import {Heading} from '@/components/Heading'
import {FooterCTA} from "@/components/FooterCTA"

export const metadata = {
  title: 'Atproto의 철학',
  description:
    'AT Protocol 설계의 근간이 되는 철학적 및 미학적 원칙에 대한 심층적인 탐구.',
}

# Atproto Ethos

*2025년 4월 4일*

*이 게시물은 Daniel Holmgren이 AtmosphereConf(2025년 3월)에서 발표한 [최근 강연](https://www.youtube.com/watch?v=1A-0k58TfPo) 의 블로그 포스트 버전입니다.*

AT Protocol (또는 atproto)은 탈중앙화 소셜 애플리케이션을 만들기 위한 프로토콜입니다. {{className: 'lead'}}

이러한 목표를 가진 프로토콜은 atproto가 처음이 아닙니다. 탈중앙화 소셜 미디어 프로토콜의 역사 속에서, atproto는 이전의 기술과 운동들로부터 깊은 영향을 받으면서도 독특한 접근 방식을 취하고 있습니다. {{className: 'lead'}}

“atproto ethos(atproto 철학)” 라는 문구는 프로토콜 설계 논의 중에 자주 등장합니다. 다소 모호한 용어일 수 있지만, 우리는 이를 네트워크 설계의 근간이 되는 철학적 및 미학적 원칙을 지칭하는 데 사용합니다. {{className: 'lead'}}

이 포스트에서는 그 철학을 추출해 볼 것입니다. 먼저 atproto에 가장 직접적인 영향을 준 기술적 흐름을 살펴봅니다. 그다음 atproto가 제시한 핵심 혁신을 끌어내고, 마지막으로 설계에 영향을 미친 몇 가지 독자적인 사고 방식을 강조할 것입니다. {{className: 'lead'}}

<Heading level={2} id="atproto-at-the-intersection-of-three-movements">세 가지 운동의 교차점에 서 있는 Atproto</Heading>

<Heading level={3} id="the-web">웹</Heading>

atproto에 가장 명확하게 영향을 준 첫 번째 요소는 웹 그 자체입니다. 

웹은 인터넷을 통해 문서를 게시하고 접근하기 위한 정보 시스템입니다. 참여와 상호작용에 있어 허가가 필요 없습니다(permissionless). 이러한 보장은 기반이 되는 인터넷의 유사한 보장에 근거합니다. 인터넷이 제대로 작동하고 컴퓨터, 인터넷 연결, IP 주소만 있다면 누구나 웹에 문서를 호스팅할 수 있습니다.

웹의 무허가성은 콘텐츠 권한의 분산을 요구합니다. 즉, 웹에 무엇을 포함할지 또는 특정 콘텐츠가 “정당한지” 여부를 결정하는 중앙 권한이 없습니다. 대신, 문서를 게시하고 호스팅하는 각 컴퓨터가 해당 문서에 대한 권한을 가집니다. 이 권한은 **위치 기반(location-based)** 입니다. 즉, 특정 사이트에 접속하여 문서를 받음으로써 해당 사이트에서 호스팅하는 문서가 무엇인지 알 수 있습니다. 당연한 소리처럼 들릴 수 있지만, 이는 사실 혁신적인 아이디어입니다. 유통업자나 문서 인증 기관, 또는 문서의 중앙 등록소도 필요하지 않기 때문입니다.

이러한 개방성이 웹의 결정적인 거버넌스 특징이라면, 결정적인 제품 기능은 하이퍼링크 입니다. 하이퍼링크는 한 문서에서 다른 문서로 이동하게 해주는 링크입니다. 특히, 이러한 하이퍼링크는 다른 권한권자의 허가 없이도 **권한의 경계를 넘어** 연결될 수 있습니다. 그 결과 웹은 고립되어 게시된 연관성 없는 문서들의 집합이 아니라, 상호 연결된 데이터의 방대한 통합 네트워크가 되었습니다.

여기서 설명한 문서 기반의 웹은 흔히 Web 1.0으로 불립니다. 하지만 지난 20년 동안 우리가 살아온 Web 2.0은 그 형태와 기능 면에서 상당히 다릅니다.

현대의 웹은 주로 사용자가 계정을 만들고 콘텐츠를 게시하거나 다른 계정의 콘텐츠를 보고 상호작용하는 페이스북이나 유튜브와 같은 소수 대형 플랫폼에서 이루어집니다. 이러한 상호작용과 콘텐츠는 종종 전통적인 의미의 “문서”처럼 보이지 않습니다. 콘텐츠는 여전히 깊이 연결되어 있지만, 그 연결은 대개 콘텐츠가 생성된 플랫폼의 경계 내로 제한됩니다.

이 새로운 웹은 참여하기가 훨씬 쉽습니다. 콘텐츠를 게시하기 위해 서버를 운영하는 법을 알거나 고정 IP 주소를 가질 필요가 없습니다. 그저 계정만 만들면 됩니다. 무엇보다 중요한 것은, 현대의 웹이 실시간 대화, 네트워크에서 일어나는 모든 일에 대한 글로벌 뷰, 그리고 이 방대한 데이터 네트워크를 통해 사용자의 관심을 유도하는 알고리즘과 같이 더 풍부하고 역동적인 콘텐츠와 상호작용을 지원할 수 있다는 점입니다.

문서 기반 웹이 현대의 웹으로 진화한 것을 웹의 실패로 보아서는 안 됩니다. 오히려 이는 웹의 성공에 대한 증거입니다. 웹의 기반이 된 아이디어, 철학, 그리고 원시 기능들은 웹 위에 사실상 제2의 레이어를 구축할 수 있을 만큼 강력하고 유연했습니다. 그러나 이 진화 과정에서 우리는 무언가를 잃어버렸습니다.

<Heading level={3} id="peer-to-peer">피어-투-피어 (Peer-to-peer)</Heading>

피어-투-피어(p2p) 운동은 여러 면에서 현대 웹을 지배하게 된 거대 플랫폼의 출현에 대한 반작용이었습니다. 이상적이고 급진적인(때로는 지나칠 정도로) p2p 운동은 백엔드 애플리케이션을 완전히 제거할 수 있는지 질문했습니다.

사용자들이 소셜 미디어 플랫폼의 콘텐츠와 상호작용을 중앙 백엔드 서비스로 보내는 대신, 관련 데이터를 자신의 장치에서 다른 장치로 직접 보내는 방식입니다. 만약 두 사용자가 서로 팔로우하고 한 명이 게시물을 올리면, 상대방은 상대의 장치와 직접 연결되어 게시물을 받게 됩니다. 물론 이는 데이터 전송을 위해 양측이 동시에 온라인 상태여야 함을 의미합니다. p2p 시스템은 데이터를 여러 장치에 복제할 수 있게 함으로써 이를 해결하려 했습니다. 따라서 사용자는 게시자로부터 직접 게시물을 받을 수도 있고, 현재 온라인 상태이며 해당 게시물을 보유하고 있는 다른 친구로부터 받을 수도 있습니다.

이를 통해 p2p는 웹의 전통적인 위치 기반 권한 모델에서 벗어나 “자기 인증 데이터(self-certifying data)” 로 이동했습니다. 데이터는 해당 데이터를 처음 생성하지 않은 장치에서도 올 수 있으며, 정식 장치에서 오는 경우라도 해당 장치에 계정과 연관된 고정 IP가 없을 수도 있습니다. 따라서 p2p 프로토콜은 데이터의 권한을 데이터의 위치가 아닌 데이터 자체로 옮겼습니다.

p2p 데이터는 종종 데이터의 해시값으로 주소가 지정되고 게시자의 개인 키로 서명됩니다. 이를 통해 콘텐츠를 임의로 재배포하면서도 게시한 사용자로부터 왔다는 완전한 권한을 유지할 수 있습니다. 따라서 클라이언트는 알려진 해시를 가진 콘텐츠를 찾기 위해 추상적인 의미의 “네트워크”에 접속하기만 하면 됩니다. 잘 작동할 때, 콘텐츠 주소 지정 네트워크는 데이터가 협력하는 장치들의 망 어딘가에 그저 “존재하는” 것 같은 아름다운 특성을 가집니다. 수신하는 데이터가 접속하는 서비스에 따라 달라지는 전통적인 위치 주소 지정 웹과 달리, p2p 시스템의 데이터는 본질적인 품질을 가집니다. 위치가 아닌 데이터가 우선순위가 됩니다.

물론 이 추상화가 항상 완벽하게 작동하는 것은 아니며, 이 새로운 토폴로지는 데이터 가용성과 발견이라는 수많은 문제를 야기했습니다. 앞서 언급했듯이, 데이터 게시자가 온라인이 아니라면 네트워크의 다른 장치에서 해당 데이터를 찾아야 합니다. 특히 장치들이 서로 다른 주소로 수시로 접속하고 끊기는 상황에서 어떤 장치가 데이터를 제공할 수 있는지 알아내는 것은 어려운 문제입니다. 그리고 찾고 있는 데이터를 보내줄 수 있는 온라인 장치가 단 하나도 없는 경우도 발생할 수 있습니다! 모든 것이 잘 작동하더라도, 네트워크 분할이 흔하고 네트워크 내에 모든 데이터에 대한 “글로벌 뷰”를 제공할 서비스가 없기 때문에 이러한 시스템은 최종 일관성(eventual consistency)에 크게 의존해야 합니다.

이러한 시스템의 또 다른 주요 문제는 사용자들이 현대 웹에서 익숙해진 풍부한 소셜 미디어 사이트들이 대규모의 컴퓨팅 및 저장 집약적인 인덱스(index)에 의존한다는 점입니다. 서버를 제거한다는 것은 그 모든 자원 사용이 사용자의 장치로 이동함을 의미했습니다. 타임라인 생성, 스레드 구성, 상호작용 수 집계, 소셜 그래프 쿼리 등 모든 작업이 상대적으로 성능이 낮은 엔드 유저 장치에서 수행되어야 했습니다.

그 결과 p2p 프로토콜로 구축된 제품들은 종종 불안정하게 느껴집니다. 게시물과 상호작용이 누락되고, 글로벌 알고리즘은 생성이 불가능하며, 이러한 애플리케이션을 실행하면 장치의 배터리 수명과 자원 사용량에 눈에 띄는 타격을 줍니다. 요컨대, 현대 웹의 거대 플랫폼들이 제공하는 매끄럽고 역동적인 느낌을 복제하는 것은 실행 불가능해 보였습니다.

<Heading level={3} id="data-intensive-distributed-systems">데이터 집약적 분산 시스템</Heading>

p2p 기술이 탐구되는 동안, 현대 웹을 구성하는 플랫폼들은 계속해서 규모가 커졌습니다. 웹 참여 장벽이 낮아짐에 따라 수백만 명, 결국 수십억 명의 사람들이 웹에 참여하고 콘텐츠를 생성하기 시작했습니다.

이러한 플랫폼의 콘텐츠는 정적으로 제공될 수 있는 단순한 문서가 아닙니다. 플랫폼들은 매일 수십억 건의 상호작용을 처리합니다. 이러한 상호작용은 프로필 페이지, 뉴스 피드, 스레드, 좋아요 수 등 사용자를 위한 풍부하고 역동적인 뷰(view)로 구성됩니다.

단순히 데이터를 처리하는 것만으로는 충분하지 않습니다. 이러한 플랫폼들은 읽기 작업이 매우 많기 때문입니다. 생성되는 모든 콘텐츠에 대해 플랫폼은 다른 사용자들로부터 수백 또는 수천 건의 요청을 처리해야 할 수도 있습니다. 플랫폼의 영향력이 커짐에 따라 가용성과 지연 시간에 대한 사용자의 기대치도 높아졌습니다. 서비스 중단이나 성능 저하는 용납되지 않으며 기업에 수백만 달러의 손실을 입힐 수도 있습니다.

이러한 모든 요소는 서비스 구축을 위한 새로운 도구와 아키텍처를 요구했습니다. 이러한 기법들에 대한 개요는 Martin Kleppmann의 저서 “데이터 중심 애플리케이션 설계”에 가장 잘 담겨 있을 것입니다. 모든 플랫폼이 똑같이 구축된 것은 아니고 수많은 경쟁 도구와 방법론이 존재하지만, 일반적인 추세를 요약해 볼 수 있습니다.

이러한 플랫폼들은 읽기 부하가 매우 크기 때문에, 일반적으로 읽기 부하와 쓰기 부하를 분리하여 각각 확장할 수 있도록 합니다. 이에 대한 간단한 버전은 데이터베이스의 읽기 복제본(read replicas)을 도입하는 것입니다. 단일 “리더(leader)” 데이터베이스가 존재하더라도, 많은 복제본이 과도한 읽기 부하를 처리하는 데 도움을 줄 수 있습니다.

그러나 데이터의 양과 플랫폼 지원에 필요한 컴퓨팅은 단일 머신으로 처리할 수 없습니다. 따라서 개별 플랫폼 배포 내에서도 작업은 여러 머신에 분산되어야 합니다. 일반적인 패턴은 애플리케이션의 조각들을 서로 호출할 수 있는 더 작은 “마이크로서비스”로 떼어낸 다음, 이러한 마이크로서비스들을 더 큰 플랫폼으로 구성하는 것입니다. 각 하위 시스템의 관심사를 분리함으로써 팀은 각 필요에 따라 확장할 수 있습니다. 예를 들어, 피드 생성은 비디오 트랜스코딩과 매우 다르며, 이러한 작업들은 각각의 워크로드에 최적화된 머신에서 호스팅되는 것이 유리합니다.

분산 시스템의 도입은 분산 시스템 특유의 문제들도 불러왔습니다. 분해된 마이크로서비스들은 플랫폼 내의 모든 데이터에 대해 강력한 일관성을 가진 뷰를 유지하는 것을 포기하게 됩니다. 어떤 경우에는 우리가 Bluesky에서 사용하는 Scylla와 같이 높은 처리량에 최적화된 최종 일관성 데이터베이스의 사용을 의미합니다. Scylla와 같은 데이터베이스는 전통적인 SQL 데이터베이스가 제공하는 ACID 보장과 풍부하고 역동적인 쿼리 지원을 포기합니다. 대신 데이터의 인덱스와 액세스 패턴을 미리 알고 있어야 합니다.

새로운 데이터베이스 기술의 도입과 마이크로서비스의 일반적인 추세는 더 많은 문제를 야기했습니다. 마이크로서비스들은 종종 동일한 데이터에 접근해야 합니다. 마이크로서비스가 일정 기간 중단되었다면, 그동안 발생한 모든 일을 따라잡을 수 있는 메커니즘이 필요합니다. 그리고 애플리케이션은 과거 데이터에 대해서도 새로운 인덱스를 생성할 수 있는 방법이 필요합니다. 스트림 처리(stream processing) 방식이 이러한 많은 질문에 답이 되었습니다. Kafka로 대표되는 스트림 처리 아키텍처에서는 시스템을 흐르는 모든 이벤트의 이벤트 로그를 유지합니다. 많은 소비자가 이 이벤트 로그를 탭(tap)합니다. 소비자가 오프라인이 되었다가 다시 돌아오면 중단된 지점부터 다시 시작할 수 있습니다. 새로운 인덱스를 생성해야 하는 경우, 전체 이벤트 로그를 단순히 재생(replay)하면 됩니다. 이러한 스트림 처리 도구는 플랫폼이 단일 진실 공급원(source of truth)을 중심으로 결합할 수 있게 해주는 정식 데이터의 “백본(backbone)” 역할을 합니다.

<Heading level={3} id="synthesis">통합</Heading>

Atproto는 이 세 가지 운동의 통합으로 자리 잡고 있습니다.

1. **웹으로부터:** 상호 연결된 콘텐츠의 개방적이고 무허가이며 보편적인 네트워크.

2. **피어 투 피어로부터:** 위치 독립적인 데이터, 자기 인증 데이터, 그리고 사용자 경험의 모든 측면에 대한 중앙 집중식 제어에 대한 회의론.

3. **데이터 집약적 분산 시스템으로부터:** 읽기/쓰기 부하의 분리, 고처리량 및 저지연을 지원하는 애플리케이션 인식 보조 인덱스, 스트리밍 정식 데이터, 그리고 모놀리스의 마이크로서비스로의 분해.

<Heading level={2} id="innovations">혁신</Heading>

이러한 기반 위에서 atproto는 두 가지 핵심 혁신을 더합니다: 아이덴티티 기반 권한과 데이터 호스팅과 그 위에 구축된 풍부한 애플리케이션의 분리 입니다.

<Heading level={3} id="identity-based-authority">아이덴티티 기반 권한</Heading>

atproto의 데이터 모델은 p2p 네트워크의 모델과 매우 유사합니다. 주요 차이점은 단순히 콘텐츠 주소 지정 방식이 아니라, 데이터를 아이덴티티 주소 지정(identity-addressed) 방식으로 만들기 위해 간접 레이어를 추가했다는 점입니다. 따라서 at-uri는 `at://username/record-type/record-key` 와 같은 형태를 띱니다.

데이터의 이러한 아이덴티티 주소 지정은 웹 기반의 위치 주소 지정 데이터 모델을 뒤집은 것입니다. 전통적인 웹에서는 위치(또는 서버)가 주요 객체이지만, atproto에서는 사용자가 주요 객체입니다.

아이덴티티는 수명이 길며 현재 수용되어 있는 위치와는 무관합니다. p2p 네트워크에서 데이터가 가졌던 우선순위는 스택의 상단에 있는 아이덴티티로 옮겨졌습니다. 아이덴티티는 특정 호스트나 애플리케이션과 독립적으로 존재하며 그 사이를 유동적으로 이동할 수 있습니다. 네트워크의 데이터는 이러한 아이덴티티로부터 흐르며, 아이덴티티를 특정 데이터 세트로 해석(resolve)하고 새로운 콘텐츠가 생성될 때 실시간 업데이트를 받는 정의된 메커니즘을 가집니다.

아이덴티티 자체는 해당 아이덴티티 데이터의 진위성을 검증할 수 있는 키 자료(key material)와 소비자가 아이덴티티 데이터의 정식 현재 상태를 받기 위해 접속할 수 있는 특정 호스트로 해석됩니다. 사용자 데이터의 이러한 정식 호스트는 개인 데이터 서버(Personal Data Servers, PDS)로 알려져 있습니다.

모든 아이덴티티를 위한 정식 호스트가 존재하지만, 해당 호스트에서 나오는 데이터는 자기 인증적이며 자기 설명적입니다. 이는 데이터가 네트워크로 임의로 재방송될 수 있음을 의미합니다. 사용자 데이터의 소비자들은 데이터의 정식 호스트에 직접 연락할 필요가 전혀 없습니다. 대신, 정식 데이터 호스트를 크롤링하여 네트워크의 특정 정의된 집합에 대한 업데이트 스트림을 출력하는 외부 서비스를 신뢰할 수 있습니다.

아이덴티티가 출력하는 데이터는 “레코드(records)”의 레포지토리(repository) 형태를 취합니다. 각 레코드는 포스트, 좋아요, 팔로우, 프로필 등 구조화된 데이터 조각입니다. 웹에서 주요 객체는 문서이며 문서는 하이퍼링크를 통해 연결됩니다. atproto에서 주요 객체는 레코드이며 레코드는 at-uri 참조를 통해 연결됩니다.

<Heading level={3} id="generic-hosting-centralized-product-development">범용 호스팅, 중앙 집중식 제품 개발</Heading>

PDS가 따르는 데이터 모델(레포지토리)은 범용적입니다. PDS 전체적으로 보면 사실 매우 간단한 일을 합니다: 사용자의 데이터를 호스팅하고 계정/아이덴티티를 관리하는 것입니다. 이 단순함은 의도된 것이며 데이터 레이어를 탄력적이고 개방된 상태로 유지하는 데 중요합니다. PDS가 애플리케이션 특화 로직이나 고비용 인덱싱 동작으로 과부하가 걸리면, 벤더 종속(vendor lock-in)과 중앙 집중화를 초래하는 유인책으로 변질될 위험이 있습니다.

PDS에서 애플리케이션 특화 세부 사항을 분리해낸 다른 측면은 애플리케이션에 애플리케이션 시맨틱을 실험하고 빠르게 반복할 수 있는 자유를 준다는 점입니다. 제품 개발은 중앙 집중식으로 이루어질 수 있습니다. 이러한 중앙 집중화는 네트워크에서 새로운 제품을 구축하는 능력에 매우 중요합니다. 우리는 제품 개발에 있어 “뒤로 물러서지 않는다” 는 태도를 취했습니다. 프로젝트는 현대적인 툴링과 제품/애플리케이션 개발 패턴을 사용할 수 있어야 합니다. 제품은 애플리케이션 도메인에 대한 명확한 소유권을 필요로 하며, 이를 통해 빠르게 반복할 수 있는 이점을 누립니다.

이러한 소유권은 스키마 ID에 소유권 개념이 포함된 atproto 네트워크의 스키마 언어에 반영되어 있습니다. 해당 스키마의 소유자는 애플리케이션의 데이터 모델을 자유롭게 반복하고 진화시킬 수 있습니다. 마찬가지로, 애플리케이션 소유자는 자신이 적합하다고 생각하는 방식으로 백엔드를 구축할 수 있습니다. atproto 네트워크의 “특이함” 에는 경계가 있습니다. 아이덴티티와 데이터가 그 임계값을 넘으면, 이를 인덱싱하고 사용자에게 보여주는 것은 애플리케이션의 결정입니다.

제품 개발은 중앙 집중식일지라도, atproto 위에 구축된 덕분에 기반이 되는 데이터와 아이덴티티는 개방되어 있고 보편적으로 접근 가능합니다. 달리 말하면, 특정 애플리케이션의 진화에 대한 소유권은 명확하지만, 데이터가 공개되어 있으므로 네트워크의 다른 누구나 이를 재사용, 리믹스 또는 확장할 수 있습니다.

<Heading level={2} id="opinionated-takes">독자적인 관점</Heading>

<Heading level={3} id="structure-gives-freedom">구조가 만드는 자유</Heading>

Atproto는 다자간의, 낮은 조정 비용을 가진 네트워크입니다. 서비스는 허가 없이 참여할 수 있고 자체 정책에 따라 운영될 수 있습니다. 조정의 고통은 어느 정도 불가피하지만, atproto는 매우 구조화된 프로토콜이 됨으로써 최악의 상황을 방지하려 합니다. 프로토콜의 많은 설계 결정에서 이를 볼 수 있습니다: 정식 CBOR로 인코딩된 레코드, 도처에 사용되는 multiformats, 저장소의 유니싯(unicit, 결정론적이며 삽입 순서에 독립적인 구조) 데이터 구조, 허용된 DID/해시 함수의 제한된 세트, 심지어 OAuth에서 DPoP을 요구하는 것까지 말이죠.

**무엇이든** 할 수 있다는 아이디어에는 힘을 실어주는 무언가가 있지만, 이는 쉽게 구조 없음의 폭정(tyranny of structurelessness)으로 빠질 수 있습니다. 즉, 조정이 붕괴되어 실제로 아무것도 완료되지 못하는 상황입니다. 네트워크에 구조가 없다면, 새로운 개발에 투입될 수 있는 에너지가 상호 운용성 촉진, 구현 간의 엣지 케이스 수정, 다른 당사자의 악의적인 행위나 보안 문제에 대한 방어 구축, 명확한 리더 없이 진화를 조정하려는 시도 등으로 분산됩니다.

이러한 구조는 atproto의 스키마 언어인 Lexicon에 가장 잘 나타나 있습니다. 상호 운용성에 대한 다른 접근 방식들은 데이터의 속성을 표현하는 일반화된 방법(RDF)을 만들거나 상호 운용성을 돕기 위해 서로 다른 도메인 간의 데이터를 변환(lenses)하려고 시도하는 반면, Lexicon은 두 대상이 같은 언어를 말하고 있는지 판단하는 방법을 제공하고 데이터가 적절하게 포맷되었는지 보장하는 매우 구조화된 메커니즘을 제공합니다.

이를 통해 atproto는 “비슷한 이야기를 하고 있지만 실제로는 그렇지 않은” 회색 지대를 피하고, 애플리케이션이 같은 것에 대해 이야기하고 있다면 **정확히** 같은 방식으로 이야기하도록 강제합니다. 의미론의 보편성을 가정하는 대신, atproto는 구체적인 의미론을 촉진하고 해당 의미론의 협업과 확장을 허용합니다.

<Heading level={3} id="lazy-trust">지연된 신뢰</Heading>

웹은 상호작용하는 서비스에 대해 상당한 신뢰를 요구합니다. 전송 계층은 보안이 유지되지만, 특정 서버로부터 받는 데이터는 오직 그 서버로부터 받았다는 사실에 의해서만 증명됩니다. 예를 들어 페이스북에서 친구의 포스트를 불러올 때, 페이스북이 올바른 포스트 텍스트를 제공하고 있다고 믿어야 합니다. 마찬가지로 페이스북이 사용자의 계정과 데이터를 잘 관리하고 있다고 믿어야 합니다.

p2p 네트워크는 완전히 신뢰가 필요 없는 급진적인 방식을 취했습니다. 자신의 클라이언트 장치만 믿으면 되고, 그게 전부입니다. 소프트웨어가 클라이언트에서 실행되고 신뢰가 데이터 자체에 깃들어 있기 때문에, 네트워크의 다른 서비스나 행위자에 대한 신뢰가 필요하지 않습니다.

Atproto는 우리가 때때로 “지연된 신뢰(lazy trust)” 라고 부르는 중간적인 접근 방식을 취합니다. p2p 네트워크처럼 신뢰는 데이터에 깃들어 있습니다. 그러나 네트워크를 탐색할 때 사용자는 정식 데이터가 아닌 계산된 뷰(computed views)를 보는 경우가 많습니다. 예를 들어 타임라인을 볼 때 클라이언트는 내려오는 모든 포스트의 서명을 일일이 확인하지 않을 가능성이 높습니다. 이는 정식 데이터가 항상 가까이에 있다는 사실로 보완됩니다. 따라서 이러한 계산된 뷰를 제공하는 서비스는 자신이 제공하는 모든 뷰에 *자신의 명성을 걸고(staking its reputation)* 있는 셈입니다. 만약 서비스가 잘못된 뷰를 제공하기 시작하면 이는 검증 가능하게 입증될 수 있습니다. 그리고 데이터가 공개되어 잠겨 있기 때문에 사용자는 더 잘 동작하는 다른 서비스로 이주할 수 있습니다.

또한 p2p 네트워크와 달리, 사용자는 자신의 데이터와 아이덴티티 정보를 호스팅하는 지속적인 백엔드(PDS)와 관계를 유지합니다. 특히 (atproto의 필수 요구 사항은 아니지만) 우리는 서명 키를 백엔드로 옮기는 결정을 내렸습니다. 이는 클라이언트 측 키와 관련된 복잡한 키 관리 UX 문제를 방지합니다. 하지만 그로 인해 사용자 제어권의 명백한 손실이 발생합니다. 이 또한 지연된 신뢰로 완화됩니다. 신뢰는 아이덴티티 시스템의 한 단계 위 레이어로 이동하여, 사용자가 자신의 아이덴티티에 대한 복구 키(recovery key)를 보유함으로써 나쁜 PDS로부터 벗어날 수 있게 합니다.

신뢰할 수 있는 방식으로 운영하는 것은 본질적으로 신뢰 없이 운영하는 것보다 효율적입니다. 일반적으로 이는 높은 신뢰 환경에서 운영할 때 얻을 수 있는 성능 및 UX 이점을 활용하려는 atproto의 철학을 나타냅니다. 그러나 그렇게 할 때 항상 신뢰할 수 있는 이탈(credible exit) 가능성을 유지하고, 악의적인 행위자와 부실한 서비스 제공자에 대비한 견제와 균형 시스템을 유지해야 합니다.

<Heading level={2} id="conclusion">결론</Heading>

이 모든 것을 고려하면 프로토콜과 네트워크의 일반적인 형태가 나타납니다. 

AT Protocol은 웹의 철학 위에 p2p 프로토콜의 기술과 데이터 집약적 분산 시스템의 관행을 결합하여 구축되었습니다.

우리는 아이덴티티를 최우선으로 여기고 이를 프로토콜 설계의 중심에 둡니다. 정식 사용자 데이터는 유동적이고 상품화된 호스팅 네트워크에 존재하며, 그 위에 풍부한 애플리케이션이 구축될 수 있도록 합니다.

그리고 우리는 이 네트워크를 설계함에 있어 구조의 편에 서서 가능한 한 높은 신뢰 환경의 이점을 취하려 노력하되, 관계가 틀어질 경우를 대비해 언제나 신뢰할 수 있는 이탈을 허용합니다.

이 내용이 흥미로우시다면, [프로토콜 사양(specs)](https://atproto.com/specs/atp) 을 확인하거나 프로토콜 위에 구축된 [Statusphere](https://github.com/bluesky-social/statusphere-example-app) 예제 앱을 직접 살펴보며 더 깊이 알아볼 수 있습니다.

<FooterCTA href="/" title="더 알아볼 준비가 되셨나요?" description="사양, 가이드 및 SDK를 여기에서 찾을 수 있습니다." />