export const metadata = {
  title: '라벨',
  description:
    '모더레이션 및 기타 목적으로 사용되는 계정 또는 콘텐츠에 대한 자체 인증 문자열 주석.',
}

# 라벨

**라벨**은 atproto 생태계 내의 모든 계정 또는 콘텐츠에 관한 메타데이터입니다. {{ className: 'lead' }}

라벨은 독립적인 자체 인증 데이터 객체로 존재하지만, 종종 API 응답의 일부로 배포되기도 합니다(이 경우 서명이 포함되지 않을 수 있음). 또한 라벨의 "값"은 레코드 내에 직접 포함될 수 있는데, 이를 "셀프 라벨"이라고 합니다. {{ className: 'lead' }}

라벨은 주로 발행자(DID), 대상(URI) 및 값으로 구성됩니다. 값은 태그나 해시태그와 유사한 짧은 문자열이며, 라벨의 생성자와 수신자 간에 미리 정의된 의미를 갖는다고 가정됩니다. 추가 메타데이터 필드는 부가적인 문맥을 제공할 수 있으나, 언제든지 발행자, 대상, 값의 조합에 대해 하나의 일관된 메타데이터 집합만 존재해야 합니다. 만약 여러 개의 메타데이터 집합이 존재한다면, `created-at` 타임스탬프를 사용하여 현재 유효한 라벨을 구분합니다. {{ className: 'lead' }}

라벨 개념 및 프로토콜 기본 요소는 범위, 사용 사례, 데이터 전송 방식에 있어 유연합니다. 원래 설계 동기 중 하나는 모더레이션 서비스를 통해 생성된 라벨을 사용하여 조합형 모더레이션을 가능하게 하는 것이었습니다. 하지만 라벨은 모더레이션에 국한되지 않으며, atproto 애플리케이션 내에서 다른 용도로도 자유롭게 재사용될 수 있습니다. {{ className: 'lead' }}

핵심 라벨 스키마는 버전 관리되며, 이 문서는 라벨 버전 `1`에 대해 설명합니다. {{ className: 'lead' }}

## 스키마 및 데이터 모델

라벨은 저장소 커밋이나 MST 노드와 유사한 프로토콜 객체입니다. 라벨은 서명을 위해 DAG-CBOR(엄격하고 정규화된 CBOR의 하위 집합)로 정식 인코딩됩니다(아래 섹션 참조). 라벨을 표현하는 Lexicon 정의(`com.atproto.label.defs#label`)가 있으나, 핵심 프로토콜 객체와 약간 다른 필드 요구사항을 가지고 있습니다: 버전 필드(`ver`)와 서명(`sig`)은 해당 버전에서는 선택 사항입니다.

라벨 객체의 필드는 다음과 같습니다:

- `ver` (정수, 필수): 라벨 스키마 버전. 현재 버전은 항상 `1`입니다.
- `src` (문자열, DID 형식, 필수): 이 라벨을 생성한 주체(계정).
- `uri` (문자열, URI 형식, 필수): 라벨이 적용되는 콘텐츠. 특정 레코드의 경우 `at://` URI, 계정의 경우 `did:` 형식.
- `cid` (문자열, CID 형식, 선택 사항): 제공될 경우, 라벨은 대상 `uri`의 특정 버전에 적용됩니다.
- `val` (문자열, 최대 128바이트, 필수): 라벨의 값. 아래에서 논의하는 의미와 선호하는 구문을 따릅니다.
- `neg` (불리언, 선택 사항): `true`로 설정되면, 동일한 `src`, `uri`, `val`을 가진 이전 라벨을 “무효화”함을 나타냅니다.
- `cts` (문자열, 날짜시간 형식, 필수): 라벨이 생성된 시각. 분산 시스템에서는 타임스탬프가 기본적으로 신뢰할 수 없거나 검증되지 않는 점에 유의하십시오.
- `exp` (문자열, 날짜시간 형식, 선택 사항): 이 라벨의 유효기간이 끝나는 시각.
- `sig` (바이트, 선택 사항): 암호화 서명 바이트. 이는 [데이터 모델](/specs/data-model)의 `bytes` 타입을 사용하며, JSON에서는 base64 인코딩된 `$bytes` 객체로 표현됩니다.

라벨이 전체 객체로서 서비스 간에 전송될 때는 `ver` 및 `sig` 필드가 필수입니다.

`neg` 필드가 `false`인 경우, 필드를 포함하지 않는 것이 최선의 관행입니다.

짧은 세 글자 필드 이름을 사용하는 것은 atproto의 다른 부분과 다르며, JWT와 더 밀접하게 정렬됩니다. 이는 네트워크 요청 및 응답에 다수의 라벨이 포함될 때 크기를 최소화하기 위함입니다.

## 값

`val` 필드는 라벨의 핵심입니다. 프로토콜의 유연성을 유지하고, 향후 온톨로지, 규범, 거버넌스 구조의 발전을 허용하기 위해, 이 문자열의 의미, 동작, 그리고 알려진 값에 대해 여기서는 거의 명시하지 않습니다.

현재 라벨 값 문자열은 미리 정해진 어휘를 가진 "토큰"으로 사용되는 것이 바람직하며, 해시태그와 유사합니다.

현재 시점에서 다음 패턴은 *사용하지 않을 것*을 강력히 권장합니다:

- 값 필드 내에 추가 구조를 포함하는 것 (예: base64 인코딩 데이터, key/value 구문, 값의 리스트나 배열 등)
- 임의의 숫자 값(예: "점수"나 "신뢰도") 인코딩
- 구분을 위해 구두점 문자 사용 (예: `.`, `:`, `;`, `#`, `_`, `'`, `>` 등)
- 값에 URL 또는 URI 인코딩
- 공백 문자 사용
- 비ASCII 문자(이모지 포함) 사용

이러한 아이디어들도 매력적이지만, 구문 확장에 대해 보다 공식적으로 지정하기 위한 조율을 희망합니다.

현재 한 가지 관례는 시스템 레벨 라벨을 나타내기 위해 느낌표(`!`)를 접두사로 사용하는 것입니다. 이는 대상에 대해 기대되는 행동을 지정하지만 콘텐츠 자체를 설명하거나 그 이유를 나타내지는 않습니다. 예를 들어, `!warn`은 경고 행동을 나타내며, `scam`은 설명적 라벨로 같은 경고 행동을 유발할 수 있습니다.

라벨의 행동, 정의, 의미, 정책은 일반적으로 다른 문서를 통해 전달됩니다. 값이 반드시 전부를 설명할 필요는 없습니다.

### 권장 문자열 구문

현재 라벨 값 문자열에 대한 권장 구문은 소문자 케밥 케이스(kebab-case)로, ASCII 문자만 사용하며 내부적으로 `-`를 사용하는 것입니다. 구체적으로:

- 소문자 알파벳 ASCII 문자 (`a` ~ `z`)
- 내부 구분자로 사용되는 대시(`-`): 단, 처음이나 마지막에 오지 않아야 함
- 기타 구두점이나 공백 문자는 사용하지 않음
- 최대 128바이트. 가능한 한 짧게(최대 몇십 자 내외) 유지하되, 어느 정도 설명력을 갖추도록 합니다.

## 라벨 수명 주기: 무효화와 만료

라벨은 일반적으로 수신 서비스에 의해 브로드캐스트되고 내부적으로 저장됩니다. 일부 서비스는 라벨을 다운스트림 서비스에 재배포할 수 있으며, API 응답에 포함될 때 라벨 서명이 제거될 수 있습니다.

라벨을 API 응답에 포함할 때는 일반적으로 "활성" 상태이며 관련 있는 라벨만 포함해야 합니다.

라벨의 권위 있는 생성자가 라벨을 취소하거나 제거하고자 할 경우, 동일한 발행자, 대상, 값을 가지되 `neg` 필드를 `true`로 설정하고 최신 타임스탬프를 가진 새로운 라벨을 발행합니다. 무효화 라벨은 이전 라벨의 반대를 “참”으로 만드는 것이 아니라, 이전 라벨을 무시해야 함을 의미합니다. 예를 들어, 값이 `spam`인 라벨에 `neg`가 `true`로 설정되었다고 해서 대상이 *스팸이 아니다*라는 의미는 아니며, 단지 이전의 `spam` 라벨을 무시해야 함을 나타냅니다.

유효한 무효화 라벨을 수신한 서비스는 내부적으로 이를 저장하고 재배포할 수 있으나, API 응답에 무효화된 라벨은 포함하지 않아야 합니다.

마찬가지로, 만료 시각이 지난 라벨은 저장될 수 있으나 API 응답에 포함해서는 안 됩니다.

## 서명

라벨은 공개키 [암호화](/specs/cryptography)를 사용하여 서명됩니다. 서명은 저장소 커밋 객체와 유사하게 생성됩니다. 서비스 간 라벨 전송 시 서명을 검증해야 하며, 대부분의 최종 클라이언트는 서명을 직접 검증하지 않고 네트워크 효율성을 위해 API 응답에서 서명을 제거할 수 있습니다. 클라이언트 및 기타 당사자는 개별 라벨에 대해 라벨 발행자의 서명을 질의하고 전체 라벨(서명 포함)을 수신함으로써 서명을 검증할 수 있는 메커니즘을 가져야 합니다.

서명 또는 서명 검증 절차는 라벨의 모든 스키마 필드를 포함하여 완전한 버전의 라벨을 구성하는 것으로 시작하며, `sig` 필드는 제외합니다. 이는 `ver` 필드는 포함하지만, Lexicon 표현에 있을 수 있는 `$type` 필드나 기타 명시되지 않은 필드는 포함하지 않는다는 의미입니다. 이 데이터 객체는 DAG-CBOR 정규화 규칙(결정론적 IPLD/DAG-CBOR)을 따르는 CBOR로 인코딩됩니다. 인코딩된 CBOR 바이트는 SHA-256으로 해시되고, 이 해시의 직접 바이트(16진수 문자열이 아님)를 적절한 암호화 키를 사용해 서명(또는 검증)합니다. 서명 바이트는 `sig` 필드에 바이트 형태로 저장됩니다(자세한 내용은 [데이터 모델](/specs/data-model)을 참조).

라벨 서명에 사용되는 키는 발행자 DID 문서 내에 있으며, 조각 식별자 `#atproto_label`을 가집니다. 이 키는 저장소 서명에 사용되는 `#atproto` 키와 동일할 수도 있습니다. 현재로서는 DID 문서에 `#atproto_label` 키가 없을 경우, 다른 키로 서명을 검증하려 해서는 안 되며, 단순히 서명을 무효한 것으로 간주하고 라벨을 무시해야 합니다.

### 서명 수명 주기

라벨을 수신할 때 서명이 검증되며, API 응답에 포함되기 전에는 재검증할 필요가 없습니다.

서명 키의 교체는 대규모 라벨링 서비스에 있어 어렵고 파괴적일 수 있습니다. 교체 절차는 다음과 같습니다:

- 라벨링 서비스는 라벨과 함께 서명을, 그리고 서명에 사용된 키에 대한 표시기를 함께 저장해야 합니다.
- 교체를 시작할 때는 새로운 서명 생성 작업을 일시 중지합니다.
- DID 문서를 업데이트하여 새로운 키를 등록합니다.
- 새로운 키로 라벨 서명을 재개합니다.
- 이전 라벨에 대해 질의 시, 사용된 키를 확인하고, 구버전이면 해당 배치의 라벨을 재서명하여 저장합니다. 이때 `created-at` 타임스탬프는 변경되지 않아야 합니다.
- 이벤트 스트림 기간 동안의 구버전 라벨은 서명이 유효하지 않을 수 있으며, 이는 허용됩니다.

유효하지 않은 서명이 있는 라벨을 만날 경우, 좋은 방법은 발행자의 DID 문서를 재조회하여 업데이트된 서명 키가 있는지 확인하는 것입니다. 만약 있다면, 서명 검증을 재시도해야 합니다.

다운스트림 서비스는 상위 키 교체 시, 구버전 라벨에 대해 일괄적으로 업데이트된 서명을 질의할지, 필요 시에 따라 개별적으로 질의할지, 아니면 구버전 서명이더라도 유효하다고 판단할지를 결정할 수 있습니다.

## 레코드 내 셀프 라벨

Lexicon 디자인 패턴 중 하나는 레코드 내부에 라벨 값 배열을 포함하는 것입니다. 다운스트림 클라이언트는 이를 외부 소스에서 온 라벨과 유사하게 "셀프 라벨"로 해석할 수 있습니다.

저장소 데이터 저장 메커니즘은 전체 라벨 객체와 유사한 문맥 및 수명 주기를 제공합니다:

- 라벨의 발행자는 저장소를 제어하는 계정입니다.
- 대상은 레코드 자체이거나 상황에 따라 전체 저장소 계정일 수 있습니다.
- CID는 레코드의 현재 버전을 나타냅니다.
- 레코드의 삭제나 업데이트를 통해 라벨 집합이 변경되므로, 무효화 및 만료 처리가 필요하지 않습니다.
- 생성 시각은 레코드 자체의 `createdAt` 필드와 동일합니다.
- 저장소 커밋 서명 메커니즘에 의해 진위(서명)가 보장됩니다.

## 라벨러 서비스 정체성

라벨러 서비스는 각각 서비스 정체성(DID 문서)을 가지고 있으며, 이는 라벨의 발행자(`src`) 필드에 나타납니다.

DID 문서에는 라벨 서명에 사용되는 키(식별자 `#atproto_label`)와 서비스 엔드포인트(식별자 `#atproto_labeler`, 타입 `AtprotoLabeler`)가 포함되며, 이는 서버 URL(메서드, 호스트 이름, 선택적 포트, 단 경로 세그먼트 없음)을 나타냅니다. 실제 사용 사례에서는 기본 포트(443)의 HTTPS 사용이 강력히 권장되며, 서비스 운영자가 이를 요구할 수 있습니다.

일부 애플리케이션에서는 정체성이 atproto 저장소(“declaration record”)를 포함할 수 있으며, 이는 라벨러에 대한 애플리케이션 별 문맥 정보를 설명합니다. 이는 특정 애플리케이션, 클라이언트 또는 AppView와의 통합을 위해 필요할 수 있으나, atproto 기본 수준에서는 필수 사항이 아닙니다.

## 라벨 배포 엔드포인트

라벨러 서비스가 라벨을 배포하기 위해 정의된 두 가지 Lexicon 엔드포인트는 다음과 같습니다:

- `com.atproto.label.subscribeLabels`: 새로운 라벨을 브로드캐스트하는 이벤트 스트림(WebSocket) 엔드포인트. 저장소 이벤트 스트림과 유사한 `seq` 백필 메커니즘을 구현하지만, 일부 차이점이 있습니다. 예를 들어, 백필 기간이 `cursor=0`까지 확장되어 전체 라벨 이력이 스트림을 통해 제공될 수 있습니다. 삭제된 라벨의 경우 원본 라벨은 스트림에서 제거되지만, 무효화 라벨은 남아 있습니다.
- `com.atproto.label.queryLabels`: 유연한 질의를 위한 엔드포인트. 커서를 사용하여 모든 라벨을 스크롤할 수 있으며, 특정 대상과 관련된 라벨로 필터링할 수도 있습니다.

공개 저장소 콘텐츠와 달리, 라벨은 반드시 공개적으로 열람 가능할 필요는 없습니다. 라벨러 서비스가 이 엔드포인트를 통해 모든 라벨을 공개할 수도 있고, 인증 및 접근 제어를 요구하거나, 또는 전혀 구현하지 않을 수도 있습니다(다른 라벨 배포 메커니즘이 있을 경우).

## 라벨러 HTTP 헤더

라벨은 종종 atproto 서비스(예: AppView)에 의해 HTTP API 응답에 “수화(hydrate)”됩니다. 클라이언트가 포함할 라벨 소스를 제어할 수 있도록 두 개의 특별 HTTP 헤더가 사용되며, PDS 구현체는 요청을 프록시할 때 이를 그대로 전달해야 합니다:

- `atproto-accept-labelers`: 요청 시 사용. 라벨러 서비스 DID 목록과 선택적 DID별 플래그 목록.
- `atproto-content-labelers`: 응답 시 사용. 구문, 내용, 의미는 `accept` 헤더와 동일하며, 실제로 질의 가능한 라벨러를 나타냅니다. 이 헤더에 DID가 포함되었다고 해서 해당 DID의 라벨이 반드시 포함되는 것은 아니며, 단지 포함되었을 경우 질의가 가능함을 의미합니다.

이 헤더들의 구문은 IETF RFC-8941("HTTP를 위한 구조화 필드 값")의 섹션 3.1.2("매개변수")를 따릅니다. 값은 쉼표(ASCII `,`)로 구분되며, 동일 헤더의 반복 선언 시 값은 하나의 목록으로 병합됩니다. 항목 값 뒤에는 하나 이상의 선택적 매개변수가 세미콜론(ASCII `;`)으로 구분되어 따라올 수 있습니다. 불리언 매개변수의 경우, RFC의 전체 구문(예: false의 경우 `param=?0`)은 현재 지원되지 않습니다. 대신, 매개변수가 존재하면 “true”로, 없으면 “false”로 간주합니다. 현재는 정수나 문자열과 같은 다른 매개변수 타입은 지원되지 않습니다.

현재 지원되는 유일한 매개변수는 불리언 매개변수 `redact`입니다. 이 플래그는 라벨 수화를 수행하는 서비스가 프로토콜 레벨의 라벨 값 `!takedown` 및 `!suspend`를 단순히 라벨링하는 대신, API 응답에서 콘텐츠를 전면적으로 삭제하도록 처리해야 함을 나타냅니다. 이 경우, 애플리케이션 별로 라벨러 정보를 표시하는 “툼브스톤” 항목이 생성되거나, 별도의 툼브스톤 없이 콘텐츠가 제거될 수 있습니다.

다음은 이러한 헤더의 완전한 예시 구문입니다:

```
# 요청 시
atproto-accept-labelers: did:web:mod.example.com;redact, did:plc:abc123, did:plc:xyz789

# 응답 시:
atproto-content-labelers: did:web:mod.example.com;redact, did:plc:abc123, did:plc:xyz789
```

요청 헤더의 구문이 잘못되었거나 파싱할 수 없는 경우, 서비스는 헤더를 무시하는 대신 오류를 반환해야 합니다.

헤더에 동일한 라벨러 DID가 반복해서 포함된 경우, 각 인스턴스의 매개변수를 결합해야 합니다. 예를 들어, 한 번은 `redact`가 포함되고 다른 한 번은 포함되지 않은 경우, 해당 DID는 단 한 번, `redact`가 포함된 것으로 처리해야 합니다. 응답 헤더 `atproto-content-labelers`는 요청 헤더가 중복 제거되고 해석된 결과를 나타냅니다.

요청 헤더가 전혀 제공되지 않을 경우, 서비스는 기본값을 대체할 수 있습니다. 이는 값이 없는 헤더를 제공하는 것과는 구분되며, 이 경우 서비스는 어떠한 라벨도 수화하거나 적용해서는 안 됩니다.

헤더에 올바른 구문으로 표시된 라벨러 DID라도, 해당 정체성이 존재하지 않거나 DID 문서에 라벨러 서비스 또는 키 항목이 포함되어 있지 않거나, 서비스 차원에서 중단되었거나, 그 외 비활성 상태인 경우, 해당 라벨러는 응답 헤더에 포함되지 않아야 하며, 오류로 처리할 필요는 없습니다.

서비스 구현체는 정책 상 특정 조건을 요구할 수 있으며, 그렇지 않을 경우 오류를 반환할 수 있습니다. 예를 들어, 특정 라벨러 DID가 반드시 포함되어야 한다거나, 허용되는 라벨러 수 혹은 `redact` 플래그가 있는 라벨러의 최소 또는 최대 수가 정해져 있을 수 있습니다.

## 보안 고려사항

라벨 서명에는 "도메인 구분"이 없으므로, 동일한 객체(및 서명)가 전혀 다른 컨텍스트에서 유효할 수 있는 위험이 존재합니다. 이는 서명 대상 객체에 예상치 못한 추가 필드가 포함되지 않도록 하는 것이 중요함을 의미합니다.

## 사용 및 구현 가이드라인

현재 시점에서는 라벨 값에 대해 “권장 문자열 구문”을 따르는 것이 강력히 권장됩니다.

## 향후 변경 가능 사항

향후 라벨 값에 대한 거버넌스, 네임스페이싱, 스타일 가이드에 대한 보다 성숙한 권고안이 마련될 수 있습니다.