export const metadata = {
  title: '레포지토리',
  description: '공개 계정 콘텐츠를 위한 자가 인증 스토리지',
}

# 레포지토리

AT Protocol의 공개 atproto 콘텐츠(**레코드**)는 계정별 레포지토리(종종 **repo**로 축약됨)에 저장됩니다. 현재 활성화된 모든 레코드는 레포지토리에 저장되며, 현재의 레포지토리 내용은 공개적으로 접근 가능합니다. 다만, 콘텐츠 삭제와 계정 삭제 모두 완벽하게 지원됩니다. {{ className: 'lead' }}

레포지토리 데이터 구조는 콘텐츠 주소 지정 방식(머클 트리, [Merkle-tree](https://ko.wikipedia.org/wiki/Merkle_트리))을 따르며, 레포지토리 내용의 모든 변경(예: 레코드의 추가, 제거, 업데이트)은 새로운 커밋의 `data` 해시 값(CID)을 생성합니다. 커밋은 회전 가능한 서명 키로 암호화 서명되어, 전체 또는 일부 콘텐츠의 재귀적 검증이 가능합니다. {{ className: 'lead' }}

레포지토리와 그 내용은 이진 [DAG-CBOR](https://ipld.io/docs/codecs/known/dag-cbor/) 형식으로, 서로의 콘텐츠 해시(CID 링크)를 참조하는 데이터 객체의 그래프로 정규적으로 저장됩니다. 큰 이진 블롭은 레포지토리에 직접 저장되지 않고 해시([CID](https://github.com/multiformats/cid))로 참조됩니다. 여기에는 이미지 및 기타 미디어 객체가 포함됩니다. 레포지토리는 오프라인 백업, 계정 이전 또는 기타 목적을 위해 [CAR](https://ipld.io/specs/transport/car/carv1/) 파일로 내보낼 수 있습니다. {{ className: 'lead' }}

atproto 페더레이션 아키텍처에서는 계정 레포지토리의 공식적인 위치가 관련된 개인 데이터 서버(PDS)입니다. 계정의 현재 PDS 위치는 DID 문서에서 공식적으로 명시됩니다. {{ className: 'lead' }}

실제 사용에서는 개별 레포지토리가 수십 개에서 수백만 개의 레코드를 포함할 것으로 예상됩니다. {{ className: 'lead' }}

## 데이터 레이아웃

레포지토리의 내용은 [Merkle Search Tree (MST)](https://hal.inria.fr/hal-02303490/document)를 사용하여 단일 루트 해시로 상태를 축소합니다. 이는 다음과 같은 레이아웃으로 시각화할 수 있습니다:

```
┌────────────────┐
│     Commit     │  (Signed Root)
└───────┬────────┘
        ↓
┌────────────────┐
│   Tree Nodes   │
└───────┬────────┘
        ↓
┌────────────────┐
│     Record     │
└────────────────┘
```

모든 노드는 [IPLD](https://ipld.io/) 객체 ([dag-cbor](https://ipld.io/docs/codecs/known/dag-cbor/))로, [CID](https://github.com/multiformats/cid) 해시를 통해 참조됩니다. 위 다이어그램의 화살표는 CID 참조를 나타냅니다.

이 레이아웃은 [AT URI](/specs/at-uri-scheme)에 반영되어 있습니다:

```
루트       | at://alice.com
컬렉션     | at://alice.com/app.bsky.feed.post
레코드     | at://alice.com/app.bsky.feed.post/1234
```

데이터 레포지토리에 대한 “커밋”은 단순히 루트 노드의 CID에 대해 키페어로 서명한 것입니다. 레포지토리의 각 변경은 새로운 커밋 노드를 생성합니다.


## 레포지토리 데이터 구조 (v3)

이 문서는 레포지토리 이진 형식의 버전 `3`에 대해 설명합니다.

버전 `2`는 약간 다른 커밋 객체 스키마를 가졌으나, 대부분 버전 `3`과 호환됩니다.

버전 `1`은 다른 MST 팬아웃 구성과, 커밋 및 레포지토리 메타데이터에 대해 호환되지 않는 스키마를 사용했습니다. 버전 `1`은 더 이상 사용되지 않으며, 네트워크 상에 이 형식의 레포지토리는 존재하지 않고 구현체도 이를 지원할 필요가 없습니다.

높은 수준에서, 레포지토리는 키/값 매핑이며, 키는 경로명(문자열)이고 값은 레코드(DAG-CBOR 객체)입니다.

**머클 검색 트리(Merkle Search Tree, MST)** 가 이 매핑을 저장하는 데 사용됩니다. 이 콘텐츠 주소 지정 방식의 결정적 데이터 구조는 키를 정렬된 순서로 저장하여, 키 조회, 범위 스캔, 그리고 (레코드 경로가 정렬되어 있다고 가정할 때) 추가 연산을 비교적 효율적으로 수행할 수 있습니다. 일반적인 MST의 속성은 아래의 학술 출판물에서 설명됩니다:

> Alex Auvolat, François Taïani. Merkle Search Trees: Efficient State-Based CRDTs in Open Networks. SRDS 2019 - 38th IEEE International Symposium on Reliable Distributed Systems, Oct 2019, Lyon, France. pp.1-10, ff10.1109/SRDS.2019.00032 ([pdf](https://inria.hal.science/hal-02303490/document))

atproto 레포지토리에서 사용되는 MST의 구체적인 세부 사항은 아래에 설명되어 있습니다.

레포지토리 경로는 문자열이며, MST 키는 바이트 배열입니다. 둘 다 빈 문자열(길이 0)이 될 수 없습니다. 레포지토리 경로 문자열은 현재 ASCII의 하위 집합으로 제한되어 있어 인코딩이 필요 없으나, 인코딩은 UTF-8로 지정되어 있습니다.

레포지토리 경로는 현재 `<collection>/<record-key>`의 고정 구조를 가집니다. 이는 유효하고 정규화된 [NSID](./nsid) 뒤에 `/`가 오고, 그 뒤에 유효한 [Record Key](./record-key)가 오는 형식입니다. 경로는 선행 슬래시(`/`)로 시작해서는 안되며, 항상 정확히 두 개의 경로 세그먼트로 구성되어야 합니다. 전체 경로 문자열에 허용되는 ASCII 문자는 현재 다음과 같습니다: 영문자(`A-Za-z`), 숫자(`0-9`), 슬래시(`/`), 점(`.`), 하이픈(`-`), 밑줄(`_`), 물결표(`~`). 특정 경로 세그먼트인 `.` 및 `..`는 유효한 NSID 또는 Record Key가 아니므로, 레포지토리 경로에서는 항상 허용되지 않습니다.

동일한 컬렉션 내의 모든 레코드의 레포지토리 경로는 MST에서 함께 정렬되므로, 열거(키 스캔) 및 내보내기가 효율적입니다. 또한, TID Record Key 체계는 컬렉션 내에서 MST 키의 연대순으로 정렬할 수 있도록 의도적으로 설계되었습니다. 이는 트리 내에서 무작위 삽입이나 수정보다 추가 작업이 효율적이며, 컬렉션 내 레코드를 열거할 때 시간 순서대로 나열됩니다(단, TID 생성이 올바르게 이루어졌다는 전제 하에 일반적으로 신뢰할 수 있습니다).


### 커밋 객체

레포지토리의 최상위 데이터 객체는 서명된 커밋입니다. 데이터 필드는 다음과 같습니다:

- `did` (문자열, 필수): 레포지토리에 연결된 계정의 DID로, 엄격하게 정규화된 형식(예: 소문자 등)이어야 합니다.
- `version` (정수, 필수): 이 레포지토리 형식 버전의 고정 값 `3`
- `data` (CID 링크, 필수): 레포지토리 내용 트리 구조(MST)의 최상위 노드를 가리키는 포인터
- `rev` (문자열, TID 형식, 필수): 레포지토리 개정판으로, 논리적 시계로 사용됩니다. 단조 증가해야 하며, 현재 타임스탬프를 TID로 사용하는 것이 권장됩니다. (약간의 오차 범위를 벗어난 미래의 `rev` 값은 무시되어야 합니다.)
- `prev` (CID 링크, nullable): 이 레포지토리의 이전 커밋 객체를 해시로 가리키는 포인터입니다. 이는 히스토리 체인을 구성할 수 있으나, 대부분 사용되지 않으며(버전 `2`와의 하위 호환성을 위해 포함됨), 버전 `3` 레포지토리에서는 이 필드가 CBOR 객체에 반드시 존재해야 하지만 사실상 항상 `null`입니다.  
  > **참고:** 이전에는 nullable 및 선택적이었으나, 이는 상호 운용성 문제를 일으켰습니다.
- `sig` (바이트 배열, 필수): 이 커밋의 암호화 서명을 원시 바이트 형태로 저장

UnsignedCommit 데이터 객체는 `sig`를 제외하고 동일한 필드를 가집니다. 커밋 서명의 절차는 모든 데이터 필드를 채운 후, DAG-CBOR로 UnsignedCommit을 직렬화하는 것입니다. 출력된 바이트는 SHA-256으로 해시되며, 이 바이너리 해시 결과(16진수 인코딩 없이)를 계정의 현재 "서명 키"로 서명합니다. 서명은 원시 바이트 형태로 커밋 객체에 저장됩니다.

서명된 커밋 객체의 CID는 해당 객체를 DAG-CBOR로 직렬화하여 생성됩니다. 아래 "blessed" CID 형식에 관한 주의사항을 참고하시고, 특히 커밋 객체에 링크할 때는 반드시 `dag-cbor` 멀티코덱을 사용해야 합니다.

서명 자체나 서명된 커밋은 사용된 키의 종류(곡선 유형) 또는 특정 공개 키 정보를 나타내지 않습니다. 해당 정보는 계정의 DID 문서에서 가져와야 합니다. 키 회전이 발생할 경우, 이전 커밋 서명의 검증이 모호해질 수 있으므로, 가장 최근의 커밋은 항상 현재의 DID 문서를 사용하여 검증되어야 합니다. 이는 서명 키 회전 시마다 새로운 레포지토리 커밋이 생성되어야 함을 의미합니다. (이 경우, `data` CID 링크는 업데이트할 필요가 없습니다.)


### MST 구조

높은 수준에서, 레포지토리 MST는 키/값 매핑으로, 키는 빈 문자열이 아닌 바이트 배열이며, 값은 레코드에 대한 CID 링크입니다. 이 MST 데이터 구조는 바이트 문자열-대-CID 매핑만으로도 완전히 재현 가능하며, 최상위 CID 해시(커밋 객체의 `data` 필드)는 내용에 따라 정확히 재생산됩니다.

트리 구조의 모든 노드는 키/CID 매핑 집합과 하위 트리 노드에 대한 링크를 포함합니다. 노드 내의 항목과 링크는 키의 정렬 순서대로 배열되며, 하위 트리 노드(재귀적으로)의 모든 키는 해당 링크 범위 내에 속합니다. 정렬 순서는 **왼쪽**(사전 순으로 가장 앞)부터 **오른쪽**(사전 순으로 뒤)까지입니다.

각 키는 해당 키 자체로부터 파생된 **깊이**를 가지며, 이 깊이가 키가 배치될 하위 트리를 결정합니다. 트리의 최상위 노드는 가장 높은 깊이 값을 가지는 모든 키를 포함합니다(작은 트리의 경우 깊이 0의 키만 존재하여 단일 노드일 수 있음). 노드 내에서 좌측 또는 우측에 존재하거나, 두 키 사이에 위치하는 링크들은 해당 범위에 속하는 키들을 포함하는 하위 트리 노드를 가리킵니다.

레코드가 없는 빈 레포지토리는 항목 배열이 비어있는 단일 MST 노드로 표현됩니다. 이것은 키("entries")나 하위 트리("sub-tree")에 대한 링크가 전혀 없는 유일한 경우입니다. 트리의 최상위는 단지 하위 트리 링크만 있는 빈 노드여서는 안 됩니다. 빈 중간 노드는 허용되며, 이 경우 해당 노드가 항목을 포함하는 하위 트리를 가리키기만 하면 됩니다. 즉, 빈 노드는 최상위와 최하위에서 제거되어야 하지만, 중간에 존재하는 빈 노드는 하위 트리 링크가 깊이 레벨을 건너뛰지 않도록 유지되어야 합니다. MST의 전체 구조와 형태는 현재의 키/값 내용에 따라 결정적이며, 삽입 및 삭제 이력과는 무관합니다.

atproto MST 구현에서는 해시 알고리즘으로 SHA-256(바이너리 출력)을 사용하며, 2비트 단위로 "접두사 0"의 개수를 세어 팬아웃을 4로 설정합니다. 키의 깊이를 계산하는 방법은 다음과 같습니다:

- 키(바이트 배열)를 SHA-256으로 해시하여 바이너리 결과를 얻습니다.
- 해시의 선행 바이너리 0의 개수를 세고, 이를 2로 나눈 후 내림합니다.
- 결과로 나온 양의 정수가 해당 키의 깊이가 됩니다.

다음은 주어진 ASCII 문자열이 바이트 배열로 매핑된 경우의 예시입니다:

- `2653ae71`: 깊이 "0"
- `blue`: 깊이 "1"
- `app.bsky.feed.post/454397e440ec`: 깊이 "4"
- `app.bsky.feed.post/9adeb165882c`: 깊이 "8"

레포지토리 내에는 많은 MST 노드가 존재하므로, 저장 효율성을 위해 이들이 압축된 이진 표현을 가지는 것이 중요합니다. 각 노드 내에서 키(바이트 배열)는 공통 접두사를 생략하여 압축되며, 각 항목은 바로 이전 키와 공유하는 바이트 수를 나타냅니다. 해당 노드의 첫 번째 항목은 전체 키를 포함해야 하며, 공통 접두사 길이는 0이어야 합니다. 이 키 압축은 노드 내부에서만 적용되며, 트리의 여러 노드에 걸쳐 확장되지는 않습니다. 이 압축 방식은 구현 간 MST 구조의 결정성을 보장하기 위해 필수적입니다.

노드 데이터 스키마 필드는 다음과 같습니다:

- `l` ("left", CID link, nullable): 현재 노드보다 낮은 레벨에 있으며, 이 노드의 키보다 작은 키들을 포함하는 하위 트리 노드에 대한 링크
- `e` ("entries", array of objects, required): 정렬된 TreeEntry 객체의 목록
  - `p` ("prefixlen", integer, required): 현재 노드 내에서 이전 TreeEntry와 공유하는 바이트 수(존재하는 경우)
  - `k` ("keysuffix", byte array, required): 이전 TreeEntry와 공유된 `p` 바이트 이후의 키 나머지
  - `v` ("value", CID Link, required): 해당 항목의 레코드 데이터(CBOR 객체)에 대한 링크
  - `t` ("tree", CID Link, nullable): 이 TreeEntry의 키 오른쪽에 해당하며, 노드 내 다음 TreeEntry의 키(존재하는 경우) 이전의 키들을 포함하는 하위 트리 노드에 대한 링크

MST 데이터 구조를 파싱할 때, 키의 깊이와 정렬 순서를 반드시 검증해야 합니다. 이는 신뢰할 수 없는 입력에 대해 특히 중요하며, 매번 검증하는 것이 가장 단순합니다. 노드 크기나 트리 구조의 기타 매개변수에 대한 추가 검사 역시 필요하지만, "보안 고려사항" 섹션을 참고하여 제한적으로 수행해야 합니다.

### CID 형식

IPFS CID 사양은 매우 유연하여 다양한 해시 유형, 링크되는 콘텐츠의 유형, 여러 문자열 인코딩 옵션을 지원합니다. 이러한 기능은 시간이 지나면서 레포지토리 형식이 발전할 수 있도록 하지만, 구현 간 상호 운용성을 극대화하기 위해서는 "blessed" CID 유형만 허용됩니다.

커밋 객체 및 MST 노드 객체(즉, 커밋 객체의 `data` 필드 또는 MST 내부 링크)와 레코드(즉, MST 리프 노드에서 레코드로의 링크)에 대해 승인된 형식은 다음과 같습니다:

- CIDv1
- 멀티베이스: DAG-CBOR 내 이진 직렬화(또는 JSON 매핑의 경우 `base32`)
- 멀티코덱: `dag-cbor` (0x71)
- 멀티해시: SHA-256 (256비트, 0x12)

레포지토리 맥락에서는 전체 데이터 구조가 내용에 따라 재현 가능해야 하므로, 허용된 CID 유형은 엄격히 제약되고 강제됩니다. 승인되지 않은 `prev` 또는 `data` 링크를 가진 커밋 객체는 유효하지 않은 것으로 간주됩니다. 또한, MST 노드 객체가 승인되지 않은 형식의 링크를 포함할 경우, 해당 MST 전체 구조가 유효하지 않은 것으로 판단됩니다.

레코드로의 "leaf" 링크에 대해서는 더 유연한 처리가 허용되며, 구현체는 이러한 매핑에 사용된 정확한 CID 링크를 보존해야 합니다. 새 레코드에 대한 CID 링크를 생성할 때는 반드시 승인된 CID 형식을 엄격히 따라야 합니다.


## CAR 파일 직렬화

데이터 객체를 저장하기 위한 표준 파일 형식은 Content Addressable aRchives(CAR) 입니다. atproto 레포지토리의 표준 내보내기 형식은 [CAR v1](https://ipld.io/specs/transport/car/carv1/)이며, 파일 확장자는 `.car`, mimetype은 `application/vnd.ipld.car`입니다.

CARv1 형식은 매우 단순합니다. 소규모 메타데이터 헤더(하나 이상의 "루트" CID 링크를 포함할 수 있음)와 일련의 이진 "블록"으로 구성됩니다. atproto 레포지토리의 경우:

- CAR 헤더의 `roots` 배열 첫 번째 요소는 가장 관련성이 높은 커밋 객체의 CID여야 합니다. 일반적인 내보내기에서는 이는 현재(최신) 커밋입니다. 추가 CID가 `roots` 배열에 포함될 수 있으나, 그 의미나 순서는 현재 정의되지 않았습니다.
- 전체 내보내기의 경우, 해당 커밋에 대한 전체 레포지토리 구조(모든 레코드와 모든 MST 노드)가 포함되어야 합니다.
- CAR 파일 내 블록의 순서는 현재 정의되거나 제한되지 않습니다. 구현체는 "선호하는" 순서를 가질 수 있으나, 예기치 않은 순서에 대해서도 유연해야 합니다.
- 추가 블록, 예를 들어 레코드 블록 등이 CAR 파일에 포함될 수 있습니다.

CAR 파일을 가져올 때, 연결이 끊긴 CID 참조가 존재할 수 있음을 유의해야 합니다. 예를 들어, 레포지토리가 다른 레포지토리의 블롭이나 레코드에 대한 CID 링크를 포함할 수 있으며, 해당 블록들은 CAR 파일에 포함되지 않을 수 있습니다.

CARv1 사양은 동일한 블록이 파일 내 여러 번 나타나는 경우(“중복 블록”)에 대해 특별한 규정을 두지 않습니다. 구현체는 중복 및 중복 제거에 대해 강건하게 처리해야 하며, 불필요하거나 연결되지 않은 블록은 무시해야 합니다.

## 레포지토리 차이(diff)

서로 독립적인 서비스 간 데이터를 효율적으로 동기화하기 위한 개념으로 "레포지토리 차이(diff)"가 있습니다. 기본 원리는 레포지토리 차이는 이전 개정판과 현재 개정판 사이에 변경된 모든 데이터(커밋 객체, MST 노드, 레코드)를 포함한다는 것입니다. 이 차이는 이전 버전의 레포지토리에 "적용"되어 최신 커밋 개정판의 전체 MST 트리를 구성하게 됩니다.

레포지토리 차이는 때때로 CAR 파일로 직렬화되며, 이를 "CAR slices"라고도 합니다. CAR slices에 관한 몇 가지 세부 사항은 다음과 같습니다:

- 전체 레포지토리 내보내기 CAR 파일과 동일한 형식, 버전, atproto 전용 제약 조건을 따릅니다.
  - 블록은 CID 기준으로 "중복 제거"되어야 하나(단, 하나의 사본만 포함), 수신 구현체는 중복에 대해 강건하게 처리해야 합니다.
- CAR 헤더의 `roots` 배열 첫 번째 요소는 커밋 블록을 가리켜야 하며, 해당 커밋 블록은 반드시 포함되어야 합니다.
- 필요한 모든 블록은, 설령 이전 레포지토리 히스토리에서 이미 나타난 블록이라 하더라도 반드시 포함되어야 합니다. 예를 들어, 레코드가 rev C에서 생성되어 rev F에서 삭제되고 rev N에서 재생성되었다면, "since F" 차이는 해당 레코드 블록을 포함해야 합니다.
- 생성된 모든 레코드는 반드시 포함되어야 합니다.
- 삭제되어 현재 레포지토리에 존재하지 않는 레코드는 포함되어서는 안 됩니다.
- 업데이트된 레코드는 최종 버전을 포함해야 하며, 이전 버전은 포함되지 않아야 합니다.
- 이전 레포지토리 버전에 존재하지 않았던 현재 레포지토리의 모든 MST 노드는 포함되어야 합니다.
- 삭제된 레코드 데이터 외에도, 차이는 수신자가 무시해야 할 추가 블록을 포함할 수 있습니다.
  - 다만, 네트워크나 계산 자원을 과도하게 소모하기 위해 불필요한 대량의 블록 데이터를 의도적으로 포함하는 차이는 네트워크 오용으로 간주됩니다.

차이는 부분적인 머클 트리로, 서명된 커밋을 포함하며, 일부 검증이 가능합니다. 이는 관련 계정(암호학적 공개 키 포함)의 신원을 확인한 관찰자가, 변경된 레코드가 최신 커밋 개정판에 포함되어 있음을 검증할 수 있음을 의미합니다. 또한, 관찰자가 특정 레코드(레포지토리 경로나 전체 AT-URI)를 알고 있다면, 해당 레코드가 최종 커밋 개정판에 더 이상 존재하지 않음을 검증할 수 있습니다.

하지만, 이전 개정판의 전체 레포지토리 상태를 모르는 관찰자는 삭제된 모든 레코드를 신뢰성 있게 열거하거나, 업데이트 이전의 레코드 값을 CID 혹은 전체 값으로 확인할 수 없습니다. 이는 콘텐츠 삭제가 신속하게 이루어지고, 삭제된 콘텐츠에 주목이 집중되지 않도록 하는 의도적인 설계입니다. 아카이브 목적으로 삭제 이벤트를 추적하고 이전 콘텐츠 값을 조회하는 것은 기술적으로 가능하나, 추가적인 자원과 노력이 필요합니다.

때때로 레포지토리 차이는 자동으로 생성됩니다. 예를 들어, 레포지토리의 모든 커밋은 바로 이전 커밋과의 차이를 생성할 수 있습니다. 다른 경우, 필요에 따라 "이전" 개정판 이후의 차이를 요청할 수 있습니다. 레포지토리 호스트는 임의의 두 개정판 간의 차이를 생성할 필요 없이, 임의의 이전 개정판 이후와 현재 개정판 사이의 차이만 제공하면 됩니다. 레포지토리 호스트는 이전 커밋/개정판의 전체 히스토리를 보관할 필요가 없으며, 일부 경우(예: 계정 이전)에는 이전 히스토리가 전혀 없을 수도 있습니다. "since" 요청에 따른 차이 해석 및 제공에 관한 몇 가지 세부 사항은 다음과 같습니다:

- 블록(레코드 또는 MST 노드)이 생성되거나 재생성된 개정판을 내부적으로 추적하면, 특정 시점 이후의 블록을 쿼리할 수 있습니다.
- "since" 개정판은 정확한 일치가 아닐 수 있습니다.
  - 예를 들어, 레포지토리 커밋이 "333", "666", "999"로 이루어졌을 때, "since" 값이 "444"로 요청되면 "666"과 "999"의 변경 사항이 포함되어야 하며, 마치 "since" 값이 "666"인 것처럼 처리되어야 합니다.
- 호스트는 추가 히스토리를 포함할 수 있으나, 가능한 한 최소한의 변경 사항만 반환하는 것이 권장됩니다.
  - 예를 들어, 레포지토리 커밋 히스토리가 "288", "300", "320", "340", "400"인 경우, "since" 값이 340이라면 340 이후의 모든 변경 사항이 반환되어야 합니다. 호스트는 가능한 한 최소한의 차이를 반환하도록 권장되지만, 클라이언트는 이에 대해 강건하게 처리해야 합니다.
- 만약 호스트가 보유한 레포지토리 히스토리 중 가장 오래된 개정판보다 이전의 "since" 요청을 받으면, 전체 레포지토리를 반환해야 합니다.
  - 예를 들어, 레포지토리 개정판이 "140", "150", "160"이었으나, 이후 새로운 PDS로 이전되어 개정판이 "161"과 "170"으로 이어진 경우, 새로운 PDS는 "since" 150 요청에 대해, 자신이 알고 있는 가장 오래된 개정판(예: "160" 또는 "161") 이후의 전체 레포지토리를 반환해야 합니다.

특히, firehose에 나타나는 연쇄적인 커밋 간 차이는 "최소화"되어야 하며, 추가 레코드나 히스토리를 포함해서는 안 됩니다.

## 보안 고려사항

레포지토리는 신뢰할 수 없는 입력입니다: 계정은 레포지토리 내용을 완전히 제어하며, PDS 인스턴스는 이진 인코딩을 완전히 제어합니다. 악의적 행위자나 우발적 상황(예: 손상된 데이터, 버그 있는 구현체)로 인한 서비스 거부(DoS) 벡터에 대비해야 합니다.

CBOR 디코딩 시에는 최대 직렬화 객체 크기, 중첩 필드의 최대 재귀 깊이, 디코딩된 데이터의 최대 메모리 사용량 등을 포함한 일반적인 예방책을 따라야 합니다. 일부 CBOR 라이브러리는 이러한 제한을 기본으로 제공하지만, 다른 라이브러리는 그렇지 않을 수 있습니다.

MST 데이터 구조의 효율성은 키 해시가 상대적으로 무작위 분포를 이루는 것에 의존합니다. 계정이 레코드 키를 제어할 수 있으므로, 특정 깊이와 정렬 순서를 갖는 레코드 키 집합을 채굴하여 비효율적인 트리 구조를 초래할 수 있으며, 이는 저장 공간의 과다 사용과 페더레이션 스트림에서의 네트워크 증폭을 유발할 수 있습니다. 이러한 공격을 방지하기 위해, 구현체는 노드당 TreeEntry의 개수를 통계적으로 있을 법한 최대 길이로 제한해야 합니다. 또한, 전체 레포지토리의 깊이나 기타 매개변수를 제한하여 보다 정교한 키 채굴 공격을 방지할 필요가 있습니다.

CAR 파일을 가져올 때에는, 레포지토리 구조의 완전성을 검증해야 합니다. CAR 구조에 관련 없는 추가 블록이 포함될 수 있으므로, CAR 내용을 백엔드 블록 저장소에 직접 주입할 때 불필요한 자원 소모를 방지해야 합니다. 또한, CAR 가져오기로 인해 이전에 삭제된 레코드가 다른 계정에서 다시 나타나는 등의 계정 간 오염 문제가 발생할 수 있습니다.


## 향후 변경 가능 사항

동일한 레코드(경로별)의 여러 버전을 저장하는 선택적 인레포지토리 메커니즘이 도입될 수 있습니다. 예를 들어, CID, 타임스탬프, 혹은 단조 증가하는 버전 정수를 나타내는 추가 경로 필드를 도입할 수 있습니다.

레코드와 관련된 메타데이터(예: 일반 라벨, 재사용 권한, 해시태그 메타데이터 등)를 저장하는 메커니즘이 고려되고 있습니다. 이는 레코드 자체를 변경하지 않고 메타데이터만 수정하여, 일부 메타데이터가 렉시콘 전반에 걸쳐 공통적으로 사용될 수 있도록 할 것입니다.

레포지토리 경로 제한이 완화되어, 경로 세그먼트의 수를 줄이거나 늘리거나, 허용 문자를 확장할 가능성이 있습니다(비 ASCII 포함). 경로는 항상 유효한 유니코드 문자열이어야 하며, MST 키(바이트 배열)로 변환 시 UTF-8 인코딩을 사용합니다.

atproto 전체 사양에서는 시간이 지남에 따라 추가적인 "blessed" 암호화 알고리즘이 도입될 수 있으며, 레코드와 블롭을 참조하기 위한 추가 CID 형식도 추가될 수 있습니다. 내부 CID 형식의 변경은 레포지토리 형식 버전 변경을 요구합니다.

레포지토리 CAR 내보내기에 연결된 "블롭"(대용량 이진 파일)이 포함될 수 있으며, 이는 기본 설정이거나 구성 가능한 옵션이 될 수 있습니다. 또는, `.tar`이나 `.zip`과 같은 다른 내보내기 메커니즘이 선택될 수도 있습니다.

레코드 콘텐츠가 언젠가는 DAG-CBOR 이외의 형식이 될 가능성도 있으며, 이 경우 레포지토리 형식 버전 변경이 필요할 것입니다. 단, 다른 데이터 형식을 DAG-CBOR 래퍼(바이트 배열 필드를 통해)로 감싸는 방식으로 효율적으로 처리할 수도 있습니다.

레포지토리 CAR 내보내기는 선호하는 블록 정렬 방식에 대한 명세가 추가될 수 있습니다.

커밋 및 MST 노드 객체에 선택적 필드를 추가하는 경우, 또는 MST 팬아웃이나 현재 MST 필드의 변경이 있는 경우, 이는 전체 레포지토리 형식 버전 변경을 초래할 수 있습니다.
