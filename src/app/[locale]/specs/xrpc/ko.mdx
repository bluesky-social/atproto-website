export const metadata = {
  title: 'HTTP API (XRPC)',
  description: 'HTTP를 통한 크로스 시스템 쿼리 및 프로시저',
}

# HTTP API (XRPC)

atproto에서 클라이언트-서버 및 서버-서버 요청을 위한 HTTP API는 XRPC라 불리는 일련의 공통 규약을 사용합니다. 엔드포인트 경로 이름에는 요청 및 응답 스키마를 지정하는 [Lexicon](/specs/lexicon)이 나타내는 NSID가 포함되며, 일반적으로 JSON 콘텐츠 타입을 사용합니다. {{ className: 'lead' }}

## Lexicon HTTP 엔드포인트

HTTP 요청 경로는 `/xrpc/`로 시작하며, 그 뒤에 NSID가 이어집니다. 경로는 항상 최상위에 있어야 하며, 접두사 아래에 있어서는 안 됩니다. NSID는 관련 Lexicon의 `id` 필드에 매핑됩니다.

Lexicon에서 표현할 수 있는 두 가지 요청 유형은 "query"(HTTP GET)와 "procedure"(HTTP POST)입니다. HTTP REST 의미론에 따라, 쿼리(GET)는 캐시 가능하며 리소스 상태를 변경해서는 안 됩니다. 프로시저(POST)는 캐시되지 않으며 상태를 변경할 수 있습니다.

Lexicon의 `parameters` 필드 아래에 있는 `params`는 HTTP URL 쿼리 파라미터에 매핑됩니다. 단, 특정 Lexicon 타입만 params에 포함될 수 있으며, 이는 해당 `params` 타입에 명시되어 있습니다. 동일한 이름의 쿼리 파라미터가 여러 번 사용되면 파라미터 배열을 나타냅니다. `boolean` 파라미터를 인코딩할 때는 문자열 `true`와 `false`를 사용해야 하며, 문자열은 따옴표 없이 사용해야 합니다. 스키마에 `default` 값이 포함된 경우, 일관된 캐싱 동작을 위해 모든 요청에 반드시 포함되어야 합니다.

요청 및 응답 본문의 콘텐츠 타입은 Lexicon에서 지정할 수 있습니다. 스키마는 정확한 MIME 타입을 요구하거나, 허용 가능한 타입 범위를 나타내는 블롭 패턴(e.g., `image/*`)을 요구할 수 있습니다.

Lexicon의 JSON 본문 스키마는 일반적인 atproto 데이터 모델을 사용하여 지정됩니다. 서버나 클라이언트에서 완전한 검증을 하려면 Lexicon에 대한 지식이 필요하지만, 추상 데이터 모델에 대해서는 부분적인 검증이 항상 가능합니다.

CORS 지원은 권장되지만 필수 사항은 아닙니다.

### 오류 응답

모든 실패한 응답은 표준 오류 응답 스키마를 따라야 합니다. `Content-Type`은 `application/json`이어야 하며, 페이로드는 다음 필드를 포함하는 JSON 객체여야 합니다:

- `error` (string, 필수): 오류 타입 이름 (공백 없는 일반 ASCII 상수)
- `message` (string, 선택): 사용자에게 표시하기 적합한 오류 설명

오류 타입은 엔드포인트의 Lexicon 스키마에 정의된 오류 이름에 매핑되어야 합니다. 이를 통해 클라이언트 소프트웨어가 보다 구체적인 오류 처리를 할 수 있으며, 이는 특히 `400`, `500`, `502` 상태 코드에서 유용합니다.

### 블롭 업로드 및 다운로드

블롭은 MIME 타입에 구애받지 않고 다양한 데이터를 담을 수 있으며, 리포지토리에 직접 저장되지 않기 때문에 NSID나 Lexicon과 직접적으로 연관되지 않습니다(하지만 Lexicon에서 참조될 수 있습니다).

블롭을 다루는 규약은 클라이언트가 `com.atproto.repo.uploadBlob` 엔드포인트를 통해 업로드하는 것이며, 이 엔드포인트는 CID와 블롭에 대한 기본 메타데이터를 포함하는 `blob` JSON 객체를 반환합니다. 클라이언트는 이후 요청(예: 새로운 레코드에 포함)에서 이 `blob` 데이터를 사용할 수 있습니다. MIME 타입 및 파일 크기 등의 제약은 두 번째 단계에서만 검증됩니다. 서버는 업로드 단계에서 콘텐츠 타입 스니핑을 수행해 요청에 제공된 `Content-Type`과 다른 MIME 타입을 반환할 수 있지만, 업로드 HTTP 요청에는 여전히 `Content-Type` 헤더가 필요합니다.

특정 계정에 대한 블롭은 `com.atproto.sync.*` NSID 공간의 엔드포인트를 사용하여 나열 및 다운로드할 수 있습니다. 이러한 엔드포인트는 업로드된 원본 블롭에 대한 완전한 접근을 제공합니다. 일반적인 패턴은 애플리케이션이 원본 블롭과 함께 CDN 등에서 다운사이즈된 썸네일 또는 미리보기 버전을 별도의 URL로 미러링하는 것입니다(즉, 원본 PDS의 `getBlob` 엔드포인트에 직접 링크하지 않는 방식).

### 커서와 페이지네이션

Lexicon 설계에서 일반적인 패턴은 페이지네이션을 위한 `cursor` 파라미터를 포함하는 것입니다. 클라이언트는 첫 요청에 `cursor` 파라미터를 포함하지 않아야 하며, 이후 요청 간에는 다른 모든 파라미터를 고정해야 합니다. 응답에 커서가 포함된 경우, 그 값을 후속 요청에 포함하여 다음 배치의 응답을 가져올 수 있으며, 커서가 더 이상 포함되지 않을 때까지 반복합니다. 이는 결과 집합의 끝을 나타냅니다.

## 인증

XRPC의 기본 클라이언트/서버 인증 및 권한 부여 방식은 [Auth Specification](./oauth)에 설명된 OAuth입니다.

모든 엔드포인트가 인증을 요구하는 것은 아니지만, 어떤 엔드포인트가 인증을 요구하는지 일관되게 열거하는 방법은 아직 마련되지 않았습니다.

또한 HTTP Bearer 인증과 JWT 토큰(리프레시 토큰 포함)을 사용하는 이전 방식의 인증 체계도 존재합니다. 초기 로그인의 경우 `com.atproto.server.createSession` 엔드포인트를 사용하며, 이때 비밀번호와 계정 식별자(예: 핸들이나 등록된 이메일 주소)를 포함합니다. 이 요청은 초기 `accessJwt`와 함께 `refreshJwt`를 반환합니다.

대부분의 요청은 access JWT를 사용하여 인증해야 하지만, access JWT의 유효 기간은 짧습니다. 몇 분마다 새로운 access JWT를 `com.atproto.server.refreshSession` 엔드포인트를 호출하여 refresh JWT로 요청할 수 있습니다.

클라이언트는 JWT 토큰을 불투명한 문자열로 취급해야 하며, JWT 내부의 필드와 의미는 명세의 안정적인 부분이 아닙니다.

토큰을 생성하고 검증하는 서버(PDS 구현체)는 access와 refresh 토큰 간 도메인 분리를 위해 `typ` 헤더 필드를 사용해야 합니다. access 토큰은 `at+jwt`를, refresh 토큰은 `refresh+jwt`를 사용해야 합니다. (`at+jwt`는 [RFC 9068](https://www.rfc-editor.org/rfc/rfc9068.html)에서 정의된 "access token"의 약어이며, atproto의 "at"과는 관련이 없습니다.)

### 앱 비밀번호

앱 비밀번호는 타사 클라이언트나 웹 애플리케이션에 로그인할 때 보안 위험을 줄이기 위한 메커니즘입니다. 계정은 기본 비밀번호와 별도로 앱 비밀번호를 생성하고 취소할 수 있습니다. 앱 비밀번호는 기본 비밀번호와 동일한 방식으로 로그인하는 데 사용되지만, 계정 변경이나 인증 설정(앱 비밀번호 자체 포함)과 같이 파괴적인 행동은 제한됩니다.

클라이언트와 애플리케이션은 앱 비밀번호를 특별히 다룰 필요가 없으나, 대부분의 경우 로그인 시 앱 비밀번호 사용을 권장하는 안내 메시지를 포함하는 것이 모범 사례입니다. 앱 비밀번호는 보통 `xxxx-xxxx-xxxx-xxxx` 형식을 가지며, 클라이언트는 이 형식을 검사하여 기본 비밀번호로 인한 우발적인 로그인을 방지할 수 있습니다(기본 비밀번호가 이 형식을 따르지 않는 한).

### 관리자 토큰 (임시 명세)

일부 관리 XRPC 엔드포인트는 관리자 권한 인증을 요구합니다. 현재 이 방식은 JWT를 사용하는 HTTP Bearer 인증 대신, 사용자 "admin"과 고정 토큰을 비밀번호 필드에 포함하는 HTTP Basic 인증을 사용합니다. 이는 관리자 요청이 클라이언트의 계정이나 정체성과 직접적으로 연결되지 않고 단순히 "admin"으로 인식됨을 의미합니다.

참고로, HTTP Basic 인증은 사용자 이름과 비밀번호를 콜론(`:`)으로 결합한 후 해당 문자열을 표준 `base64`로 인코딩하여 동작합니다. 인코딩된 문자열은 `Authorization` 헤더에 `Basic `(공백 포함) 접두어와 함께 포함됩니다.

예를 들어, 관리자 토큰이 `secret-token`이라면 헤더는 다음과 같이 구성됩니다:

```
Authorization: Basic YWRtaW46c2VjcmV0LXRva2Vu
```

현재 관리자 인증이 필요한 엔드포인트는 다음과 같습니다:

- `com.atproto.admin.*`
- `com.atproto.server.createInviteCode`
- `com.atproto.server.createInviteCodes`

### 서비스 간 인증 (JWT)

이 섹션은 서명된 JWT를 사용하여 서비스 간 인증을 수행하는 메커니즘을 설명합니다.

현재 메커니즘은 계정의 atproto 서명 키로 서명된 단기 JWT를 사용하는 것입니다. 요청을 받는 서비스는 계정의 DID 문서에 있는 키를 사용하여 서명을 검증할 수 있습니다.

JWT의 주요 매개변수는 다음과 같습니다:

- **`alg` 헤더 필드 (string, 필수):** 서명에 사용된 키 유형을 나타냅니다 (자세한 내용은 [Cryptography](/specs/cryptography) 참조)
  - `k256` 키의 경우 `ES256K` 사용
  - `p256` 키의 경우 `ES256` 사용
- **`typ` 헤더 필드 (string, 필수):** 현재는 `JWT`이지만, 추후 보다 구체적인 값으로 업데이트될 예정입니다.
- **`iss` 본문 필드 (string, 필수):** 요청이 대표하는 계정의 DID입니다. 이 값은 접미사 서비스 식별자를 포함할 수 있습니다(아래 참조).
- **`aud` 본문 필드 (string, 필수):** 요청이 전달되는 대상 서비스와 연관된 서비스 DID입니다.
- **`exp` 본문 필드 (number, 필수):** 토큰 만료 시간(UNIX 타임스탬프, 초 단위)입니다. 단기 시간 창이어야 하며, 토큰 취소 기능은 구현되어 있지 않습니다. 약 60초 정도가 적절합니다.
- **`iat` 본문 필드 (number, 필수):** 토큰 생성 시간(UNIX 타임스탬프, 초 단위)입니다.
- **`lxm` 본문 필드 (string, 선택):** "lexicon method"의 약어로, NSID 형식을 따릅니다. 이 토큰이 권한을 부여하는 엔드포인트를 나타내며, 포함된 경우 서버는 반드시 이를 검증해야 합니다. 보안에 민감한 작업에서는 이를 요구하는 것이 좋으며, 추후 필수 항목이 될 수 있습니다.
- **`jti` 본문 필드 (string, 필수):** 고유한 무작위 문자열 논스(nonce)로, 토큰 재사용 및 재생 공격을 방지하는 데 사용됩니다.
- **JWT 서명 (string, 필수):** 계정 DID의 서명 키를 사용해 base64url 인코딩된 서명입니다.

토큰이 발행자의 DID 문서 내 특정 서비스 컨텍스트에서 생성될 경우, `iss` 필드에는 `#` 문자로 구분된 해당 서비스 식별자가 포함될 수 있습니다. 예를 들어, 라벨러 서비스를 위한 `did:web:label.example.com#atproto_labeler`와 같이 사용됩니다. 이 경우, 적절한 서명 키는 서비스 식별자와 고정 매핑된 키 식별자에 따라 결정됩니다:

- 서비스 식별자 `atproto_labeler`는 키 식별자 `atproto_label`에 매핑됩니다.

서비스 식별자가 포함되지 않은 경우 범용으로 간주하며, `atproto` 키 식별자를 사용해야 합니다.

요청을 받는 서비스는 특정 리소스나 엔드포인트에 접근할 때 특정 서비스 식별자의 사용을 요구하거나 금지할 수 있습니다.

서명은 계정의 서명 키(레포지토리 커밋에 서명하는 데 사용된 동일한 키)를 사용하여 일반적인 JWT 프로세스를 통해 계산됩니다. Typescript 의사 코드는 다음과 같습니다:

```
const headerPayload = utf8ToBase64Url(jsonStringify(header)) + '.' + utf8ToBase64Url(jsonString(body))
const signature = hashAndSign(accountSigningKey, utf8Bytes(headerPayload))
const jwt = headerPayload + '.' + bytesToBase64Url(signature)
```

## 서비스 프록시

PDS는 클라이언트와 다른 atproto 서비스 간의 일반 프록시 역할을 수행합니다. 클라이언트는 HTTP 헤더를 사용하여 요청을 전달할 네트워크 상의 특정 서비스를 지정할 수 있습니다(예: 특정 AppView 또는 라벨러 서비스). PDS는 일부 안전성 검사를 수행한 후, 사용자의 정체성으로 발급 및 서명된 서비스 간 인증 토큰(JWT, 위에 설명됨)을 사용하여 요청을 해당 서버로 전달합니다.

사용되는 HTTP 헤더는 `atproto-proxy`이며, 그 값은 `#` 문자로 구분된 서비스 엔드포인트 식별자를 포함한 DID입니다. PDS는 서비스 DID를 해석하고, 해당 DID 문서에서 서비스 엔드포인트 URL을 추출하여 요청을 프록시합니다.

라벨러 서비스로 프록시하기 위한 예시 요청 헤더는 다음과 같습니다:

```
atproto-proxy: did:web:labeler.example.com#atproto_labeler
```

프록시가 동작하기 위해서는 다음과 같은 조건을 충족해야 합니다. 이 조건들은 추후 네트워크 남용 문제를 해결하기 위해 확장될 수 있습니다.

- 대상 서비스는 해석 가능한 DID, 올바른 형식의 DID 문서, 그리고 일치하는 서비스 식별자를 가진 서비스 엔트리를 보유해야 합니다.
- atproto 엔드포인트 경로만 지원됩니다. 즉, `/xrpc/` 접두사 뒤에 유효한 NSID와 엔드포인트 이름이 있어야 합니다. (참고로 `/xrpc/` 접두사는 추후 설정 가능할 수 있습니다.)
- 요청은 PDS에 활성화된 계정을 가진 인증된 사용자로부터 전송되어야 합니다.
- PDS의 속도 제한(rate limit)이 여전히 적용됩니다.

## HTTP 헤더 요약

클라이언트는 다음과 같은 요청 헤더를 사용할 수 있습니다:

- **`Content-Type`:** 요청 본문이 있는 경우, 이 헤더를 포함하여 콘텐츠 타입을 명시해야 합니다.
- **`Authorization`:** 인증 정보를 포함합니다. 자세한 내용은 이 명세의 "인증" 섹션을 참조하세요.
- **`atproto-proxy`:** 다른 atproto 서비스로 프록시하기 위해 사용됩니다. 자세한 내용은 "서비스 프록시" 섹션을 참조하세요.
- **`atproto-accept-labelers`:** 클라이언트가 특정 라벨러로부터 라벨을 요청하여 응답에 포함시키도록 할 때 사용됩니다. 자세한 내용은 [라벨](/specs/label) 명세를 참조하세요.

## HTTP 상태 코드 요약

- **`200 OK`:** 요청이 성공적으로 처리되었습니다. 응답 본문이 있는 경우, `Content-Type` 헤더가 포함되어야 합니다.
- **`400 Bad Request`:** 요청이 잘못되어 처리되지 않았습니다.
- **`401 Unauthorized`:** 이 엔드포인트는 인증이 필요합니다. `WWW-Authenticate` 헤더가 포함되어야 합니다.
- **`403 Forbidden`:** 클라이언트에게 이 엔드포인트에 대한 권한이 없습니다.
- **`404 Not Found`:** 리소스가 없음을 나타낼 수 있으며, 이는 서버가 atproto를 지원하지 않거나 해당 엔드포인트를 지원하지 않음을 의미할 수 있습니다. 오류 메시지(또는 메시지 부재)를 통해 이를 명확히 해야 합니다.
- **`413 Payload Too Large`:** 요청 본문이 너무 큽니다. 가능하면 여러 개의 더 작은 요청으로 나누어야 합니다.
- **`429 Too Many Requests`:** 자원 한도가 초과되었으므로 클라이언트는 요청을 중단해야 합니다. `Retry-After` 헤더가 포함되어 특정 백오프 시간을 안내할 수 있습니다.
- **`500 Internal Server Error`:** 일반적인 내부 서비스 오류입니다. 클라이언트는 일정 지연 후 재시도할 수 있습니다.
- **`501 Not Implemented`:** 지정된 엔드포인트는 알려져 있으나 구현되지 않았습니다. 클라이언트는 재시도해서는 안 됩니다. (예를 들어, 서버가 WebSockets 요청을 지원하지 않을 때 반환됩니다.)
- **`502 Bad Gateway`, `503 Service Unavailable`, 또는 `504 Gateway Timeout`:** 일반적으로 일시적 또는 영구적인 서비스 중단을 나타냅니다. 클라이언트는 일정 지연 후 재시도할 수 있습니다.

## 사용 및 구현 가이드라인

클라이언트는 타임아웃, 제한된 재시도, 그리고 무작위 지수 백오프(randomized exponential backoff)를 구현하는 것이 권장됩니다. 이는 일시적인 다운타임 발생 시 견고성을 높이고, 동시에 과도한 서버 부하를 줄이는 데 도움이 됩니다.

서버는 `/xrpc/` 경로 접두사가 있는 모든 요청에 대해 사용자 정의 JSON 오류 응답을 구현하는 것이 바람직하지만, 현실적으로 많은 서비스는 일반적인 로드 밸런서나 리버스 프록시의 HTML 오류 페이지를 반환할 수 있으므로, 클라이언트는 JSON이 아닌 오류 응답에도 유연하게 대처해야 합니다.

HTTP 서버와 클라이언트 라이브러리는 일반적으로 URL(쿼리 파라미터 포함)의 전체 크기에 제한이 있으며, 이러한 제한은 XRPC에서 파라미터 사용에 제약을 줄 수 있습니다.

PDS 구현체는 지원하는 Lexicon에서 정의된 블롭 제약 사항의 상위 집합이어야 하는 전역 최대 크기나 허용 MIME 타입 집합 등을 기준으로 블롭 업로드를 제한할 수 있습니다.

## 보안 및 개인정보 보호 고려사항

개방된 인터넷에서는 HTTPS만 사용해야 합니다.

EXIF 메타데이터와 같이 개인 식별 정보가 포함된 블롭에 대해서는 주의가 필요합니다. 현재로서는 클라이언트가 블롭 업로드 전에 민감한 EXIF 메타데이터를 제거할 책임이 있으며, PDS가 우발적 메타데이터 유출 방지를 위해 도움을 줄 수 있는 방안(예: 메타데이터 자동 제거)도 추후 고려될 수 있습니다.

## 향후 변경 가능 사항

- 인증 시스템은 전면 개편될 가능성이 있습니다.
- Lexicon은 인증 요구 여부를 명시할 수 있어야 합니다.
- PDS의 역할이 일반 게이트웨이로 공식화되고 확장될 수 있습니다. 특정 XRPC 엔드포인트를 타 서비스로 프록시하는 일반적인 메커니즘이 추가될 수 있으며, 쿼리 및 블롭의 일반 캐싱에 대한 명세가 포함될 수 있습니다. 또한 PDS가 타 서비스의 응답을 변형하는 것이 명시적으로 허용될 수 있습니다.
- HTTP 리다이렉트 지원 여부에 대한 명시적인 결정이 필요합니다.
- 커서 페이지네이션 동작은, 커서가 반환되었으나 결과 목록이 비어 있거나 커서 값이 반복되는 경우에 대해 명확하게 정의되어야 합니다.
- 미디어 블롭에 내포된 민감한 메타데이터의 우발적 공개를 방지하기 위해, 업로드 블롭 엔드포인트에 메타데이터 제거를 선택적으로 비활성화하는 쿼리 파라미터가 추가될 수 있으며, 기본값은 모든 블롭 업로드 시 차단 또는 자동 제거로 설정될 수 있습니다.
- 서비스 간 인증을 위한 `lxm` JWT 필드는 추후 필수 항목이 될 수 있습니다.
