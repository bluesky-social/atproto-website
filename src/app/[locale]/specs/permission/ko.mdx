import {Heading} from '@/components/Heading'

export const metadata = {
  title: '권한',
  description:
    '계정 리소스에 대한 인증 권한.',
}

# 권한

atproto 리소스에 대한 제어는 "권한(permissions)"을 사용하여 설명되고 부여됩니다. 특정 Lexicon 네임스페이스(레코드 타입 및 API 엔드포인트)와 관련된 권한 그룹을 "권한 세트(permission set)"로 묶을 수 있습니다. 이 둘은 모두 [OAuth](/specs/oauth) 컨텍스트에서 사용되어 클라이언트 소프트웨어에 PDS의 계정 리소스에 대한 접근 권한을 부여합니다. 예를 들어, 사용자의 공개 리포지토리에 특정 타입의 레코드를 쓰거나, 원격 서비스에 인증된 API 요청을 보내는 기능 등이 있습니다. 개발자는 앱이 작동하는 데 필요한 권한을 선언하고, 최종 사용자는 앱에 접근 권한을 부여할 때 해당 권한을 확인하게 됩니다.

각 리소스 유형에는 권한을 세분화할 수 있는 정의된 매개변수 세트가 있습니다. 권한은 문자열 형식(OAuth 스코프로 직접 사용) 또는 JSON 객체(권한 세트에서 사용)로 표현될 수 있습니다. 권한 세트는 공개 Lexicon 스키마로 게시되며, 권한 세트 자체의 NSID와 동일한 NSID 계층 구조 아래에 있는 명명된 리소스로 범위가 제한됩니다.

<Heading level={2} id="resource-types">리소스 유형</Heading>

PDS 인스턴스에서 사용자 소유 리소스와 관련된 권한:

- `repo`: 공개 리포지토리 (레코드 및 컬렉션)
- `rpc`: 서비스 인증 (외부 서비스에 대한 API 호출)
- `blob`: 업로드된 미디어 파일
- `identity`: DID 및 핸들
- `account`: 호스팅 상태, 이메일 주소

추가적인 "meta" 리소스인 `include`가 있으며, 이는 권한 세트를 참조하는 데 사용됩니다(아래 권한 세트 섹션 참조).

이 섹션에서는 권한을 제한할 수 있는 모든 매개변수를 포함하여 이러한 리소스를 더 깊이 있게 설명합니다. 각 리소스에 대해 하나의 매개변수가 "위치(positional)"로 표시될 수 있으며, 이는 문자열 표현 구문에 영향을 미칩니다(이후 섹션에서 설명).

리소스와 권한은 특정 PDS API 엔드포인트에 묶이지 않고 추상적으로 설명됩니다. 예: `rpc` 권한은 서비스 간 인증을 사용하여 원격 서비스 API를 호출하는 기능을 설명합니다. 여기에는 프록시된 PDS 요청(`Atproto-Proxy` HTTP 헤더 사용)과 `com.atproto.server.getServiceAuth`를 사용하여 서비스 인증 토큰을 가져오는 것이 모두 포함됩니다.

### `repo`

계정의 공개 리포지토리에 있는 레코드에 대한 쓰기 접근 권한입니다. 특정 레코드 타입(컬렉션)이나 작업(예: 업데이트 vs 삭제)으로 제한될 수 있습니다.

매개변수:

- `collection` (문자열 배열, 필수, 위치): 레코드 타입의 NSID. 스코프 문자열 구문에서 와일드카드(`*`)가 허용되며 모든 레코드에 대한 접근 권한을 부여합니다. 부분 와일드카드는 지원되지 않습니다(예: `com.example.*` 사용 불가). 권한 세트 내의 권한에서는 와일드카드가 *지원되지 않습니다*.
- `action` (고유 문자열 배열, 선택 사항): 허용되는 레코드 작업 세트를 정의합니다. 허용되는 값은 `create`, `update`, `delete`입니다. 정의되지 않은 경우 모든 작업이 허용됩니다.

예시:

```
# 단일 레코드 타입에 대한 전체 권한 (생성, 업데이트, 삭제)
repo:app.example.profile

{
"type": "permission",
"resource": "repo",
"collection": ["app.example.profile"]
}

# 위와 동일하며, 작업을 명시적으로 지정함
repo:app.example.profile?action=create&action=update&action=delete

{
"type": "permission",
"resource": "repo",
"collection": ["app.example.profile"],
"action": ["create", "update", "delete"]
}

# 여러 레코드 타입에 대한 전체 권한
repo?collection=app.example.profile&collection=app.example.post

{
"type": "permission",
"resource": "repo",
"collection": ["app.example.profile", "app.example.post"]
}

# 모든 레코드 타입에 대한 전체 권한 (권한 세트 내에서는 허용되지 않음)
repo:*

# 모든 레코드 타입에 대한 삭제 전용 권한 (권한 세트 내에서는 허용되지 않음)
repo:*?action=delete
```

### `rpc`

원격 서비스에 인증된 API 요청을 보낼 수 있는 기능입니다. 여기에는 PDS의 `com.atproto.server.getServiceAuth` 엔드포인트를 사용하여 서비스 인증 토큰(JWT)을 요청하는 것과 PDS를 통해 프록시된 요청이 모두 포함됩니다.

권한은 원격 엔드포인트(`lxm`, "Lexicon Method"의 약어)와 원격 서비스의 ID(대상, `aud`)로 매개변수화됩니다. 권한은 이 매개변수 중 적어도 하나로 제한되어야 합니다. 즉, 모든 서비스의 모든 API 엔드포인트를 호출하는 기능은 단일 권한으로 선언할 수 없습니다.

권한 세트에 포함될 때 대상(audience) 매개변수는 전체 세트에서 상속될 수 있습니다.

매개변수:

- `lxm` (문자열 배열, 필수, 위치): API 엔드포인트의 NSID. 스코프 문자열 구문에서 와일드카드(`*`)가 허용되며 모든 엔드포인트에 대한 접근 권한을 부여합니다. 부분 와일드카드는 지원되지 않습니다(예: `com.example.*` 사용 불가). 권한 세트 내의 권한에서는 와일드카드가 *지원되지 않습니다*.
- `aud` (문자열, 반-필수): API 요청의 대상(audience)으로, DID 서비스 참조 형식입니다 (DID 뒤에 필수 서비스 유형 프래그먼트가 옴, 예: `did:web:api.example.com#srvtype`). 와일드카드(`*`)를 지원하지만, 위에서 언급했듯이 `aud`와 `lxm` 모두 와일드카드일 수는 없습니다. 권한 세트 컨텍스트에서는 DID 참조가 허용되지 않습니다. 세분화된 문자열 표현에서는 항상 필수이며, 권한 세트에서는 `inheritAud`에 따라 달라집니다.
- `inheritAud` (불리언, 선택 사항): 권한 세트 내부에서만 사용됩니다. 참(true)인 경우, `aud` 값은 `include:` 호출에서 상속되며, 권한에서 `aud` 필드는 필요하지 않습니다.

`inheritAud`가 참이고 권한에 `aud`도 정의된 경우 권한은 유효하지 않습니다(무시되어야 함). `inheritAud`가 참이고 호출하는 `include:`에 `aud`가 정의되지 않은 경우 `rpc` 권한은 유효하지 않습니다(무시되어야 함).

예시:

```
# 임의의 서비스에 중재 보고서 제출
rpc:app.example.moderation.createReport?aud=*

{
"type": "permission",
"resource": "rpc",
"lxm": ["app.example.moderation.createReport"],
"aud": "*"
}

# 특정 서비스의 모든 RPC 메서드 호출 (권한 세트 내에서는 허용되지 않음)
rpc?lxm=*&aud=did:web:api.example.com%23svc_appview
```

## `blob`

PDS에 미디어 파일(blob)을 업로드할 수 있는 기능입니다.

이 유형의 권한은 권한 세트에 포함될 수 없으며, 클라이언트 앱에서 직접 요청해야 합니다.

매개변수:

- `accept` (문자열 배열, 필수, 위치): MIME 타입 또는 부분 MIME 타입 글로브 패턴(예: `*/*` 또는 `text/*`). `blob` lexicon 타입의 `accept` 필드와 동일한 구문입니다.

예시:

```
# 모든 유형의 blob 업로드
blob:*/*

# 비디오 또는 html 업로드
blob?accept=video/*&accept=text/html
```

## `account`

PDS 계정 호스팅 세부 정보(예: (비공개) 계정 이메일) 제어.

이 유형의 권한은 권한 세트에 포함될 수 없으며, 클라이언트 앱에서 직접 요청해야 합니다.

매개변수:

- `attr` (문자열, 필수, 위치): 계정 구성의 구성 요소. 와일드카드는 지원되지 않습니다.
- `action` (문자열, 선택 사항): 제어 정도. 현재 `read` 또는 `manage`를 지원합니다. 지정하지 않을 경우 기본값은 `read`입니다.

속성:

- `email`: 계정 이메일 주소. `read` 작업은 이메일 및 확인 상태를 볼 수 있게 합니다. `manage` 작업은 `read`를 포함하며 이메일 주소 변경도 허용합니다.
- `repo`: CAR 파일을 사용하여 전체 공개 리포지토리를 업데이트하는 기능. `manage` 작업은 계정 마이그레이션 중과 같이 전체 CAR 파일을 가져오는 것을 허용합니다. `read` 작업은 아무것도 하지 않습니다.

예시:

```
# 계정 이메일 읽기
account:email

# 리포지토리 가져오기
account:repo?action=manage
```

## `identity`

네트워크 신원, 즉 계정 DID 문서 및 핸들에 대한 제어. PDS가 DID 문서를 제어할 수 없는 경우(예: 계정이 `did:web`을 사용하는 경우) 신원 변경을 지원하지 못할 수 있습니다.

이 유형의 권한은 권한 세트에 포함될 수 없으며, 클라이언트 앱에서 직접 요청해야 합니다.

매개변수:

- `attr` (문자열, 필수, 위치): 계정의 측면 또는 구성 요소. 와일드카드(`*`)일 수 있으며, 이는 DID 문서 및 핸들에 대한 완전한 제어를 나타냅니다.

속성:

- `handle`: 핸들 업데이트 기능. 여기에는 DID 문서에 핸들 등록 및 PDS가 제어하는 도메인 이름이 포함됩니다.
- `*` (와일드카드): DID 문서 및 핸들에 대한 완전한 제어.

예시:

```
# 계정 핸들 업데이트
identity:handle
```

<Heading level={2} id="scope-string-syntax">스코프 문자열 구문</Heading>

[OAuth](/specs/oauth) 스코프로 직접 요청될 때 권한은 간단한 문자열로 표현되어야 합니다. 이 섹션에서는 권한 스코프 문자열의 구문을 설명합니다.

문자열은 대소문자를 구분하며 인쇄 가능한 비공백 ASCII 문자의 하위 집합을 사용합니다. 리소스 이름 부분이 있고, 그 뒤에 콜론(`:`)으로 구분된 선택적인 "위치(positional)" 부분이 오며, 물음표(`?`)로 시작하는 선택적인 매개변수가 뒤따릅니다. 위치 부분은 물음표를 제외한 모든 문자를 포함할 수 있으며, 추가 콜론 문자, 해시(`#`), 마침표 등을 포함하고 퍼센트 인코딩을 지원합니다. 매개변수는 앰퍼샌드(`&`)로 구분되고, 이름과 값 부분은 등호(`=`)로 구분되며, 예약 문자의 퍼센트 인코딩을 지원합니다. 배열 값은 동일한 이름 부분을 가진 반복된 매개변수로 표현할 수 있습니다.

예를 들어, 스코프 문자열 `account:repo?action=manage`는 리소스 이름 `account`, 값 `repo`를 가진 "위치" 부분, 그리고 키/값 쌍 `action=manage`를 가집니다. `account`의 위치 매개변수가 `attr`임을 알면, 동일한 권한을 `account?action=manage&attr=repo`로 표현할 수 있습니다.

위치 포지션에 매개변수가 지정된 경우, 키/값 매개변수에서도 설명될 수 없습니다. 예: `repo:com.example.record?collection=com.example.other`는 허용되지 않습니다.

구문적으로나 의미적으로 유효한 스코프 문자열의 예:

```
identity:*
identity:*?
rpc?lxm=*&aud=did:web:api.example.com%23svc_appview
blob?accept=video/*&accept=text/html
repo:app.example.profile?action=create&action=update&action=delete
include:app.example.authFull?aud=did:web:api.example.com%23svc_chat
```

일반 구문과는 일치하지만 현재 리소스 정의에서는 의미적으로 유효하지 않은 스코프 문자열:

```
resource
resource:positional?key=val
resource:positional&thing?key=val
service:did:web:com.example#type?key=val
resource:
resource:?
resource:&
resource?
```

일반 구문과 일치하지 않는 예:

```
resource:positional?key=québec
emoji:☺️
```

<Heading level={2} id="permission-sets">권한 세트</Heading>

전체 기능을 갖춘 클라이언트 앱은 작동하기 위해 수십 개 또는 수백 개의 개별 권한이 필요합니다. 이는 긴 권한 목록을 주의 깊게 검토할 가능성이 낮아 사용자 경험 및 보안 문제를 야기하며, 개발자에게는 이러한 목록을 정의하고 유지 관리하는 것이 번거로운 작업입니다.

권한 관리를 단순화하기 위해 Lexicon 설계자는 게시하는 스키마의 일부로 권한 "세트"를 정의할 수 있습니다. 이러한 권한 세트는 그 자체로 Lexicon 스키마이며 `com.example.authBasicFeatures`와 같이 NSID로 참조됩니다.

인증 서버(Authorization Servers)는 권한 세트를 동적으로 해결(resolve), 인증 및 처리합니다. 세트에는 인증 요청 흐름 중에 최종 사용자에게 표시되는 사용자에게 의미 있는 제목과 요약이 포함되며, 국제화를 지원합니다. 이러한 요약은 동의 이해도를 높이고 궁극적으로 계정 보안을 향상시킵니다 (사용자 인터페이스는 부여되는 특정 세부 권한을 확장할 수도 있어야 합니다). 권한 세트는 공개적으로 게시되며 모든 클라이언트 개발자가 사용할 수 있습니다. (동적 해결을 위한 캐싱 및 폴백 동작은 아래에서 설명합니다.)

다음은 권한 세트 Lexicon의 예입니다. 전체 구문은 [Lexicon 사양](/specs/lexicon)에 설명되어 있습니다.

```
{
  "lexicon": 1,
  "id": "com.example.authBasicFeatures",
  "defs": {
    "main": {
      "type": "permission-set",
      "title": "Basic App Functionality",
      "title:lang": {
        "ja": "基本的なアプリ機能"
      },
      "detail": "Creation of posts and interactions",
      "detail:lang": {
        "ja": "投稿と交流の作成"
      },
      "permissions": [
        {
          "type": "permission",
          "resource": "repo",
          "collection": ["app.example.post"]
        },
        {
          "type": "permission",
          "resource": "repo",
          "collection": ["app.example.like"],
          "action": ["delete"]
        },
        {
          "type": "permission",
          "resource": "rpc",
          "inheritAud": true,
          "lxm": [
            "app.example.getFeed"
            "app.example.getProfile",
            "app.example.getPreferences",
            "app.example.putPreferences",
            "app.example.getAuthorFeed",
            ...
          ]
        },
        {
          "type": "permission",
          "resource": "rpc",
          "aud": "*",
          "lxm": ["app.example.getFeedSkeleton"]
        }
      ]
    }
  }
}
```

이 전체 권한 세트는 다음과 같은 인증 스코프 문자열로 요청할 수 있습니다:

```
include:com.example.authBasicFeatures?aud=did:web:api.example.com%23svc_appview
```

일부 `rpc` 권한에 `inheritAud` 플래그가 true로 설정되어 있으므로 `include`의 `aud` 매개변수가 해당 특정 `rpc` 권한으로 전달됩니다. `include`의 일부로 `aud`가 포함되지 않았다면 기본값(대상 없음)이 대신 사용되었을 것입니다.

권한 세트는 Lexicon 스키마이며 암호화 인증을 포함하는 Lexicon 해결 시스템을 사용하여 게시되고 가져옵니다. 권한 세트는 네임스페이스에 새로운 스키마가 추가됨에 따라(예: 새로운 레코드 타입 또는 API 엔드포인트) 시간이 지남에 따라 업데이트될 수 있습니다. 인증 서버는 해결된 세트의 캐시를 유지해야 하지만 주기적으로 다시 해결해야 합니다. 액세스 토큰과 관련된 권한은 고정되어 있어야 하지만, 클라이언트가 토큰을 갱신(새 액세스 토큰 획득)할 때 세션에 대해 계산된 권한은 클라이언트가 요청한 세트의 변경 사항을 반영하여 업데이트될 수 있습니다.

이는 권한 세트와 관련된 OAuth 세션에 의도적인 시간적 동적성을 추가합니다. Lexicon 설계자는 새로운 리소스(예: 레코드 타입)를 정의하고 해당 리소스에 대한 권한을 포함하도록 게시된 세트를 업데이트할 수 있습니다. 그러면 클라이언트 소프트웨어는 사용자가 세션을 다시 인증할 필요 없이 새로운 Lexicon을 활용하도록 업데이트될 수 있습니다. OAuth 세션은 초기 부여의 인증 스코프로 엄격하게 제한됩니다. 이러한 유연성을 가능하게 하는 것은 권한 세트의 간접성(indirection)입니다.

인증 서버와 리소스 서버는 권한 세트 내의 개별 권한 선언이 알 수 없는 리소스를 설명하거나 예상치 못한 매개변수 이름 또는 값을 포함하는 경우 해당 선언을 무시해야 합니다. 이러한 동작의 이유는 권한 시스템이 시간이 지남에 따라 발전할 것으로 예상되며, 새로운 클라이언트 권한 요청이 전체적으로 거부되어서는 안 되기 때문입니다. 동시에, 새로운 매개변수(필드)가 권한을 더 세분화할 수 있으므로 부분적으로 이해된 권한을 부여하는 것은 안전하지 않습니다.

<Heading level={2} id="namespace-authority">네임스페이스 권한</Heading>

권한 세트는 세트 자체와 동일한 NSID 네임스페이스 아래의 리소스를 참조하는 권한을 표현하는 것으로 제한됩니다.

권한(Authority)은 "형제(siblings)"나 특별한 네임스페이스 없이 NSID의 상대적 구조를 기반으로 합니다. 대체로 이는 세트가 네임스페이스 전반에 걸쳐 권한을 요청할 수 없음을 보장합니다. 구체적으로:

- 권한 세트는 동일한 NSID "그룹"의 리소스 또는 "자식"(하위 도메인, 재귀적으로 깊게)을 주소로 지정할 수 있습니다.
- NSID 계층 구조에서 "형제 그룹"이나 "부모"를 주소로 지정할 수 없습니다.

예를 들어, `app.example.feed.authOnlyPost` 세트는 `app.example.feed.post` 레코드에 대한 권한과 원격 서비스에 `app.example.feed.getPostThread` API 엔드포인트 요청을 보내는 권한을 포함할 수 있습니다. 하지만 `app.example.actor.profile`에 대한 권한은 부여할 수 없습니다. 계층 구조에서 한 단계 위에 있는 `app.example.authFull` 권한 세트는 이러한 모든 리소스 또는 계층 구조 더 아래에 있는 리소스에 대한 권한을 포함할 수 있습니다.

<Heading level={2} id="resolution-and-caching">해결 및 캐싱</Heading>

권한 세트 Lexicon은 인증 서버(예: PDS 인스턴스)에서 해결해야 합니다. 기존 [Lexicon 게시 및 해결 시스템](/specs/lexicon)은 스키마가 게시되고 검증되는 방법을 설명합니다.

네트워크 트래픽을 줄이고 중단에 대한 탄력성을 높이기 위해 인증 서버는 권한 세트 해결을 캐시할 것으로 예상됩니다. 캐시는 인증 서버의 모든 계정 및 세션에서 공유될 수 있습니다.

권한 세트 스키마는 긴 "만료(expiration)" 시간과 짧은 "stale(오래된/신선하지 않은)" 시간으로 캐시되어야 합니다. Stale Lexicon은 업데이트되어야 하지만(즉, 해결 갱신 시도), 해결이 실패하면 이전에 존재하던 stale 값을 사용할 수 있습니다. 권장되는 "stale" 수명은 24시간이며, 이는 캐시 수명의 확고한 상한선입니다. 캐시 수명의 확고한 하한선은 액세스 토큰 수명, 즉 15~30분입니다. 새로운 인증 세션에 대해 권한 세트를 참조하기 위한 권장 "만료" 수명은 90일이지만, 이는 확고한 경계는 아닙니다. 기존 인증 세션은 캐시에서 권한 세트가 "만료"되더라도 영향을 받지 않아야 합니다.

세션 시작 시 권한 세트를 해결할 수 없고(로컬 캐시에 이미 없는 경우) 인증 요청은 실패합니다.

<Heading level={2} id="usage-and-implementation-guidelines">사용 및 구현 가이드라인</Heading>

현재 정의된 리소스와 매개변수는 모든 구문의 유연성을 활용하지는 않습니다. 구현체는 일반 구문 대신 현재 사용되는 구문에 집중하기로 결정할 수 있습니다.

인증 서버는 권한 세트의 lexicon 해결을 오프로드하기 위해 "Lexicon Aggregator" 서비스를 사용하기로 선택할 수 있습니다. 이러한 서비스는 업데이트된 권한 세트를 감지하기 위해 전체 네트워크 파이어호스를 모니터링합니다. NSID 도메인 하이재킹이나 권한 세트 범위에 대한 적대적 변경을 방지하기 위한 보안 로직을 포함할 수 있습니다.

<Heading level={2} id="possible-future-changes">가능한 향후 변경 사항</Heading>

리소스 세트는 프로토콜에 새로운 기능이 추가됨에 따라 시간이 지남에 따라 확장될 것으로 예상됩니다.

`account` 및 `identity` 리소스에 추가 속성이 추가될 것으로 예상됩니다.

이전 제안에서는 권한 세트 해결 캐시를 제거(purging)하는 메커니즘을 설명했습니다. 이를 통해 캐시된 해결로 인해 클라이언트 소프트웨어에 권한을 사용할 수 없는 우려 없이 업데이트된 lexicon 리소스와 업데이트된 클라이언트 소프트웨어를 동기화하여 릴리스할 수 있습니다. 이 메커니즘은 아직 구현되지 않았으며 현재 사양에는 포함되지 않았습니다.