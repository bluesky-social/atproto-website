export const metadata = {
  title: 'Lexicon',
  description:
    '스키마 정의 언어입니다.',
}

# Lexicon

Lexicon은 atproto 레코드, HTTP 엔드포인트(XRPC) 및 이벤트 스트림 메시지를 설명하기 위해 사용되는 스키마 정의 언어입니다. 이는 atproto의 [Data Model](/specs/data-model)을 기반으로 합니다. {{ className: 'lead' }}

이 스키마 언어는 [JSON Schema](http://json-schema.org/) 및 [OpenAPI](https://en.wikipedia.org/wiki/OpenAPI_Specification)와 유사하지만, atproto 전용 기능과 의미론을 포함합니다. {{ className: 'lead' }}

이 명세는 Lexicon 정의 언어의 버전 1을 설명합니다. {{ className: 'lead' }}

## 타입 개요

| Lexicon Type | Data Model Type | Category |
| --- | --- | --- |
| `null` | Null | concrete |
| `boolean` | Boolean | concrete |
| `integer` | Integer | concrete |
| `string` | String | concrete |
| `bytes` | Bytes | concrete |
| `cid-link` | Link | concrete |
| `blob` | Blob | concrete |
| `array` | Array | container |
| `object` | Object | container |
| `params` |  | container |
| `token` |  | meta |
| `ref` |  | meta |
| `union` |  | meta |
| `unknown` |  | meta |
| `record` |  | primary |
| `query` |  | primary |
| `procedure` |  | primary |
| `subscription` |  | primary |

## Lexicon 파일

Lexicon은 단일 NSID와 연관된 JSON 파일입니다. 파일은 하나 이상의 정의를 포함하며, 각 정의는 고유한 짧은 이름을 갖습니다. 이름이 `main`인 정의는 파일 전체에 대한 "주요" 정의를 선택적으로 설명합니다. 정의가 하나도 없는 Lexicon은 유효하지 않습니다.

Lexicon JSON 파일은 다음 필드를 가진 객체입니다:

- `lexicon` (정수, 필수): Lexicon 언어 버전을 나타냅니다. 이 버전에서는 고정값 `1`
- `id` (문자열, 필수): Lexicon의 NSID
- `revision` (정수, 선택): 변경 사항이 발생한 경우 Lexicon의 버전을 나타냅니다
- `description` (문자열, 선택): 보통 한두 문장으로 구성된 Lexicon에 대한 간단한 개요
- `defs` (문자열-객체의 맵, 필수): 각기 다른 이름(키)을 가진 정의들의 집합

`defs` 아래의 스키마 정의들은 모두 자신들의 타입을 구분하기 위해 `type` 필드를 포함합니다. 파일은 "기본" 타입(definition) 중 하나를 가질 수 있으며, 이 경우 이름은 항상 `main`이어야 합니다. `main`이 기본 타입이 아닌 타입을 설명하는 것도 가능합니다.

Lexicon 내 특정 정의에 대한 참조는 조각(fragment) 구문(예: `com.example.defs#someView`)을 사용합니다. `main` 정의가 존재할 경우 NSID만으로 참조할 수 있으며, 조각(`#main`)을 붙여서는 안 됩니다. 예를 들어, 데이터 객체(레코드나 union 내의 값)의 `$type` 필드 내 참조는 반드시 NSID만 사용해야 하며, `#main` 접미사를 사용해서는 안 됩니다. 예: `com.example.record` (올바름) vs `com.example.record#main` (잘못됨).

`revision` 필드의 의미론은 아직 완전히 확립되지 않았으나, 이는 여러 버전이나 복사본 중 가장 최신의 Lexicon을 식별하는 데 도움이 될 의도로 마련되었습니다.

관련 Lexicon들은 종종 NSID 계층 내에서 함께 그룹화됩니다. 관례상 여러 Lexicon에서 사용되는 정의들은 전용 `*.defs` Lexicon(예: `com.atproto.server.defs`)에 정의됩니다. 일반적으로 `*.defs` Lexicon은 `main`이라는 이름의 정의를 포함하지 않아야 하지만, 반드시 그렇다는 규칙은 아닙니다.

## 기본 타입 정의

기본 타입은 다음과 같습니다:

- `query`: XRPC Query (HTTP GET)를 설명합니다.
- `procedure`: XRPC Procedure (HTTP POST)를 설명합니다.
- `subscription`: 이벤트 스트림(WebSocket)
- `record`: 저장소 레코드에 저장될 수 있는 객체를 설명합니다.

각 기본 정의 스키마 객체는 다음 필드를 포함합니다:

- `type` (문자열, 필수): 타입 값 (예: 레코드의 경우 `record`)
- `description` (문자열, 선택): 보통 한두 문장으로 구성된 간단한 설명

### Record

타입 별 추가 필드:

- `key` (문자열, 필수): [Record Key type](/specs/record-key)를 지정합니다.
- `record` (객체, 필수): 이 레코드 타입을 지정하는 `object` 타입의 스키마 정의

### Query 및 Procedure (HTTP API)

타입 별 추가 필드:

- `parameters` (객체, 선택): 이 엔드포인트의 HTTP 쿼리 매개변수를 설명하는 `params` 타입의 스키마 정의
- `output` (객체, 선택): HTTP 응답 본문을 설명합니다.
    - `description` (문자열, 선택): 간단한 설명
    - `encoding` (문자열, 필수): 본문 내용의 MIME 타입. JSON 응답의 경우 `application/json`을 사용합니다.
    - `schema` (객체, 선택): `object`, `ref` 또는 refs의 `union` 중 하나인 스키마 정의. JSON 인코딩 응답을 설명하는 데 사용되며, JSON 응답의 경우에도 스키마는 선택적입니다.
- `input` (객체, 선택, `procedure` 전용): HTTP 요청 본문 스키마를 설명하며, `output` 필드와 동일한 형식을 따릅니다.
- `errors` (객체 배열, 선택): 반환될 수 있는 문자열 오류 코드 집합
    - `name` (문자열, 필수): 공백 없이 오류 타입의 간단한 이름
    - `description` (문자열, 선택): 한두 문장 정도의 간단한 설명

### Subscription (이벤트 스트림)

타입 별 추가 필드:

- `parameters` (객체, 선택): Query 및 Procedure와 동일
- `message` (객체, 선택): 메시지의 유형을 지정합니다.
    - `description` (문자열, 선택): 간단한 설명
    - `schema` (객체, 필수): 스키마 정의. 반드시 refs의 `union` 타입이어야 합니다.
- `errors` (객체 배열, 선택): Query 및 Procedure와 동일

`message` 아래 참조되는 Subscription 스키마는 반드시 refs의 `union` 타입이어야 하며, `object` 타입은 허용되지 않습니다.

## 필드 타입 정의

기본 정의와 마찬가지로, 모든 스키마 객체는 다음 필드를 포함합니다:

- `type` (문자열, 필수): 각 타입에 대한 고정 값
- `description` (문자열, 선택): 보통 한두 문장 정도의 간단한 설명

### `null`

추가 필드 없음.

### `boolean`

타입 별 추가 필드:

- `default` (boolean, 선택): 이 필드의 기본값
- `const` (boolean, 선택): 이 필드의 고정(상수) 값

HTTP 쿼리 매개변수로 포함될 경우, `true` 또는 `false` (따옴표 없이)로 렌더링되어야 합니다.

### `integer`

부호가 있는 정수 숫자.

타입 별 추가 필드:

- `minimum` (정수, 선택): 허용되는 최소 값
- `maximum` (정수, 선택): 허용되는 최대 값
- `enum` (정수 배열, 선택): 허용되는 값들의 폐쇄 집합
- `default` (정수, 선택): 이 필드의 기본값
- `const` (정수, 선택): 이 필드의 고정(상수) 값

### `string`

타입 별 추가 필드:

- `format` (문자열, 선택): 문자열 형식 제한
- `maxLength` (정수, 선택): UTF-8 바이트 단위의 최대 길이
- `minLength` (정수, 선택): UTF-8 바이트 단위의 최소 길이
- `maxGraphemes` (정수, 선택): 유니코드 그래프 클러스터(시각적 문자) 기준 최대 길이
- `minGraphemes` (정수, 선택): 유니코드 그래프 클러스터 기준 최소 길이
- `knownValues` (문자열 배열, 선택): 이 필드에 대한 추천 또는 일반적인 값들의 집합 (폐쇄 enum은 아님)
- `enum` (문자열 배열, 선택): 허용되는 값들의 폐쇄 집합
- `default` (문자열, 선택): 이 필드의 기본값
- `const` (문자열, 선택): 이 필드의 고정(상수) 값

문자열은 유니코드입니다. 유니코드가 아닌 인코딩의 경우 `bytes`를 사용하십시오. 기본적인 `minLength`/`maxLength` 검증은 UTF-8 바이트 수를 기준으로 합니다. Javascript는 문자열을 기본적으로 UTF-16으로 저장하므로 정확한 바이트 수 계산을 위해 재인코딩이 필요합니다. `minGraphemes`/`maxGraphemes` 검증은 복잡한 기술적 및 언어학적 정의를 가진 그래프 클러스터를 기준으로 하지만, 대략적으로는 라틴 문자, CJK 문자, 구두점, 숫자, 또는 이모지(여러 유니코드 코드포인트 및 다수의 UTF-8 바이트로 구성될 수 있음)와 같은 "시각적 문자"에 해당합니다.

`format`은 문자열의 형식을 제한하고 추가 의미를 제공합니다. 사용 가능한 형식 및 그 정의에 대해서는 데이터 모델 명세를 참조하십시오.

`const`와 `default`는 서로 배타적입니다.

### `bytes`

타입 별 추가 필드:

- `minLength` (정수, 선택): 인코딩 없이 원시 바이트 기준 최소 크기
- `maxLength` (정수, 선택): 인코딩 없이 원시 바이트 기준 최대 크기

### `cid-link`

추가 필드 없음.

CID 제한에 대해서는 [Data Model spec](/specs/data-model)을 참조하십시오.

### `array`

타입 별 추가 필드:

- `items` (객체, 필수): 이 배열의 요소들을 설명하는 스키마
- `minLength` (정수, 선택): 배열 요소의 최소 개수
- `maxLength` (정수, 선택): 배열 요소의 최대 개수

이론상 배열은 동질적 타입(모든 요소가 동일한 타입)을 가지지만, union 타입의 경우 이러한 제한은 의미가 없으므로 구현체는 모든 요소가 동일한 타입임을 가정할 수 없습니다.

### `object`

다른 정의 내에서 참조될 수 있는 일반 객체 스키마.

타입 별 추가 필드:

- `properties` (문자열-객체의 맵, 필수): 각 필드의 이름과 해당 스키마를 정의합니다.
- `required` (문자열 배열, 선택): 필수 속성을 나타냅니다.
- `nullable` (문자열 배열, 선택): `null` 값을 가질 수 있는 속성을 나타냅니다.

데이터 모델 명세에서 설명된 바와 같이, 필드를 생략하는 것, 필드를 `null` 값으로 포함하는 것, 또는 "false-y" 값(예: `false`, `0`, 빈 배열 등)을 포함하는 것 사이에는 의미론적 차이가 있습니다.

### `blob`

타입 별 추가 필드:

- `accept` (문자열 배열, 선택): 허용되는 MIME 타입 목록. 각 타입은 glob 패턴(`image/*` 등)으로 끝날 수 있습니다. 모든 MIME 타입을 허용하려면 `*/*`를 사용합니다.
- `maxSize` (정수, 선택): 최대 크기 (바이트 단위)

### `params`

이 타입은 `query`, `procedure`, `subscription`의 `parameters` 필드에만 사용되는 제한된 범위의 타입입니다. 이는 HTTP 쿼리 매개변수에 매핑됩니다.

타입 별 추가 필드:

- `required` (문자열 배열, 선택): `object`의 `required`와 동일한 의미
- `properties`: `object`의 properties와 유사하지만, 포함할 수 있는 타입은 `boolean`, `integer`, `string`, `unknown` 또는 이들 중 하나의 `array`로 제한됩니다.

`object`와 달리 `params`에는 `nullable` 필드가 없습니다.

### `token`

토큰은 참조를 위해서만 존재하는 빈 데이터 값입니다. 이는 특정 의미를 가진 값 집합을 정의하는 데 사용됩니다. `description` 필드는 토큰의 의미를 명확히 해야 합니다. 토큰은 문자열 데이터로 인코딩되며, 문자열은 토큰 자체(NSID 뒤에 선택적 조각)의 완전한 참조를 나타냅니다.

토큰은 일부 프로그래밍 언어의 "심볼" 개념과 유사하며, 문자열, 변수, 내장 키워드 등과 구분됩니다.

예를 들어, 토큰은 엔티티의 상태(상태 머신)나 범주 목록을 열거하기 위해 정의될 수 있습니다.

추가 필드 없음.

### `ref`

타입 별 추가 필드:

- `ref` (문자열, 필수): 다른 스키마 정의에 대한 참조

ref는 여러 위치에서 스키마 정의를 재사용할 수 있도록 하는 메커니즘입니다. `ref` 문자열은 Lexicon 타입 정의(전역 NSID, 선택적 `#` 구분 이름)나 같은 Lexicon 파일 내의 로컬 정의(이름 앞에 `#`)를 참조할 수 있습니다.

### `union`

타입 별 추가 필드:

- `refs` (문자열 배열, 필수): 스키마 정의에 대한 참조
- `closed` (boolean, 선택): union이 "열림"인지 "닫힘"인지를 나타냅니다. 기본값은 `false` (열림)

union은 이 위치에서 여러 가능한 타입이 올 수 있음을 나타냅니다. 참조는 `ref`와 동일한 구문을 따르며, 전역 참조와 로컬 참조 모두 허용됩니다. 실제 데이터는 단일 구체 타입에 대해 검증됩니다: union은 여러 스키마의 필드를 *조합*하거나 새로운 *하이브리드* 데이터 타입을 정의하지 않습니다. 이때 각 다른 타입은 **variant**라고 부릅니다.

기본적으로 union은 "열림"으로, 이는 향후 명세의 개정 시 refs 목록에 새로운 타입이 추가될 수 있음을 의미합니다. 따라서 구현체는 최신 Lexicon이 아닐 수 있음을 감안하여 검증할 때 관대해야 합니다. `closed` 플래그(true)를 설정하면 타입 목록이 고정되었음을 나타냅니다.

`refs`가 없는 `union` 스키마 정의는 `closed` 플래그가 false(기본값)인 경우 `unknown`과 유사하게 허용됩니다. 주요 차이점은 데이터에 `$type` 필드가 필요하다는 점입니다. `closed`가 true인 빈 refs 목록은 유효하지 않은 스키마입니다.

`union`이 참조하는 스키마 정의들은 모두 객체 혹은 객체로 매핑이 명확한 타입이어야 하며, 각 variant는 CBOR map(또는 JSON Object)로 표현되고 variant 타입을 나타내는 `$type` 필드를 포함해야 합니다. 데이터는 객체여야 하므로 union은 `token`을 참조할 수 없습니다(토큰은 문자열 데이터에 해당).

### `unknown`

이 타입은 특정 검증 없이 어떤 데이터 객체든 올 수 있음을 나타냅니다. 최상위 데이터는 객체여야 하며(문자열, 불리언 등은 안 됨), 해당 위치에 `null`도 허용되지 않습니다(필드가 `nullable`로 명시되지 않은 한).

데이터 객체는 스키마를 나타내는 `$type` 필드를 포함할 수 있지만, 이는 필수가 아닙니다. 최상위 데이터 객체는 blob(`$type: blob`)이나 CID link(`$link`)와 같은 복합 데이터 타입의 구조를 가져서는 안 됩니다.

데이터 모델에 따라 데이터 객체의 (중첩된) 내용은 여전히 유효해야 합니다. 예를 들어, 부동소수점 수는 포함하면 안 됩니다. blob이나 CID link와 같은 중첩 복합 타입은 예상대로 검증 및 변환되어야 합니다.

Lexicon 디자이너는 당분간 `record` 객체 내에서 `unknown` 필드의 사용을 자제할 것을 강력히 권장합니다.

추가 필드 없음.

## 문자열 형식

문자열은 선택적으로 다음 `format` 타입 중 하나로 제한될 수 있습니다:

- `at-identifier`: [Handle](/specs/handle) 또는 [DID](/specs/did)를 의미하며, 아래에서 자세히 설명됩니다.
- `at-uri`: [AT-URI](/specs/at-uri-scheme)
- `cid`: [Data Model](/specs/data-model)에 지정된 형식의 CID 문자열
- `datetime`: 아래에 설명된 타임스탬프
- `did`: 일반적인 [DID Identifier](/specs/did)
- `handle`: [Handle Identifier](/specs/handle)
- `nsid`: [Namespaced Identifier](/specs/nsid)
- `tid`: [Timestamp Identifier (TID)](/specs/tid)
- `record-key`: [Record Key](/specs/record-key), 일반적인 구문("any")을 따름
- `uri`: 일반 URI, 아래에 설명됨
- `language`: 아래에 설명된 언어 코드

여러 식별자 형식의 경우, Lexicon 스키마 검증 시 가능한 한 포괄적인 식별자 구문을 허용해야 합니다. 기본 구문 검증을 통과하지 못하는 식별자에 대해서는 Lexicon 데이터 검증 오류가 아닌 애플리케이션 오류로 보고되어야 합니다. 예를 들어, `did` 형식 문자열 필드에 어떠한 DID가 포함되더라도 Lexicon 검증은 통과해야 하며, 지원되지 않는 DID 메서드는 별도의 애플리케이션 오류로 처리됩니다.

### `at-identifier`

DID(`did`) 또는 핸들(`handle`) 중 하나인 문자열 타입입니다. DID는 항상 `did:`로 시작하며, 콜론(`:`)은 핸들에 허용되지 않으므로 at-identifier가 핸들과 DID 중 어느 것인지 명확히 구분됩니다.

### `datetime`

타임존 정보를 포함한 정밀한 날짜 및 시간.

이 형식은 현대 컴퓨팅 시대(예: UNIX epoch 이후)의 컴퓨터 생성 타임스탬프에 사용하기 위한 것입니다. 만약 역사적 사건, 모호성 또는 먼 미래의 시간을 나타내야 한다면 다른 형식을 사용하는 것이 바람직합니다. 연대기 이전(기원전)은 명시적으로 허용되지 않습니다.

날짜 및 시간 형식 표준은 매우 유연하며 서로 겹칠 수 있습니다. atproto의 datetime 문자열은 [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339), [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) 및 [WHATWG HTML](https://html.spec.whatwg.org/#dates-and-times) 표준의 교차 조건을 충족해야 합니다.

날짜와 시간 사이를 구분하는 문자는 반드시 대문자 `T`여야 합니다.

타임존 지정은 필수이며, UTC 타임존 사용과 대문자 `Z` 접미사(소문자 사용 불가)를 강력히 권장합니다. 시/분 형식(예: `+01:00` 또는 `-10:30`)도 지원되지만, ISO 8601에 따라 "음의 0"(`-00:00`)은 명시적으로 허용되지 않습니다.

전체 초(second) 정밀도가 필수이며, 임의의 소수점 이하 자릿수는 허용됩니다. 최소한 밀리초 정밀도를 사용하고 생성된 정밀도에 맞게 0으로 채워주는 것이 모범 사례입니다(예: `:12.340Z`는 `:12.34Z` 대신). 모든 datetime 포맷 라이브러리가 후행 0 포맷을 지원하는 것은 아닙니다. 밀리초와 마이크로초 정밀도는 언어 간에 reasonably 지원되지만, 나노초 정밀도는 그렇지 않습니다.

구현체는 정밀도 손실 및 후행 소수점 0의 모호성과 같은 datetime의 양방향 문제에 주의해야 합니다. 만약 Lexicon 레코드를 네이티브 타입으로 직렬화 및 역직렬화 한 후 재직렬화할 경우, 문자열 표현이 달라져 해시 참조, 무결성 검증 또는 저장소 업데이트에 문제가 생길 수 있습니다. 따라서 datetime을 단순 문자열로 역직렬화하여 원본 문자열을 유지하는 것이 안전합니다.

구현체는 datetime의 의미론적 유효성(예: 월이나 일이 `00`인 경우 등)도 검증해야 합니다.

유효한 예제:

```text
# 선호
1985-04-12T23:20:50.123Z
1985-04-12T23:20:50.123456Z
1985-04-12T23:20:50.120Z
1985-04-12T23:20:50.120000Z

# 지원
1985-04-12T23:20:50.12345678912345Z
1985-04-12T23:20:50Z
1985-04-12T23:20:50.0Z
1985-04-12T23:20:50.123+00:00
1985-04-12T23:20:50.123-07:00
```

잘못된 예제:

```text
1985-04-12
1985-04-12T23:20Z
1985-04-12T23:20:5Z
1985-04-12T23:20:50.123
+001985-04-12T23:20:50.123Z
23:20:50.123Z
-1985-04-12T23:20:50.123Z
1985-4-12T23:20:50.123Z
01985-04-12T23:20:50.123Z
1985-04-12T23:20:50.123+00
1985-04-12T23:20:50.123+0000

# ISO-8601 엄격한 대소문자 구분
1985-04-12t23:20:50.123Z
1985-04-12T23:20:50.123z

# RFC-3339는 맞으나, ISO-8601은 아님
1985-04-12T23:20:50.123-00:00
1985-04-12 23:20:50.123Z

# 타임존 지정은 필수
1985-04-12T23:20:50.123

# 구문은 올바르나, datetime 값이 유효하지 않음
1985-04-12T23:99:50.123Z
1985-00-12T23:20:50.123Z
```

### `uri`

RFC-3986에 따라 URI 스키마에 유연한 모든 URI 형식을 지원합니다. 여기에는 `did`, `https`, `wss`, CID를 위한 `ipfs`, `dns` 및 물론 `at` 등이 포함됩니다.
Lexicon에서 최대 길이는 8 KBytes입니다.

### `language`

[IETF Language Tag](https://en.wikipedia.org/wiki/IETF_language_tag) 문자열로, [BCP 47](https://www.rfc-editor.org/info/bcp47)을 준수하며, [RFC 5646](https://www.rfc-editor.org/rfc/rfc5646.txt) ("언어 식별을 위한 태그")에 정의되어 있습니다. 이는 HTTP, HTML 등 다른 웹 표준에서 언어를 식별하는 동일한 표준입니다. Lexicon 문자열은 RFC에 정의된 "well-formed" 언어 태그여야 하며, 클라이언트는 "well-formed"하지만 RFC에 따라 "유효하지 않은" 언어 문자열은 무시해야 합니다.

RFC에 명시된 대로, 소문자로 된 ISO 639의 2자 또는 3자 언어 코드를 단독으로 사용할 수 있으며, 예를 들어 `ja` (일본어)나 `ban` (발리어) 등이 이에 해당합니다. 지역 서브태그는 `pt-BR` (브라질 포르투갈어)와 같이 추가될 수 있습니다. 그 외에도 `hy-Latn-IT-arevela`와 같이 추가 서브태그가 붙을 수 있습니다.

언어 코드는 단순 문자열 비교가 아닌 파싱, 정규화 및 의미론적 매칭이 필요합니다. 예를 들어, 검색 엔진은 색인 및 필터링을 위해 언어 태그를 ISO 639 코드로 단순화할 수 있지만, 클라이언트 애플리케이션은 전체 언어 코드를 로컬에서 유지할 수 있어야 합니다.

## 언제 `$type`을 사용할까

데이터 객체는 가끔 `$type` 필드를 포함하여 Lexicon 타입을 나타냅니다. 이 필드는 데이터 검증 시 내용 타입에 대해 모호성이 있을 경우 반드시 포함되어야 합니다.

구체적인 규칙은 다음과 같습니다:

- `record` 객체는 항상 `$type`을 포함해야 합니다. 레코드가 저장소의 컬렉션 경로 등에서 타입이 추론될 수 있으나, 레코드 객체는 저장소 외부로 전달될 수 있으므로 자체적으로 타입을 명시해야 합니다.
- `union`의 variant들은 (subscription 메시지의 최상위 제외) 항상 `$type`을 포함해야 합니다.

또한, `blob` 객체는 항상 `$type`을 포함하여 일반적인 처리를 가능하게 합니다.

참고로, `main` 타입은 `$type` 필드에서 NSID만 사용해야 하며, `#main` 접미사는 사용하면 안 됩니다.

## Lexicon 진화

Lexicon은 전진 및 후진 호환성을 보장하는 범위 내에서 시간이 지남에 따라 변경될 수 있습니다. 기본 원칙은 기존의 모든 데이터는 업데이트된 Lexicon에서도 유효해야 하며, 새로운 데이터는 구버전 Lexicon에서도 유효해야 한다는 것입니다.

- 새로운 필드는 모두 선택적이어야 합니다.
- 필수 필드는 제거할 수 없습니다. 더 이상 사용되지 않는 필드는 사용 중단(deprecated)으로 표시하는 것이 모범 사례입니다.
- 타입은 변경될 수 없습니다.
- 필드 이름은 변경될 수 없습니다.

보다 큰 변경이 필요한 경우에는 새로운 Lexicon 이름을 사용해야 합니다.

Lexicon이 "확정"되었다는 것을 판단하는 것은 모호할 수 있습니다. 최소한 공개 채택 및 타 제3자의 구현이 이루어진 경우 해당 Lexicon은 출시된 것으로 간주되어 호환성을 깨뜨려서는 안 됩니다. 모범 사례로, 실험적 또는 개발 중임을 나타내기 위해 Lexicon 타입 이름에 이를 명시하는 것이 좋습니다. 예: `com.corp.experimental.newRecord`.

## 권한 및 제어

Lexicon의 권한은 NSID에 의해 결정되며, DNS의 도메인 권한에 근거합니다. 해당 권한은 Lexicon 정의에 대한 최종 통제권을 가지며, Lexicon 스키마 정의의 유지보수 및 배포에 책임을 집니다.

DNS 제어권을 잃어 부정적인 행위자가 나타나는 위기 상황에서는 프로토콜 생태계가 이 권한 체계를 무시할 수 있습니다. 이는 예외적인 상황에서만 적용되어야 하며, 활동 중인 권한을 전복시키기 위한 수단으로 사용되어서는 안 됩니다. 프로토콜 분쟁 해결의 기본 메커니즘은 Lexicon을 새로운 네임스페이스로 포크하는 것입니다.

프로토콜 구현체는 Lexicon 검증에 실패한 데이터를 완전히 유효하지 않은 것으로 간주하고, 개별 데이터에 대해 부분적인 처리나 복구를 시도해서는 안 됩니다.

Lexicon에 부합하는 나머지 데이터 내의 예상치 못한 필드는 무시되어야 합니다. 스키마 검증 시 이러한 필드는 경고 정도로 취급되어야 합니다. 이는 제어 권한에 의한 명세의 진화와 구버전 Lexicon을 고려한 강건함을 보장하기 위함입니다.

제3자는 기술적으로 데이터 내에 추가 필드를 삽입할 수 있으나, 이는 권장되는 확장 방식은 아닙니다. 다만, Lexicon이 나중에 동일한 이름의 필드를 다른 타입으로 추가할 경우 기존 데이터가 유효하지 않게 될 위험이 있습니다.

## 사용 및 구현 지침

Lexicon 스키마는 JSON Schema나 OpenAPI로 변환되어, 해당 생태계의 도구 및 라이브러리를 활용해 JSON 형식의 atproto 데이터를 처리할 수 있어야 합니다.

JSON 또는 CBOR에서 Lexicon 기반의 구조로 데이터를 직렬화/역직렬화하는 구현체는 예상치 못한 필드가 "덮어쓰기(clobber)"되는 위험에 주의해야 합니다. 예를 들어, Lexicon이 새로운(선택적) 필드를 추가할 경우, 구버전 구현체는 이를 인지하지 못해 역직렬화 후 재직렬화 시 해당 데이터가 누락될 수 있습니다. 이를 방지하기 위한 한 가지 방법은 모든 "추가" 필드를 유지하거나, 원본 데이터 객체를 그대로 전달하는 것입니다.

## 향후 변경 가능성

예상치 못한 추가 필드에 대한 검증 규칙은 변경될 수 있습니다. 예를 들어, 명세가 "닫힌(closed)" 스키마를 나타내어 예상치 못한 필드를 허용하지 않거나, 비공식 확장을 나타내기 위해 필드 이름 접두사(`x-`)에 관한 규약이 생길 수 있습니다.
