export const metadata = {
  title: 'OAuth',
  description:
    '클라이언트/서버 인증 및 권한 부여를 위한 OAuth',
}

# OAuth

<Note>
atproto를 위한 OAuth 프로파일은 새로 도입되었으며, 개발 커뮤니티의 피드백과 진행 중인 표준 작업에 따라 수정될 수 있습니다. 자세한 내용은 [OAuth 로드맵](https://github.com/bluesky-social/atproto/discussions/2656)을 참조하세요.
</Note>

<Note>
이 명세는 권위 있는 표준이지만 구현 가이드는 아니며, 설계 결정의 배경이나 맥락에 대한 설명은 많지 않습니다. 초기 [설계 제안](https://github.com/bluesky-social/proposals/tree/main/0004-oauth)은 권위 있는 문서는 아니지만 보다 많은 배경과 예시를 제공합니다. 개발자에게는 SDK 문서나 [OAuth 클라이언트 구현 가이드](https://docs.bsky.app/docs/advanced-guides/oauth-client)가 더 이해하기 쉬울 수 있습니다.
</Note>

OAuth는 atproto에서 클라이언트가 PDS 인스턴스에 대해 권한 있는 요청을 수행하기 위한 주요 메커니즘입니다. 대부분의 사용자 대상 소프트웨어는 OAuth를 사용하도록 설계되어 있으며, 여기에는 모바일 앱, 리치 브라우저 앱, 네이티브 데스크톱 앱과 같은 "프론트엔드" 클라이언트뿐 아니라 웹 서비스와 같은 "백엔드" 클라이언트도 포함됩니다.

다른 인증 방식에 대해서는 atproto의 [HTTP API 명세](./xrpc)를 참고하세요. 여기에는 기존의 HTTP 클라이언트 세션/토큰 및 서비스 간 인증 방식이 포함되어 있습니다.

OAuth는 IETF에 의해 표준화된 표준 및 모범 사례의 지속적으로 발전하는 프레임워크입니다. atproto는 이 문서에서 설명하는 특정 OAuth 표준 조합을 의무화하는 OAuth의 "프로파일"을 사용합니다.

대략적으로 atproto는 다음과 같이 "OAuth 2.1"([`draft-ietf-oauth-v2-1`](https://datatracker.ietf.org/doc/draft-ietf-oauth-v2-1/))의 진화를 시작점으로 합니다. 즉:

- OAuth 2.0의 "authorization code" 그랜트 타입만 지원하며, "implicit"나 다른 그랜트 타입은 지원하지 않습니다.
- Proof Key for Code Exchange(PKCE, [RFC 7636](https://datatracker.ietf.org/doc/html/rfc7636))가 의무화됩니다.
- 보안 모범 사례([`draft-ietf-oauth-security-topics`](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics) 및 [`draft-ietf-oauth-browser-based-apps`](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps))가 필수입니다.

중앙 집중형 앱 플랫폼과 달리, atproto에서는 독립적인 서버 구현체가 다수 존재하므로, 서버 검색과 클라이언트 등록은 공개 인증 서버 메타데이터와 공개 클라이언트 메타데이터의 조합을 통해 자동화됩니다. `client_id`는 클라이언트 메타데이터(JSON 문서)가 위치한 완전한 웹 URL입니다. 서버와 클라이언트 간에 공유되는 `client_secret`은 존재하지 않습니다. 핸들 또는 DID로 로그인할 때, 계정의 PDS 네트워크 위치를 발견하기 위해 atproto 전용 신원 확인 단계가 필요합니다.

OAuth 용어에서 atproto Personal Data Server(PDS)는 액세스 토큰을 사용하여 권한 있는 HTTP 요청이 이루어지는 "리소스 서버"입니다. 때때로 PDS는 OAuth 인증 흐름과 토큰 요청을 처리하는 "인증 서버" 역할도 수행하며, 다른 상황에서는 별도의 "입구(Entryway)" 서비스가 여러 PDS 인스턴스에 대한 인증 서버 역할을 합니다. 클라이언트는 PDS의 메타데이터 파일을 통해 인증 서버의 네트워크 위치를 자동으로 발견합니다.

DPoP(서버가 발급하는 nonce 포함)는 인증 토큰을 특정 클라이언트 소프트웨어 인스턴스(예: 단말기나 브라우저 세션)에 바인딩하기 위해 필수입니다. Pushed Authentication Requests(PAR)는 인증 요청 흐름을 간소화하기 위해 사용됩니다. "Confidential" 클라이언트는 JWT를 사용해 클라이언트 소프트웨어를 인증 서버에 인증하며, 이때 비밀 키로 서명합니다.

자동화된 클라이언트 등록은 atproto OAuth의 새로운 측면 중 하나입니다. 2024년 8월 기준으로, 클라이언트 메타데이터는 여전히 Internet Draft([`draft-parecki-oauth-client-id-metadata-document`](https://datatracker.ietf.org/doc/draft-parecki-oauth-client-id-metadata-document/)) 상태이며, 기존의 "Dynamic Client Registration" 표준([RFC 7591](https://datatracker.ietf.org/doc/html/rfc7591))과 혼동해서는 안 됩니다. 향후 다른 개방형 프로토콜에서도 유사한 자동 등록 흐름을 채택할 수 있기를 바라지만, 당분간 일반 OAuth 생태계에서는 지원이 미흡할 수 있습니다.

OAuth 2.0은 전통적으로 권한 부여(`authz`) 시스템이지 인증(`authn`) 시스템이 아니므로, "XYZ로 로그인/가입"과 같은 순수한 계정 인증 용도에 항상 적합한 솔루션은 아닙니다. OpenID Connect(OIDC)는 OAuth 2.0 위에 구축되어 보통 신원 인증을 위해 권장됩니다. 불행히도, 현재 버전의 OIDC는 atproto 신원을 안전하고 일반적인 방식으로 인증할 수 있는 기능을 제공하지 않습니다. atproto OAuth 프로파일은 인증 흐름 중 계정 인증을 위한 (의무적인) 메커니즘을 포함하며, atproto 신원 인증 용도로 사용할 수 있습니다.

## 클라이언트

이 섹션에서는 인증 서버가 강제하는 OAuth 클라이언트에 대한 요구사항을 설명합니다.

OAuth 클라이언트 소프트웨어는 전 세계적으로 유일한 `client_id`로 식별됩니다. 동일한 소프트웨어의 다른 변형(예: 브라우저 앱과 Android(모바일 OS) 버전)은 서로 다른 `client_id` 값을 가질 수 있습니다. [`draft-parecki-oauth-client-id-metadata-document`](https://datatracker.ietf.org/doc/draft-parecki-oauth-client-id-metadata-document) 명세 초안에 따라, `client_id`는 클라이언트 메타데이터 JSON 문서를 가져올 수 있는 완전한 웹 URL이어야 합니다. 예를 들어, `https://app.example.com/client-metadata.json`과 같이 사용합니다. 추가 설명은 아래를 참조하세요:

- URL은 W3C URL 명세를 따르는 올바른 형식이어야 합니다.
- 스킴은 반드시 `https://`여야 하며, 포트 번호가 포함되어서는 안 됩니다. 단, 개발 환경에서는 `http://localhost`에 대한 특별한 예외가 있으니 아래 세부사항을 참고하세요.
- 경로에 반드시 `client-metadata.json`이 포함될 필요는 없으나, 포함하는 것이 관례입니다.

atproto OAuth 프로파일과 다른 형태의 OAuth를 모두 지원하는 인증 서버는 `client_id` 값 충돌을 방지해야 합니다. 예를 들어, 자동 등록되지 않은 클라이언트의 `client_id` 값은 절대로 `https://` 또는 `http://` 접두어를 가져서는 안 됩니다.

### 클라이언트 유형

모든 atproto OAuth 클라이언트는 기본적인 표준과 요구사항을 충족해야 하지만, 클라이언트의 보안 특성(예: 세션 수명)에 따라 약간의 차이가 있을 수 있습니다.

OAuth 2.0 명세([RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749))에 따라, 모든 클라이언트는 두 가지 유형 중 하나입니다:

- **Confidential 클라이언트**는 암호화 서명 키를 사용해 인증 서버에 자신을 인증할 수 있는 클라이언트입니다. 이를 통해 리프레시 토큰을 특정 클라이언트에 바인딩할 수 있습니다. 이 클라이언트 인증 방식은 DPoP와는 별개이며, 클라이언트 인증 키는 모든 클라이언트 세션에서 공유됩니다(키 교체가 가능함). 일반적으로 이는 클라이언트가 관리하는 서버 측 웹 서비스가 키를 보유하는 경우입니다. 보안 사고 시 토큰을 취소할 수 있으므로, Confidential 클라이언트는 더 긴 세션 및 토큰 수명을 가질 수 있습니다.
- **Public 클라이언트**는 클라이언트 서명 키를 사용해 자신을 인증하지 않는 클라이언트입니다. 이는 클라이언트 소프트웨어가 전적으로 사용자 단말에서 실행되거나, 단순히 구현하지 않기로 선택한 경우에 해당합니다.

웹 서비스가 Public 클라이언트 역할을 하는 것은 허용되며, 반대로 모바일 앱이나 브라우저 앱이 토큰 중개 백엔드 서비스와 협력하여 Confidential 클라이언트를 구성할 수도 있습니다. 모바일 및 브라우저 앱은 "backend-for-frontend"(BFF) 아키텍처를 채택할 수 있습니다. 이 문서에서는 명확성을 위해 "public"과 "confidential"이라는 용어를 사용합니다.

클라이언트가 실행되는 환경은 인증 흐름 중 사용하는 리디렉션(콜백) URL 유형에 영향을 줍니다:

- **웹 클라이언트**: 웹 서비스와 브라우저 앱을 포함합니다. 리디렉션 URL은 브라우저에서 열리는 일반적인 웹 URL입니다.
- **네이티브 클라이언트**: 일부 모바일 및 데스크톱 네이티브 클라이언트를 포함합니다. 리디렉션 URL은 앱 자체를 여는 플랫폼 전용 콜백 스킴을 사용할 수 있습니다.

인증 서버는 `client_id`로 식별되는 "신뢰할 수 있는" 클라이언트 집합을 유지할 수 있습니다. 어떤 클라이언트라도 검증되지 않은 클라이언트 메타데이터를 사용하여 더 잘 알려진 앱이나 브랜드를 가장할 수 있으므로, 인증 서버는 기본적으로 이러한 메타데이터를 사용자에게 표시해서는 안 됩니다. 신뢰할 수 있는 클라이언트의 경우, 읽기 쉬운 이름(`client_name`), 프로젝트 URI(`client_uri`; `client_id`와 다른 도메인/출처일 수 있음) 및 로고(`logo_uri`)와 같은 추가 메타데이터를 표시할 수 있습니다. (자세한 내용은 "보안 고려사항" 섹션을 참조하세요.)

단순히 atproto 계정 인증(리소스 접근 권한 부여 없이)을 위해 atproto OAuth를 사용하는 클라이언트는 최소한의 스코프만 요청해야 합니다("Scopes" 섹션 참조). 그럼에도 불구하고 대부분의 인증 흐름은 구현해야 합니다. 특히, 토큰 응답의 `sub` 필드를 확인하여 계정 신원을 검증하는 것이 매우 중요합니다(이는 atproto 고유 사항입니다).

### 클라이언트 ID 메타데이터 문서

<Note>
클라이언트 ID 메타데이터 문서 명세([`draft-parecki-oauth-client-id-metadata-document`](https://datatracker.ietf.org/doc/draft-parecki-oauth-client-id-metadata-document/))는 여전히 초안 상태이며 시간이 지남에 따라 발전할 수 있습니다. 우리의 의도는 후속 초안 및 최종 표준과 정렬하면서도 기존 구현에 미치는 혼란을 최소화하는 것입니다.
</Note>

클라이언트는 공개 웹에 "클라이언트 메타데이터" JSON 파일을 게시해야 합니다. 이 파일은 인증 요청(PAR)이나 세션 수명 주기 중에 인증 서버에 의해 동적으로 가져와집니다. HTTP 응답 상태 코드는 반드시 200이어야 하며(다른 2xx나 리디렉션이 아님), JSON 객체 본문과 `Content-Type` 헤더는 `application/json`이어야 합니다.

인증 서버는 공개 웹에서 클라이언트 메타데이터 문서를 가져와야 합니다. 이때는 SSRF(서버 사이드 요청 위조) 공격을 방지하기 위해 강화된 HTTP 클라이언트를 사용해야 합니다("OAuth 보안 고려사항" 참조). 서버는 HTTP 캐싱 헤더를 고려하여 클라이언트 메타데이터 응답을 캐시할 수 있습니다(단, 제한 내에서). 최소 및 최대 캐시 TTL은 현재 명세에 없으나, 인증 토큰 요청 시 기한이 지난 Confidential 클라이언트 인증 키(`jwks` 또는 `jwks_uris`)로 인한 요청이 신속하게 거부되도록 적절하게 설정해야 합니다.

모든 클라이언트 유형에 대해 관련된 필드는 다음과 같습니다:

- `client_id` (문자열, 필수): `client_id`. 클라이언트 메타데이터 파일을 가져오기 위해 사용한 URL과 정확히 일치해야 합니다.
- `application_type` (문자열, 선택): `web` 또는 `native` 중 하나여야 하며, 명시되지 않은 경우 기본값은 `web`입니다. 이는 OpenID/OIDC에서 사용하는 필드이며, 인증 서버가 관련 "최신 모범 사례"를 적용하는 데 사용됩니다.
- `grant_types` (문자열 배열, 필수): `authorization_code`는 항상 포함되어야 합니다. `refresh_token`은 선택 사항이지만, 클라이언트가 토큰 재발급 요청을 할 경우 포함되어야 합니다.
- `scope` (문자열, 공백으로 구분된 부분 문자열, 필수): 클라이언트가 요청할 수 있는 모든 스코프 값을 여기에 선언합니다. `atproto` 스코프는 필수이며, 반드시 포함되어야 합니다. (자세한 내용은 "Scopes" 섹션 참조)
- `response_types` (문자열 배열, 필수): `code`가 포함되어야 합니다.
- `redirect_uris` (문자열 배열, 필수): 적어도 하나의 리디렉션 URI가 필요합니다. 리디렉션 URI에 관한 규칙은 인증 요청 필드 섹션에 나와 있습니다.
- `token_endpoint_auth_method` (문자열, 선택): Confidential 클라이언트는 이를 `private_key_jwt`로 설정해야 합니다.
- `token_endpoint_auth_signing_alg` (문자열, 선택): 여기서 `none`은 허용되지 않습니다. 현재 권장되고 가장 널리 지원되는 알고리즘은 `ES256`이지만, 향후 변경될 수 있습니다. 인증 서버는 이를 지원하는 알고리즘과 비교합니다.
- `dpop_bound_access_tokens` (불린, 필수): 모든 클라이언트에 대해 DPoP은 필수이므로, 반드시 `true`여야 합니다.
- `jwks` (JWK 배열을 포함하는 객체, 선택): Confidential 클라이언트는 JWT 클라이언트 인증에 사용할 공개 키를 최소 하나 이상 제공해야 합니다. 이 필드나 `jwks_uri` 필드 중 하나는 반드시 제공되어야 하며, 둘 다 동시에 제공해서는 안 됩니다.
- `jwks_uri` (문자열, 선택): JWKS JSON 객체가 있는 URL입니다. 위의 `jwks`와 관련된 세부사항을 참고하세요.

다음 필드들은 선택 사항이지만 권장됩니다:

- `client_name` (문자열, 선택): 클라이언트의 사람이 읽을 수 있는 이름
- `client_uri` (문자열, 선택): `client_id`와 혼동해서는 안 되며, 클라이언트의 홈페이지 URL입니다. 제공되는 경우, `client_uri`는 `client_id`와 동일한 호스트네임을 가져야 합니다.
- `logo_uri` (문자열, 선택): 클라이언트 로고에 대한 URL. 오직 `https:` URI만 허용됩니다.
- `tos_uri` (문자열, 선택): 클라이언트의 이용 약관(ToS)에 대한 사람이 읽을 수 있는 URL. 오직 `https:` URI만 허용됩니다.
- `policy_uri` (문자열, 선택): 클라이언트의 개인정보 처리방침에 대한 사람이 읽을 수 있는 URL. 오직 `https:` URI만 허용됩니다.

"OAuth 보안 고려사항" 섹션에서 언제 `client_name`, `client_uri` 및 `logo_uri`가 사용자에게 표시되거나 표시되지 않아야 하는지에 대한 내용을 참조하세요.

추가적인 선택적 클라이언트 메타데이터 필드는 [IANA](https://www.iana.org/assignments/oauth-parameters/oauth-parameters.xhtml#client-metadata)에 나와 있습니다. 이 필드들은 atproto OAuth 프로파일에서 직접 사용하지 않는 "Dynamic Client Registration" 표준(RFC 7591)과 공유됩니다.

### 로컬호스트 클라이언트 개발

개발 환경(인증 서버와 클라이언트)에서 작업할 때, 개발 중인 클라이언트 메타데이터를 공개 URL에 게시하여 인증 서버가 접근할 수 있게 하는 것이 어려울 수 있습니다. 이는 컨테이너화된 인증 서버와 로컬 DNS 환경에서도, 내부 IP 대역에 대한 SSRF 보호로 인해 발생할 수 있습니다.

개발 워크플로를 쉽게 하기 위해, origin이 `http://localhost`인 `client_id`에 대해 특별한 예외가 적용됩니다. 인증 서버는 이 예외를 지원하는 것이 권장되며(실제 운영 환경에서도 지원 가능), 단 이는 선택 사항입니다.

로컬호스트 `client_id`의 경우, 인증 서버는 스킴이 `http`이고, 호스트명이 정확히 `localhost`이며 포트가 지정되어 있지 않은지 확인해야 합니다. IP 주소(예: `127.0.0.1` 등)는 지원되지 않습니다. 경로는 빈 값이어야 합니다 (`/`).

인증 요청에서, `redirect_uri`는 제공된(또는 기본) URI 중 하나와 일치해야 합니다. 경로 구성 요소는 일치해야 하나 포트 번호는 일치하지 않아도 됩니다.

특정 메타데이터 필드는 `client_id` URL의 쿼리 파라미터를 통해 구성할 수 있습니다(적절히 URL 인코딩):

- `redirect_uri` (문자열, 선택, 여러 쿼리 파라미터 허용): 로컬 리디렉션/콜백 URL을 선언할 수 있으며, 경로 구성 요소는 매치되지만 포트 번호는 무시됩니다. 값이 제공되지 않으면 기본값은 `http://127.0.0.1/`와 `http://[::1]/`입니다.
- `scope` (공백으로 구분된 값이 포함된 문자열, 선택, 단일 쿼리 파라미터): 클라이언트가 요청할 수 있는 스코프 집합. 기본값은 `atproto`입니다.

나머지 가상 클라이언트 메타데이터 문서의 내용은 다음과 같습니다:

- `client_id` (문자열): 가상 문서를 생성하는 데 사용된 정확한 `client_id` (URL)
- `client_name` (문자열): 인증 서버에서 선택한 값(예: "Development client")
- `response_types` (문자열 배열): 반드시 `code`를 포함해야 합니다.
- `grant_types` (문자열 배열): `authorization_code`와 `refresh_token`을 포함합니다.
- `token_endpoint_auth_method`: `none`
- `application_type`: `native`
- `dpop_bound_access_tokens`: `true`

이는 Confidential 클라이언트가 아닌 Public 클라이언트로 작동함을 유의하세요.

## 신원 인증

앞서 언급한 바와 같이, OAuth 2.0은 전통적으로 권한 부여(`authz`)만을 제공하며, 신원 인증(`authn`)은 OpenID/OIDC와 같은 추가 표준에 의존합니다. atproto OAuth 프로파일은 계정 신원의 인증을 요구하며, 추가 리소스 접근 권한 부여 없이 단순한 신원 인증 사용 사례를 지원합니다.

atproto에서 계정 신원은 해당 계정의 영구적이며 전 세계적으로 유일한 공개 확인 식별자인 DID에 기반합니다. DID는 계정의 현재 PDS 호스트 위치를 나타내는 DID 문서로 해결됩니다. 해당 PDS(및 선택적 입구)는 인증 권한 기관이자 OAuth 인증 서버 역할을 수행합니다. 어떤 인증 서버와 통신할 때든, 클라이언트는 반드시 해당 인증 서버가 문제의 계정에 대해 권한이 있음을 독립적으로 확인해야 합니다. 즉, 계정을 DID로 해결하고 해당 인증 서버가 일치하는지 확인해야 합니다.

클라이언트는 다음 두 가지 방식 중 하나로 인증 흐름을 시작할 수 있습니다:

- 사용자가 제공한 공개 계정 식별자(핸들 또는 DID)로 시작
- 사용자가 제공한 서버 호스트네임(PDS 또는 입구)으로 시작하여, 해당 서버가 리소스 서버 및/또는 인증 서버 역할을 하는지 확인

계정 식별자로 시작할 경우, 클라이언트는 DID 문서로 계정을 해결해야 하며, 핸들인 경우 DID 문서가 해당 핸들을 주장하는지 양방향 검증하는 것이 필수입니다(atproto 핸들 명세 참조). 모든 핸들 해결 기법과 atproto에서 승인된 DID 메서드를 지원해야 모든 계정과의 상호 운용성이 보장됩니다.

일부 클라이언트 환경에서는 모든 신원 유형을 해결하기 어려울 수 있습니다. 예를 들어, 핸들 해결은 브라우저 앱에서 직접 지원되지 않는 DNS TXT 조회를 포함할 수 있습니다. 클라이언트 구현체는 DNS-over-HTTP와 같은 대체 기법을 사용하거나 신원 해결을 지원하는 웹 서비스를 활용할 수 있습니다.

인증 흐름은 보안상 매우 중요하므로, 신원 해결 결과의 캐싱 기간은 주의 깊게 설정되어야 합니다. 인증 흐름의 경우 캐시 수명은 10분 미만이어야 합니다.

해결된 DID는 전체 인증 세션에 바인딩되어 클라이언트 앱 코드 내에서 기본 계정 식별자로 사용되어야 합니다. (검증된) 핸들은 UI에 표시할 수 있으나, 시간이 지남에 따라 변경될 수 있으므로 주기적인 재검증이 필요합니다. 인증 요청의 `login_hint`로 계정 식별자를 전달할 경우, 클라이언트는 사용자가 제공한 원래의 계정 식별자(핸들이나 DID)를 사용하는 것이 권장됩니다.

인증 흐름의 마지막 단계에서, 클라이언트가 초기 토큰 요청을 할 때, 인증 서버는 JSON 응답 본문의 `sub` 필드에 계정 DID를 반환해야 합니다. 만약 인증 흐름이 계정 식별자로 시작되었다면, 클라이언트는 이 DID가 세션 초기에 바인딩된 예상 DID와 일치하는지 반드시 검증해야 합니다.

반대로 서버(호스트네임 또는 URL)로 시작한 경우, 클라이언트는 먼저 리소스 서버 메타데이터를 가져와(필요 시 인증 서버로 해결) 처리한 다음, 인증 서버 메타데이터를 가져옵니다. (자세한 내용은 "인증 서버" 섹션 참조) 두 경우 모두, 최종적으로 클라이언트는 식별된 인증 서버와 함께 작업하게 됩니다. 이때 인증 요청에는 `login_hint`나 계정 식별자가 세션에 바인딩되지 않으나, 인증 서버의 `issuer`가 세션에 바인딩됩니다.

인증 흐름이 진행되어 초기 토큰 요청이 성공하면, 클라이언트는 토큰 응답의 `sub` 필드에서 계정 식별자를 파싱합니다. 이 시점에서도 클라이언트는 해당 계정이 실제로 인증되었음을 신뢰할 수 없습니다. 클라이언트는 반드시 신원을 다시 해결(DID 문서 확인)하고, 선언된 PDS 호스트를 추출하며, 리소스 서버 메타데이터를 통해 해당 PDS가 세션에 바인딩된 인증 서버와 일치하는지 확인한 후, 인증 서버 메타데이터를 가져와 `issuer` 필드가 일치하는지 확인해야 합니다([`draft-ietf-oauth-v2-1` 섹션 7.3.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-11#section-7.13.1) 참고).

요약하면, atproto Identity Authentication만을 위한 클라이언트라 하더라도 전체 인증 흐름을 거치고, 토큰 응답의 `sub` 필드에 있는 계정 식별자(DID)가 인증 서버의 호스트명/출처(`issuer`)와 일치하는지 반드시 확인해야 합니다.

## 권한 범위(Scopes)

OAuth 스코프를 사용하면 클라이언트가 부여받는 리소스와 작업에 대해 보다 세분화된 제어가 가능합니다.

특별한 `atproto` 스코프는 모든 atproto OAuth 세션에서 필수입니다. 이 스코프의 의미는 `openid` 스코프와 유사하며, 클라이언트가 atproto OAuth 프로파일을 사용하고 있으며 이 명세의 모든 요구사항을 준수함을 확인합니다. 이 스코프가 포함되지 않으면 atproto 전용 PDS 리소스에 대한 접근 권한이 부여되지 않습니다.

인증 서버는 클라이언트가 `atproto` 스코프를 포함하지 않는 경우, 다른 OAuth 프로파일도 지원할 수 있습니다. 예를 들어, 인증 서버가 atproto PDS/입구로 기능하면서 다른 프로토콜/표준도 동시에 지원할 수 있습니다.

atproto OAuth 프로파일을 사용함으로써(즉, `atproto` 스코프를 포함함으로써) 인증 서버는 토큰 요청 시 계정 식별자로 atproto 계정 DID를 반환합니다. 인증 서버는 메타데이터 문서의 `scopes_supported`에 반드시 `atproto`를 포함해야 하므로, 클라이언트는 해당 서버가 atproto OAuth 프로파일을 지원함을 알 수 있습니다. 클라이언트는 계정 인증 전용(예: "atproto로 로그인" 사용 사례)의 경우 오직 `atproto` 스코프만 요청할 수 있습니다. OpenID와 달리, atproto 프로파일 메타데이터는 일반적으로 공개되므로 프로필 메타데이터를 가져오기 위한 추가 스코프가 필요하지 않습니다.

OAuth 2.0 명세에서는, 클라이언트가 요청한 스코프와 다른 스코프가 부여될 경우에만 토큰 응답에 부여된 스코프를 반환하도록 요구합니다. 하지만 atproto OAuth 프로파일에서는, 인증 서버가 토큰 응답에 항상 부여된 스코프를 반환해야 합니다. 클라이언트는 응답에 `scope` 필드가 없거나, `scope` 필드에 `atproto`가 포함되어 있지 않으면 해당 세션을 거부해야 합니다.

목표는 Lexicon 네임스페이스(NSID)에 기반한 유연한 스코프 지원으로, 클라이언트가 필요한 특정 콘텐츠와 API 엔드포인트에 대해서만 접근 권한을 부여받을 수 있도록 하는 것입니다. 해당 스코프 시스템의 설계가 준비될 때까지, atproto OAuth 프로파일은 기존의 "세션 토큰" 인증 시스템 하에서 부여된 권한과 일치하는 두 가지 과도기 스코프를 정의합니다:

- `transition:generic`: 이전의 "앱 비밀번호" 권한 수준에 해당하는 광범위한 PDS 계정 권한.
    - 모든 저장소 레코드 타입에 대한 생성/수정/삭제 권한
    - 블롭(미디어 파일) 업로드
    - 모든 개인 설정의 읽기 및 쓰기
    - 대부분의 Lexicon 엔드포인트에 대한 API 접근 및 서비스 프록시 기능(서비스 제공자 DID에 의해 식별)
    - 클라이언트가 접근 권한이 있는 특정 API 엔드포인트에 대해 서비스 인증 토큰을 생성할 수 있음
    - 계정 관리 작업(핸들 변경, 이메일 변경, 계정 삭제/비활성화, 계정 마이그레이션) 불가
    - DM(다이렉트 메시지) 접근 불가(`chat.bsky.*` Lexicon 제외)
- `transition:chat.bsky`: "앱 비밀번호"에 DM 접근 토글을 추가한 것과 동일.
    - `chat.bsky` Lexicon에 대한 API 엔드포인트 및 서비스 프록시 기능
    - `chat.bsky` Lexicon에 대해 서비스 인증 토큰 생성 가능
    - 이 스코프는 반드시 `transition:generic` 스코프에 의존하며, 단독으로 동작하지 않습니다.

## 인증 요청

이 섹션에서는 atproto OAuth 프로파일에 대한 인증 요청에 관한 표준 및 요구사항을 상세히 설명합니다.

모든 클라이언트와 인증 서버는 PKCE와 PAR를 의무적으로 사용해야 합니다. Confidential 클라이언트는 JWT 클라이언트 어서션을 사용해 자신을 인증합니다.

### 요청 필드

atproto OAuth 프로파일에 해당하는 인증 요청과 관련된 주요 필드 요약은 다음과 같습니다:

- `client_id` (문자열, 필수): 클라이언트 소프트웨어를 식별합니다. (위 "클라이언트" 섹션 참조)
- `response_type` (문자열, 필수): 반드시 `code`여야 합니다.
- `code_challenge` (문자열, 필수): PKCE 챌린지 값. (아래 "PKCE" 섹션 참조)
- `code_challenge_method` (문자열, 필수): 사용된 코드 챌린지 메서드 예: `S256`. (아래 "PKCE" 섹션 참조)
- `state` (문자열, 필수): 인증 요청과 응답을 검증하기 위해 사용되는 랜덤 토큰.
- `redirect_uri` (문자열, 필수): 클라이언트 메타데이터에 선언된 URI 중 하나와 일치해야 하며, `application_type`에 맞는 형식이어야 합니다.
- `scope` (공백으로 구분된 문자열, 필수): 클라이언트 메타데이터에 선언된 스코프의 부분 집합이어야 하며, 반드시 `atproto`를 포함해야 합니다. (자세한 내용은 "Scopes" 섹션 참조)
- `client_assertion_type` (문자열, 선택): Confidential 클라이언트가 클라이언트 인증 메커니즘을 설명하기 위해 사용.
- `client_assertion` (문자열, 선택): Confidential 클라이언트의 경우 클라이언트 인증을 위해 사용됨.
- `login_hint` (문자열, 선택): 로그인 시 사용할 계정 식별자. ("인증 인터페이스" 섹션 참조)

`client_secret`은 다른 OAuth 프로파일에서 사용되지만 포함되어서는 안 됩니다.

클라이언트 인증 요청에서의 `state` 파라미터는 의무이며, 무작위로 생성된 토큰을 사용해 장치, 계정, 세션 간에 중복이나 재사용이 없어야 합니다. 인증 서버는 중복된 state 파라미터를 거부해야 하나, 계정이나 세션 간의 state 값을 추적할 의무는 없습니다. 이 `state` 파라미터는 나중에 `issuer`를 검증하는 데 사용되므로, 신뢰할 수 없는 당사자가 위조하거나 추측할 수 없어야 합니다.

웹 클라이언트의 경우, `redirect_uri`는 브라우저에서 인증 흐름 종료 후 사용자를 클라이언트로 되돌려 보내기 위한 HTTPS URL입니다. 이 URL은 포트 번호를 포함할 수 있으나, 기본 포트 번호는 포함하지 않아야 합니다. `redirect_uri`는 클라이언트 메타데이터에 선언된 URI 중 하나와 반드시 일치해야 하며, 인증 서버는 이를 검증해야 합니다. URL의 출처(origin)는 `client_id`와 일치해야 합니다.

로컬호스트 개발 워크플로를 위해, "로컬호스트 클라이언트 개발" 섹션에 설명된 규칙에 따라 `http://127.0.0.1` 또는 `http://[::1]` URL 사용에 대한 예외가 존재합니다. 이 클라이언트는 웹 URL을 사용하나, 생성된 클라이언트 메타데이터에서 `application_type`은 `native`로 설정됩니다.

네이티브 클라이언트의 경우, `redirect_uri`는 운영체제에서 앱으로 사용자를 리디렉션할 수 있도록 커스텀 URI 스킴을 사용할 수 있습니다. 커스텀 스킴은 리버스 도메인 순서를 사용하여 `client_id`의 호스트명과 일치해야 합니다. 스킴은 콜론(`:`) 뒤에 단일 슬래시(`/`)와 URI 경로 구성 요소가 따라와야 합니다. 예를 들어, `client_id`가 [`https://app.example.com/client-metadata.json`](https://app.example.com/client-metadata.json)인 앱은 `com.example.app:/callback`과 같은 `redirect_uri`를 가질 수 있습니다.

네이티브 클라이언트는 HTTPS URL을 사용할 수도 있으며, 이 경우 URL의 출처(origin)는 `client_id`와 동일해야 합니다. (예: Apple Universal Links)

클라이언트는 추가적인 선택적 인증 요청 파라미터를 포함할 수 있으며, 서버는 이를 처리할 수 있으나 필수 사항은 아닙니다. 추가 파라미터에 대해서는 다른 OAuth 표준 및 [IANA OAuth 파라미터 레지스트리](https://www.iana.org/assignments/oauth-parameters/oauth-parameters.xhtml)를 참고하세요.

### Proof Key for Code Exchange (PKCE)

PKCE는 모든 인증 요청에 대해 필수입니다. 클라이언트는 매 인증 요청마다 새로운 고유의 무작위 챌린지를 생성해야 합니다. 인증 서버는 (최소 24시간 이내) 세션 간에 `code_challenge` 값의 재사용을 방지해야 합니다.

모든 클라이언트와 인증 서버는 반드시 `S256` 챌린지 메서드를 지원해야 하며, 자세한 내용은 [RFC 7636](https://datatracker.ietf.org/doc/html/rfc7636)를 참조하세요. `plain` 메서드는 허용되지 않습니다. 클라이언트와 서버가 지원할 경우 추가 메서드를 지원할 수도 있습니다.

인증 서버는 `code` 값의 재사용을 거부하고, 이전에 사용된 `code` 값과 관련된 모든 세션과 토큰을 폐기해야 합니다.

### Pushed Authorization Requests (PAR)

인증 서버는 PAR를 반드시 지원해야 하며, 모든 클라이언트는 인증 요청 시 PAR를 사용해야 합니다.

인증 서버는 서버 메타데이터 문서에서 `require_pushed_authorization_requests`를 `true`로 설정하고, `pushed_authorization_request_endpoint`에 유효한 URL을 포함해야 합니다. (자세한 내용은 [RFC 9207](https://datatracker.ietf.org/doc/html/rfc9207) 참고)

클라이언트는 `pushed_authorization_request_endpoint` URL로 HTTPS POST 요청을 하며, 요청 파라미터는 form-encoded request body에 포함합니다. JSON 응답 객체에서 `request_uri`(리디렉션 URI와는 구분됨)를 받게 됩니다. 이후 사용자를 인증 서버의 인증 엔드포인트로 리디렉션할 때, 이전에 전송한 대부분의 요청 파라미터는 생략하고 대신 이 `request_uri`와 `client_id`를 쿼리 파라미터로 포함합니다.

<Note>
PAR는 비교적 새로운 표준으로 지원이 제한적일 수 있으며, 클라이언트에 PAR 사용 요구 사항이 너무 부담스러운 경우 완화될 수 있습니다. 그런 경우, 인증 서버는 PAR와 비PAR 요청을 모두 지원해야 하며, 클라이언트에 대해 PAR은 선택 사항이 됩니다.
</Note>

### Confidential 클라이언트 인증

Confidential 클라이언트는 인증 요청 시 JWT 클라이언트 어서션을 사용해 자신을 인증해야 합니다. 인증 서버는 Confidential 클라이언트에 대해 더 긴 토큰/세션 수명을 부여할 수 있습니다. (자세한 내용은 "토큰 및 세션 수명" 섹션 참조)

사용할 클라이언트 어서션 타입은 `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`이며, 이는 "JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants"([RFC 7523](https://datatracker.ietf.org/doc/html/rfc7523))에 설명되어 있습니다. 현재 모든 클라이언트와 인증 서버는 `ES256` 암호화 시스템을 지원해야 합니다. 권장 암호화 시스템/알고리즘은 향후 발전할 수 있습니다.

추가 요구사항:

- Confidential 클라이언트는 클라이언트 메타데이터에 JWT 클라이언트 인증에 사용할 공개 키(JWK)를 하나 이상 게시해야 합니다. 이는 직접 JSON 형태의 `jwks` 필드이거나, 별도의 JWKS JSON 객체를 가리키는 `jwks_uri`를 통해 제공되어야 합니다. `jwks_uri`는 반드시 `https://` 스킴을 가진 완전한 URL이어야 합니다.
- Confidential 클라이언트는 주기적으로 클라이언트 키를 교체해야 하며, 새 키를 JWKS 집합에 추가한 후 새로운 세션에 사용하고, 더 이상 활성 인증 세션에 사용되지 않는 키는 제거해야 합니다.
- Confidential 클라이언트는 클라이언트 메타데이터 문서에 `token_endpoint_auth_method`를 반드시 `private_key_jwt`로 포함해야 합니다.
- 유출 또는 침해된 경우, Confidential 클라이언트는 즉시 클라이언트 메타데이터에서 인증 키를 제거해야 합니다.
- 인증 서버는 Confidential 클라이언트의 활성 인증 세션을 해당 세션 시작 시 사용한 클라이언트 인증 키에 바인딩해야 합니다. 만약 클라이언트 인증 키가 클라이언트 메타데이터에서 사라지면, 서버는 해당 세션을 폐기하고 이후 토큰 재발급 요청을 거부해야 합니다. 이는 인증 서버가 주기적으로 클라이언트 메타데이터를 다시 가져와야 함을 의미합니다.

## 토큰 및 세션 수명

액세스 토큰은 계정의 PDS("리소스 서버")에 대해 클라이언트 요청을 권한 부여하기 위해 사용됩니다. 클라이언트 입장에서는 토큰이 불투명하지만, 종종 만료 시간이 포함된 서명된 JWT입니다. PDS 구현에 따라 개별 액세스 토큰을 침해 시 폐기할 수 없을 수도 있으므로, 상대적으로 짧은 수명을 가져야 합니다.

리프레시 토큰은 인증 서버(또는 입구)에 새로운 토큰(액세스 토큰 및 리프레시 토큰)을 요청하는 데 사용됩니다. 클라이언트 입장에서는 리프레시 토큰 역시 불투명합니다. 인증 세션은 폐기 가능하며, 리프레시 토큰 또한 단일 사용 형태(요청 시 새로운 리프레시 토큰으로 대체됨)입니다. 이로 인해 클라이언트 구현체는 동시 토큰 재발급 요청을 방지하기 위한 락킹 메커니즘이 필요할 수 있습니다.

리프레시 토큰을 요청하기 위해, 클라이언트는 클라이언트 메타데이터에 `refresh_token` 그랜트 타입을 선언해야 합니다.

토큰은 항상 고유 세션 DPoP 키에 바인딩됩니다. 토큰은 클라이언트 단말 간에 공유되거나 재사용되어서는 안 되며, 클라이언트 소프트웨어(`client_id`)에도 고유하게 바인딩되어야 합니다. 전체 세션은 액세스 토큰과 리프레시 토큰이 더 이상 사용되지 않을 때 종료됩니다.

세션, 액세스 토큰 및 리프레시 토큰의 구체적인 수명은 인증 서버 구현체에 따라 달라지며, 클라이언트 유형 및 평판에 따른 보안 평가에 의존할 수 있습니다.

일부 가이드라인 및 요구사항:

- 액세스 토큰 수명은 모든 경우 30분 미만이어야 합니다. 만약 서버가 개별 액세스 토큰을 폐기할 수 없다면 최대 15분, 권장 수명은 5분입니다.
- 신뢰할 수 없는 Public 클라이언트의 경우, 전체 세션 수명은 7일로 제한되고 개별 리프레시 토큰의 수명은 24시간으로 제한됩니다.
- Confidential 클라이언트의 경우, 전체 세션 수명은 무제한일 수 있으며, 개별 리프레시 토큰은 180일로 제한됩니다.
- Confidential 클라이언트는 초기 인증 요청 시 사용한 것과 동일한 클라이언트 인증 키와 어서션 방법을 리프레시 토큰 요청 시에도 사용해야 합니다.

## DPoP(서명된 증거) 증명

atproto OAuth 프로파일에서는 모든 클라이언트가 인증 서버 및 리소스 서버에 인증 토큰 요청 시 DPoP을 반드시 사용하도록 요구합니다. 자세한 내용은 [RFC 9449](https://datatracker.ietf.org/doc/html/rfc9449)를 참조하세요.

클라이언트는 최초 인증 요청(PAR)에서 DPoP을 시작해야 합니다.

서버가 발급하는 DPoP nonce는 필수입니다. 리소스 서버와 인증 서버는 동일 서버일 경우 동일 nonce를 공유하거나, 별도의 nonce를 사용할 수 있습니다. 클라이언트는 계정 세션 및 서버별로 DPoP nonce를 추적해야 합니다. 서버는 nonce의 수명을 최대 5분으로 제한하며 주기적으로 갱신해야 합니다. 서버는 모든 클라이언트 세션 및 다수의 요청에 대해 동일한 nonce를 사용할 수 있으며, 클라이언트가 여러 동시 요청을 보낼 경우를 위해 최근의 만료된 nonce도 허용해야 합니다. 클라이언트는 DPoP이 포함된 요청에 대해 `DPoP-Nonce` 헤더(대소문자 구분 없음)가 누락된 응답을 받으면 해당 응답을 거부해야 하며, HTTP 400 오류 형태의 예상치 못한 nonce 업데이트에도 재시도해야 합니다.

클라이언트는 모든 요청마다 고유의 DPoP 토큰(JWT)을 생성 및 서명해야 합니다. 각 DPoP 요청 JWT는 고유한(무작위 생성된) `jti` nonce를 포함해야 합니다. 서버는 `jti` nonce 재사용을 방지하기 위해 이를 추적해야 하며, 서버가 관리하는 DPoP nonce 기간 내에 클라이언트가 생성한 `jti` nonce 기록의 범위를 제한할 수 있습니다.

모든 클라이언트와 서버는 DPoP JWT 서명을 위해 반드시 `ES256`(NIST "P-256") 암호화 알고리즘을 지원해야 합니다. 권장 알고리즘 집합은 향후 발전할 수 있으며, 클라이언트와 서버는 추가 알고리즘을 구현하고 메타데이터 문서에 이를 명시할 수 있습니다.

## 인증 서버

브라우저 앱 지원을 위해, 인증 서버는 서버 메타데이터, 인증 요청(PAR), 토큰 요청 등 관련 엔드포인트에서 HTTP CORS 요청/헤더를 반드시 지원해야 합니다.

### 서버 메타데이터

리소스 서버(PDS 인스턴스)와 인증 서버(PDS 또는 입구)는 모두 HTTPS의 well-known 엔드포인트에 메타데이터 파일을 게시해야 합니다.

리소스 서버(PDS) 메타데이터는 "OAuth 2.0 Protected Resource Metadata"([`draft-ietf-oauth-resource-metadata`](https://datatracker.ietf.org/doc/draft-ietf-oauth-resource-metadata/)) 초안 명세를 준수해야 합니다. 주요 요구사항은 다음과 같습니다:

- URL 경로는 `/.well-known/oauth-protected-resource`
- HTTP 응답은 200이어야 하며(2xx나 리디렉션 아님), 유효한 JSON 객체와 `Content-Type`은 `application/json`이어야 합니다.
- 단 하나의 요소를 가지는 문자열 배열 `authorization_servers`를 포함해야 하며, 이는 완전한 URL입니다.

인증 서버 URL은 리소스 서버(PDS)와 동일한 출처일 수 있으며, 또는 별도의 서버(예: 입구)를 가리킬 수 있습니다. 이 URL은 단순 출처 URL이어야 하며: `https` 스킴, 사용자 인증 정보(예: user:password) 없음, 경로 없음, 쿼리 문자열이나 프래그먼트 없음. 포트 번호는 허용되나, 기본 포트(HTTPS의 경우 443)는 포함하면 안 됩니다.

인증 서버는 또한 "OAuth 2.0 Authorization Server Metadata"([RFC 8414](https://datatracker.ietf.org/doc/html/rfc8414)) 표준을 준수하여 메타데이터를 게시합니다. 주요 요구사항은 다음과 같습니다:

- URL 경로는 `/.well-known/oauth-authorization-server`
- HTTP 응답은 200이어야 하며(2xx나 리디렉션 아님), 유효한 JSON 객체와 `Content-Type`은 `application/json`이어야 합니다.
- `issuer` (문자열, 필수): 인증 서버의 "출처" URL. 유효한 URL이어야 하며 `https` 스킴을 사용해야 합니다. 포트 번호가 포함될 수 있으나(출처와 일치하는 경우), 기본 포트(HTTPS의 경우 443)는 지정하면 안 됩니다. 경로 세그먼트가 없어야 하며, 메타데이터 문서를 가져온 URL의 출처와 일치해야 합니다.
- `authorization_endpoint` (문자열, 필수): 인증 리디렉션을 위한 엔드포인트 URL.
- `token_endpoint` (문자열, 필수): 토큰 요청을 위한 엔드포인트 URL.
- `response_types_supported` (문자열 배열, 필수): 반드시 `code`를 포함해야 합니다.
- `grant_types_supported` (문자열 배열, 필수): 반드시 `authorization_code`와 `refresh_token`(리프레시 토큰 지원 포함)을 포함해야 합니다.
- `code_challenge_methods_supported` (문자열 배열, 필수): 반드시 `S256`을 포함해야 합니다. (아래 "PKCE" 섹션 참조)
- `token_endpoint_auth_methods_supported` (문자열 배열, 필수): Public 클라이언트를 위한 `none`과 Confidential 클라이언트를 위한 `private_key_jwt`를 모두 포함해야 합니다.
- `token_endpoint_auth_signing_alg_values_supported` (문자열 배열, 필수): `none`은 포함되어서는 안 되며, 현재는 `ES256`을 포함해야 합니다. (암호화 알고리즘 집합은 향후 발전할 수 있음)
- `scopes_supported` (문자열 배열, 필수): 반드시 `atproto`를 포함해야 하며, 과도기 권한 부여를 지원할 경우 해당 스코프도 포함해야 합니다. (자세한 내용은 "Scopes" 섹션 참조)
- `authorization_response_iss_parameter_supported` (불린, 선택): 반드시 `true`여야 합니다.
- `require_pushed_authorization_requests` (불린): 반드시 `true`여야 하며, (자세한 내용은 "PAR" 섹션 참조)
- `pushed_authorization_request_endpoint` (문자열, 필수): PAR 엔드포인트 URL이어야 합니다.
- `dpop_signing_alg_values_supported` (문자열 배열, 필수): 현재는 반드시 `ES256`을 포함해야 합니다. (자세한 내용은 "DPoP" 섹션 참조)
- `require_request_uri_registration` (불린, 선택): 기본값은 `true`이며, 명시적으로 설정할 필요는 없으나 `false`가 되어서는 안 됩니다.
- `client_id_metadata_document_supported` (불린, 필수): 반드시 `true`여야 합니다. (자세한 내용은 "클라이언트 ID 메타데이터" 섹션 참조)

`issuer`(출처)는 인증 서버의 전체 식별자입니다.

### 인증 인터페이스

인증 서버(PDS/입구)는 사용자가 인증 서버와 상호작용하여 로그인하고, 클라이언트의 인증 요청을 승인(또는 거부)하며, 활성 세션을 관리할 수 있는 웹 인터페이스(인증 인터페이스)를 구현해야 합니다.

서버 구현체는 사용자 인증 및 계정 복구를 위해 자체적인 기술(예: 안전한 쿠키, 이메일, 2단계 인증, 패스키, 외부 신원 제공자(OIDC 포함) 등)을 선택할 수 있습니다. 서버는 여러 동시 인증 세션을 지원할 수도 있습니다.

클라이언트가 인증 서버의 `authorization_endpoint` URL로 리디렉션할 경우, 서버는 먼저 사용자를 인증해야 합니다. 활성 인증 세션이 없으면 사용자는 로그인하라는 메시지를 받게 됩니다. 인증 요청에 `login_hint`가 제공되었다면, 이를 로그인 폼에 미리 채워 넣을 수 있습니다. 활성 인증 세션이 여러 개 존재하는 경우, 사용자는 목록에서 선택하거나 `login_hint`를 통해 자동 선택될 수 있습니다. 단일 활성 세션이 존재한다면, 인터페이스는 다른 계정으로 로그인할 옵션을 제공하며 승인 화면으로 넘어갈 수 있습니다. `login_hint`가 제공된 경우, 인증 서버는 사용자가 해당 계정으로만 인증하도록 허용해야 합니다. 그렇지 않으면 클라이언트가 계정 신원(`sub` 필드)을 검증할 때 인증 흐름이 실패합니다.

인증 승인 프롬프트는 클라이언트 앱을 식별하고 요청된 권한 범위를 설명해야 합니다.

표시할 클라이언트 메타데이터의 양은 해당 클라이언트가 인증 서버에 의해 "신뢰받는"지 여부에 따라 달라질 수 있습니다. (자세한 내용은 "클라이언트" 및 "보안 고려사항" 섹션 참조) 기본적으로 전체 `client_id` URL이 표시되어야 합니다.

스코프에 관한 설명은 "Scopes" 섹션을 참조하세요.

만약 Confidential 클라이언트이고 사용자가 과거에 동일한 스코프에 대해 이미 승인을 했다면, 인증 서버는 "무음 로그인(silent sign-in)"을 통해 인증 요청을 자동 승인할 수 있습니다. 인증 서버는 자체 정책에 따라 이를 처리할 수 있으며, 사용자가 명시적으로 설정해야 하거나 클라이언트가 "신뢰할 수 있는" 클라이언트여야 할 수 있습니다.

인증 서버는 별도의 웹 인터페이스를 통해 인증된 사용자가 활성 OAuth 세션을 확인하고 해당 세션을 삭제할 수 있도록 구현해야 합니다.

## 인증 흐름 요약

아래는 atproto OAuth 인증 흐름의 개략적인 설명입니다(사용자가 이미 atproto 계정을 보유하고 있다고 가정).

1. 클라이언트는 사용자에게 계정 식별자(핸들 또는 DID) 또는 PDS/입구 호스트네임을 요청합니다. ("신원 인증" 섹션 참조)
2. 계정 식별자인 경우, 클라이언트는 DID 문서를 통해 계정을 해결하고, 해당 DID 문서에서 선언된 PDS URL을 추출한 후, 리소스 서버 및 인증 서버 위치를 가져옵니다. 서버 호스트네임으로 시작하는 경우, 클라이언트는 해당 호스트네임을 통해 인증 서버를 해결합니다. 두 경우 모두, 인증 서버 메타데이터를 가져와 atproto OAuth의 요구사항에 부합하는지 검증합니다("인증 서버" 섹션 참조).
3. 클라이언트는 HTTPS POST 요청을 통해 Pushed Authorization Request(PAR)를 보냅니다. (자세한 내용은 "인증 요청" 섹션 참조) 주요 사항은 다음과 같습니다:
   - 무작위 생성된 `state` 토큰이 필수이며, 이는 후속 응답 콜백 시 세션 참조에 사용됩니다.
   - PKCE가 필수이므로, 비밀 값이 생성되어 저장되고 파생된 챌린지가 요청에 포함됩니다.
   - 요청 시 `scope` 값이 포함되며, 반드시 `atproto`를 포함해야 합니다.
   - Confidential 클라이언트의 경우, `client_assertion`을 포함해 `jwt-bearer` 타입으로 클라이언트 인증을 수행합니다.
   - 클라이언트는 사용자/단말/세션마다 새로운 DPoP 키를 생성하여 PAR 요청부터 사용합니다.
   - 계정 식별자로 시작한 경우, 클라이언트는 해당 초기 식별자를 `login_hint` 필드를 통해 전달해야 합니다.
   - atproto는 PAR를 사용하므로, 요청은 반드시 HTTPS POST 방식으로 인증 서버에 전송됩니다.
4. 인증 서버는 PAR 요청을 수신하고, `client_id` URL을 통해 클라이언트 메타데이터 문서를 가져옵니다. 서버는 요청 및 클라이언트 메타데이터를 검증한 후, 세션 정보를 저장하며 DPoP 키를 세션에 바인딩합니다. 서버는 DPoP nonce를 HTTP 헤더에 포함하여 `request_uri` 토큰을 클라이언트에 반환합니다.
5. 클라이언트는 `request_uri`를 받고 사용자를 리디렉션할 준비를 합니다. 이 시점에서 클라이언트는 보통 세션 정보를 안전한 저장소(예: 웹 서비스 백엔드의 데이터베이스, 브라우저의 IndexedDB 등)에 보관해야 합니다. 이후 클라이언트는 `request_uri`와 함께 브라우저를 통해 인증 서버의 인증 엔드포인트로 사용자를 리디렉션합니다. 단, 클라이언트는 세션 데이터를 `state` 파라미터에 직접 저장해서는 안 됩니다.
6. 인증 서버는 `request_uri`를 기반으로 이전 인증 요청 파라미터를 조회한 후, 사용자를 인증합니다(로그인 또는 계정 선택). 사용자에게 승인(또는 거부) 프롬프트가 표시됩니다. 사용자는 요청된 세분화 스코프를 조정할 수 있으며, 승인 여부를 결정합니다. 인증 서버는 사용자를 `redirect_uri`로 리디렉션하며, 이는 웹 콜백 URL 또는 네이티브 앱 URI일 수 있습니다.
7. 클라이언트는 URL 쿼리 파라미터(`state`와 `iss`)를 통해 세션 정보를 조회 및 검증합니다. 이후 `code` 파라미터를 사용해 인증 서버의 토큰 엔드포인트에 초기 토큰 요청을 보냅니다. 클라이언트는 이전에 저장한 값을 `code_verifier` 필드에 포함하여 PKCE 플로우를 완료합니다. Confidential 클라이언트는 토큰 요청 시 클라이언트 어서션 JWT를 포함해야 합니다("Confidential 클라이언트 인증" 섹션 참조). 인증 서버는 요청을 검증하고, 토큰과 함께 계정 식별자(DID)를 나타내는 `sub` 필드 및 발급된 액세스 토큰에 해당하는 `scope`를 반환합니다.
8. 이 시점에서, 클라이언트는 반드시 토큰 응답의 `sub` 필드에 있는 계정 식별자가 인증 서버의 `issuer`(쿼리 파라미터 `iss`에 포함)와 일치하는지 검증해야 합니다. (자세한 내용은 "신원 인증" 섹션 참조) 만약 응답에 `atproto` 스코프가 포함되지 않았다면, 클라이언트는 해당 세션을 거부해야 합니다.
9. 인증 전용 클라이언트는 여기서 인증 흐름을 종료할 수 있습니다.
10. 액세스 토큰을 사용하여, 클라이언트는 PDS("리소스 서버")에 대해 권한 있는 요청을 수행할 수 있습니다. 이때 반드시 DPoP과 액세스 토큰을 함께 사용해야 합니다. 토큰(액세스 및 리프레시 토큰)은 주기적으로 인증 서버의 토큰 엔드포인트에 재요청해야 하며, 이 과정 또한 DPoP을 요구합니다("토큰 및 세션 수명" 섹션 참조).

## 보안 고려사항

외부 당사자가 제공한 HTTP URL을 클라이언트와 공급자(서버)가 가져올 때 여러 보안 이슈가 발생할 수 있습니다. 특히, 악의적으로 조작된 URL로 인해 내부 IP 주소(또는 프라이빗 네트워크)에 접근하는 SSRF(서버 사이드 요청 위조) 공격이 대표적입니다. 또한, 악의적인 서버로부터의 대용량 응답, TCP 슬로우로리스(slow-loris) 공격 등 서비스 거부(DoS) 공격의 위험도 있습니다. 이러한 공격을 완화하기 위해 "강화된" HTTP 클라이언트 구현/설정을 사용하는 것을 강력히 권장합니다.

어떤 당사자라도 언제든지 임의의 내용으로 클라이언트 및 클라이언트 메타데이터 파일을 생성할 수 있습니다. 특히, `client_id`의 호스트네임은 전체 클라이언트를 대표한다고 전적으로 신뢰할 수 없습니다. 신뢰할 수 없는 사용자가 임의의 URL에 클라이언트 메타데이터 파일을 업로드할 수 있기 때문입니다. 특히, `client_uri`, `client_name` 및 `logo_uri` 필드는 검증되지 않으므로 악의적인 행위자가 합법적인 클라이언트를 가장할 수 있습니다. 인증 서버는 기본적으로 이러한 필드를 미확인 클라이언트에 대해 사용자에게 표시하지 않도록 강력히 권장합니다. 서비스 운영자는 신뢰할 수 있는 `client_id` 목록을 유지하고, 해당 앱에 대해서만 추가 메타데이터를 표시해야 합니다.

## 향후 변경 가능 사항

- 클라이언트 메타데이터 요청(인증 서버의 경우)이 일시적인 네트워크 장애, 서버 유지보수 등으로 실패할 수 있습니다. 이 경우 활성 클라이언트 세션을 즉시 폐기하는 것은 취약할 수 있으므로, 명시적인 유예 기간이 필요할 수 있습니다.
- 리소스 서버 메타데이터가 단일 인증 서버 URL만 참조하도록 요구하는 부분은 완화될 수 있습니다.
- 세션 및 토큰 수명에 관한 세부 사항은 추가 보안 검토에 따라 변경될 수 있습니다.
