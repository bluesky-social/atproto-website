export const metadata = {
  title: 'Timestamp Identifiers (TIDs)',
  description: '수정 및 레코드를 위한 간결한 타임스탬프 기반 식별자입니다.',
}

# Timestamp Identifiers (TIDs)

TID("Timestamp Identifiers")는 정수 타임스탬프를 기반으로 한 간결한 문자열 식별자입니다.  
이 식별자는 정렬이 가능하며 웹 URL에 적합하고, 네트워크 시스템 내에서 "논리적 시계" 역할을 수행할 수 있습니다.  
현재 TID는 atproto에서 레코드 키와 저장소 커밋의 "리비전" 번호로 사용되고 있습니다.

**참고:** TID는 ["스노우플레이크 식별자"](https://en.wikipedia.org/wiki/Snowflake_ID)와 유사한 점이 있습니다.  
그러나 atproto의 탈중앙화 맥락에서는 TID의 전역적 유일성이 보장되지 않으며, 악의적인 저장소 관리자가 알려진 TID를 재사용하는 레코드를 쉽게 생성할 수 있습니다.

## TID 구조

TID의 높은 수준의 의미는 다음과 같습니다:

- 64비트 정수
- 빅 엔디언 바이트 순서
- `base32-sortable` 인코딩: 즉, `234567abcdefghijklmnopqrstuvwxyz` 문자셋을 사용하여 인코딩합니다.
- 특별한 패딩 문자(예: `=`)를 사용하지 않으며, 모든 자릿수가 항상 인코딩되므로 길이는 항상 13개의 ASCII 문자입니다.  
  정수 0에 해당하는 TID는 `2222222222222`입니다.

64비트 정수의 배치는 다음과 같습니다:

- 최상위 비트는 항상 0입니다.
- 다음 53비트는 UNIX 에포크(1970년 1월 1일) 이후의 마이크로초를 나타냅니다.  
  53비트를 선택한 이유는 자바스크립트에서 사용하는 64비트 부동소수점 수의 최대 안전 정수 정밀도 때문입니다.
- 마지막 10비트는 임의의 "클록 식별자"입니다.

TID 생성기는 가능한 충돌을 피하기 위해 임의의 클록 식별자 번호를 생성해야 합니다 (예: 여러 PDS 서비스 클러스터의 작업자 인스턴스 간).  
타임스탬프는 로컬 클록을 사용하여 생성할 수 있습니다.  
동일한 마이크로초에 여러 TID가 생성되거나, "클록 스미어" 또는 클록 동기화 이슈가 발생하는 경우에도 TID 출력 스트림이 단조 증가하며 절대 반복되지 않도록 주의해야 합니다.  
만약 로컬 클록이 밀리초 정밀도만 제공한다면, 타임스탬프를 패딩해야 합니다. (예: 값을 1000으로 곱하여 마이크로초 단위로 변환할 수 있습니다.)

## TID 구문

Lexicon 문자열 타입: `tid`

TID 문자열 구문 파싱 규칙:

- 길이는 항상 13개의 ASCII 문자여야 합니다.
- `234567abcdefghijklmnopqrstuvwxyz` 문자셋, 즉 base32-sortable 문자셋을 사용합니다.
- 첫 번째 문자는 반드시 `234567abcdefghij` 중 하나여야 합니다.

초기 버전의 TID 구문에서는 하이픈을 허용했으나, 현재는 허용되지 않으며 파싱 시 거부해야 합니다.

TID에 대한 참고 정규식은 다음과 같습니다:

```
/^[234567abcdefghij][234567abcdefghijklmnopqrstuvwxyz]{12}$/
```

### 예시

#### 구문적으로 유효한 TID:

```
3jzfcijpj2z2a
7777777777777
3zzzzzzzzzzzz
2222222222222
```

#### 유효하지 않은 TID:

```
# base32 문자가 아님
3jzfcijpj2z21
0000000000000

# 대소문자 구분 (대문자 사용됨)
3JZFCIJPJ2Z2A

# 길이가 너무 길거나 짧음
3jzfcijpj2z2aa
3jzfcijpj2z2
222

# 더 이상 지원되지 않는 레거시 하이픈 구문 (TTTT-TTT-TTTT-CC)
3jzf-cij-pj2z-2a

# 최상위 비트가 1인 경우
zzzzzzzzzzzzz
kjzfcijpj2z2a
