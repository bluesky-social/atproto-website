export const header = {
  title: 'AT URI 스키마 (at://)',
  description: 'ATP 저장소 데이터를 주소 지정하기 위한 URI 스키마입니다.',
}

# AT URI 스키마 (at://)

AT URI 스키마(`at://`)은 특정 저장소의 개별 레코드를 참조할 때, 해당 저장소를 DID 또는 핸들로 식별하여 쉽게 참조할 수 있도록 설계되었습니다. 또한 AT URI는 저장소 내의 컬렉션이나 전체 저장소(즉, 정체성)를 참조하는 데에도 사용할 수 있습니다.

두 개의 AT URI는 동일한 저장소 내의 동일한 레코드를 참조합니다; 하나는 계정의 DID를 사용하고, 다른 하나는 계정의 핸들을 사용합니다.

- `at://did:plc:44ybard66vv44zksje25o7dz/app.bsky.feed.post/3jwdwj2ctlk26`
- `at://bnewbold.bsky.team/app.bsky.feed.post/3jwdwj2ctlk26`

<Note>
**핸들 기반 AT URI에 대한 주의사항**

핸들을 참조하는 AT URI는 내구성이 없습니다.

사용자가 핸들을 변경하면, 해당 핸들을 사용하는 모든 AT URI는 유효하지 않게 되며, 핸들이 재사용될 경우 다른 저장소의 레코드를 참조할 위험이 있습니다.

AT URI는 콘텐츠 기반 주소 지정 방식이 아니므로, 참조하는 레코드의 _내용_ 또한 시간이 지나면서 변경될 수 있습니다.
</Note>

### 구조

AT URI의 전체 일반 구조는 다음과 같습니다:

```text
"at://" AUTHORITY [ PATH ] [ "?" QUERY ] [ "#" FRAGMENT ]
```

**authority** 부분은 저장소와 연결된 정체성을 나타내며, DID 또는 핸들을 사용할 수 있습니다. 단, 핸들은 시간이 지나면서 다른 DID(즉, 다른 저장소)를 참조할 수 있으므로 주의해야 합니다. (자세한 내용은 아래의 "사용 및 구현 가이드라인"과 "강력한 참조" 항목을 참조하세요.)

현재 atproto Lexicon 사용에서는 **query**와 **fragment** 부분이 지원되지 않으며, 경로에 허용되는 패턴은 다음과 같이 고정되어 있습니다:

```text
"at://" AUTHORITY [ "/" COLLECTION [ "/" RKEY ] ]
```

**authority** 부분은 필수이며 정규화되어야 합니다. 만약 DID가 사용된다면, atproto에서 허용된 "blessed" DID 메서드 중 하나여야 합니다. 선택적인 **collection** 부분은 정규화된 [NSID](./nsid)여야 하며, 선택적인 **rkey** 부분은 유효한 [Record Key](./record-key)여야 합니다.

특정 저장소 내의 레코드를 참조하는 AT URI는 *강력한* 참조가 아닙니다. 즉, 콘텐츠 기반 주소 방식이 아니므로 해당 레코드는 시간이 지나면서 변경되거나 삭제될 수 있으며, DID 자체가 삭제되거나 접근이 어려워질 수 있습니다. `did:web`의 경우, DID의 통제(즉, 저장소에 대한 통제)가 시간이 지나면서 변경될 수 있습니다. 또한 authority 부분에 핸들이 포함된 경우, 핸들과 DID 간의 매핑도 변경될 수 있습니다.

AT URI와 `https://`, `ftp://`, `wss://` 등 일반적인 URL 형식 간의 주요 차이점은, AT URI의 "authority" 부분이 지정된 리소스의 네트워크 위치를 나타내지 않는다는 점입니다. 핸들이 authority에 있더라도, 해당 호스트명은 단지 정체성 조회에 사용되며, 실제 저장소 콘텐츠의 호스트(예: PDS 호스트)와 다를 수 있습니다.

### 일반 URI 준수

AT URI는 IETF [RFC-3986](https://www.rfc-editor.org/rfc/rfc3986)에서 정의한 범용 리소스 식별자(URI)의 일반 문법을 따릅니다. 이 문서에서 설명하는 일부 일반 URI 기능을 활용하지만, 모든 기능을 사용하지는 않습니다. 일반 URI의 구성 요소 및 특징은 다음과 같습니다:

- Authority 부분 (double slash 앞에 위치): 지원됨
- 빈 authority 부분: 지원되지 않음
- Userinfo: 현재 지원되지 않으나 향후 사용을 위해 예약됨. 단독 `@` 문자가 핸들 앞에 오는 경우는 유효하지 않음 (예: `at://@handle.example.com` 은 유효하지 않음)
- 호스트와 포트 구분: 지원되지 않음. 이는 DID에 사용된 콜론(`:`)과 문법 충돌이 발생하기 때문입니다.
- Path 부분: 지원되며 선택적임
- Query: 일반 문법에 따라 지원되지만, 현재 사용되지 않음
- Fragment: 일반 문법에 따라 지원되지만, 현재 사용되지 않음
- 상대 참조: 아직 지원되지 않음
- 정규화 규칙: 일반 문법에 따라 지원되나, 현재 사용되지 않음

AT URI는 WHATWG URL 표준([https://url.spec.whatwg.org/](https://url.spec.whatwg.org/))을 준수하지 않습니다. Authority 부분에 포함된 DID의 콜론 문자가 인코딩되지 않은 경우, 해당 표준에서 허용되지 않습니다. DID는 항상 적어도 두 개의 콜론을 포함하며, 항상 `did:`로 시작하고, DID 메서드에는 숫자가 포함될 수 없으므로 명확하게 구분할 수 있습니다.

### 전체 AT URI 문법

전체 AT URI 문법은 향후 경로 구조, 쿼리 매개변수, 그리고 fragment 부분의 확장을 포함한 다양한 사용 사례에 유연하게 대응할 수 있도록 설계되었습니다. 전체 문법 규칙은 다음과 같습니다:

- 전체 URI는 제한된 ASCII 문자 집합으로 구성됩니다.
- 아래에서 언급하는 "unreserved" 문자 집합은 [RFC-3986](https://www.rfc-editor.org/rfc/rfc3986)에서 정의된 영숫자(`A-Za-z0-9`), 마침표, 하이픈, 언더스코어, 틸데(`.-_~`)를 포함합니다.
- 전체 길이 제한은 최대 8킬로바이트(향후 변경될 수 있음)
- 문자의 16진수 인코딩은 허용되나, 실제로는 필요하지 않습니다.
- URI 스키마은 `at`이며, 항상 double slash(`//`)와 함께 authority 부분이 필수입니다. 즉, URI는 항상 `at://`로 시작해야 합니다.
- Authority 부분은 필수이며 비어있을 수 없습니다. Authority는 atproto 핸들이거나 atproto와 함께 사용하기 위한 제한 조건을 충족하는 DID여야 합니다. Authority 부분은 호스트:포트 쌍으로 해석될 수 없으며, 이는 DID에 콜론(`:`)이 사용되기 때문입니다. DID 내의 콜론과 unreserved 문자는 인코딩되지 않아야 하며, 다른 예약 문자는(예: `#`, `/`, `$`, `&`, `@`) 인코딩되어야 합니다.
    - 현재 atproto에서 허용하는 "blessed" DID 메서드는 이러한 예약 문자가 DID 식별자에 포함되지 않음을 보장합니다.
- 선택적인 경로 부분은 authority 다음에 올 수 있으며, 경로는 단일 슬래시(`/`)로 구분된 여러 세그먼트를 포함할 수 있습니다. 일반 URI 경로 정규화 규칙을 사용할 수 있습니다.
- 선택적인 쿼리 부분은 일반 URI 문법 제한을 따릅니다.
- 선택적인 fragment 부분은 JSON Path 문법을 따릅니다.

### 제한된 AT URI 문법

Lexicon에서 `at-uri` 타입으로 사용되는 AT URI의 하위 집합은 다음과 같습니다. 현재 쿼리 매개변수와 fragment는 사용되지 않으며, 끝에 슬래시가 허용되지 않습니다 (authority 뒤에 추가적인 경로가 없을 때의 슬래시 포함 불가). URI는 정규화된 형태여야 하며, 모든 하위 식별자들도 정규화되어야 합니다.

```text
AT-URI        = "at://" AUTHORITY [ "/" COLLECTION [ "/" RKEY ] ]

AUTHORITY     = HANDLE | DID
COLLECTION    = NSID
RKEY          = RECORD-KEY
```

### 정규화

특히 atproto 레코드에 포함될 때, 재현 가능하고 단순 문자열 비교가 가능하도록 엄격한 정규화 규칙을 따라야 합니다.

- URI의 모든 부분에서 불필요한 16진수 인코딩을 사용하지 않습니다.
- 인코딩된 16진수 문자는 대문자로 표기합니다.
- URI 스키마은 소문자로 표기합니다.
- 핸들이 authority에 사용된 경우, 소문자로 표기합니다.
- DID가 authority에 사용된 경우, 정규화된 형태여야 하며 중복된 16진수 인코딩을 피해야 합니다. (이미 16진수 인코딩되어 있다면 퍼센트 기호를 다시 인코딩하지 않습니다.)
- 경로 부분 끝에 슬래시를 사용하지 않습니다.
- 경로 부분 내 중복 슬래시나 불필요한 "dot" 섹션(`/./` 또는 `/abc/../` 등)을 제거합니다.
- 경로에 포함된 NSID의 도메인 부분은 소문자로 표기합니다.
- 레코드 키는 대소문자를 구분하며 정규화하지 않습니다.
- Lexicon 레코드에서 저장소나 레코드를 참조할 때는 쿼리와 fragment 부분을 포함하지 않습니다.

자세한 경로 정규화 및 `..`/`.` 상대 참조 제거는 [RFC-3986](https://www.rfc-editor.org/rfc/rfc3986)을 참고하세요.

### 예시

유효한 AT URI (일반 및 Lexicon 문법 모두):

```text
at://foo.com/com.example.foo/123
```

일반 AT URI 문법에서는 유효하지만, 현재 Lexicon에서는 유효하지 않은 예:

```text
at://foo.com/example/123     // 유효하지 않은 NSID
at://computer                // 유효한 DID 또는 핸들이 아님
at://example.com:3000        // 유효한 DID 또는 핸들이 아님
```

두 문맥 모두에서 유효하지 않은 AT URI:

```text
at://foo.com/                // 끝에 슬래시 있음
at://user:pass@foo.com       // userinfo는 현재 지원되지 않음
```

### 사용 및 구현 가이드라인

일반 URI 및 URL 파싱 라이브러리는 때때로 AT URI에 사용할 수 있으나, 항상 적절히 동작하는 것은 아닙니다. 핵심 요구사항은 URI의 authority(또는 origin) 부분을 userinfo, host, port로 분리하지 않고 단순 문자열로 다룰 수 있어야 한다는 점입니다. 구체적으로:

- Python 3의 `urllib` 모듈(표준 라이브러리)은 사용 가능합니다.
- Javascript의 `url-parse` 패키지는 사용 가능합니다.
- Golang의 `net/url` 패키지는 작동하지 않습니다.
- 대부분의 인기 있는 Rust URL 파싱 크레이트들은 작동하지 않습니다.

특히 다른 저장소의 레코드를 참조할 때는, 권장사항으로 authority 부분에 DID를 사용하는 것입니다. 어플리케이션 화면에서는 보다 읽기 쉬운 핸들을 사용할 수 있습니다. HTML에서는 핸들 버전의 AT URI를 *표시*하고, 실제 링크(`href`)는 DID 버전을 사용할 수 있습니다.

레코드에 대한 *강력한* 참조가 필요한 경우, AT URI와 함께 CID 해시를 사용하는 것이 권장됩니다.

Lexicon(레코드, API 등)에서는 때때로 일반 `at-uri` 문자열 형식 외에 특정 변형의 AT URI가 요구됩니다. 예를 들어, 레코드 내부에서 다른 레코드를 참조할 때는 authority 부분에 DID가 있어야 하며, URI는 컬렉션과 rkey 경로 세그먼트를 포함해야 합니다. 이러한 조건을 충족하지 않는 URI는 검증에 실패합니다.

JSON Path의 fragment 문법과 Lexicon 참조 문법을 혼동하지 마세요. 두 문법 모두 `#` 기호를 사용하여 JSON 문서 내 다른 필드를 참조하지만, 예를 들어 JSON Path 문법은 슬래시(`/`)로 시작합니다 (예: `#/key`).

### 향후 변경 가능 사항

최대 길이 제한은 변경될 수 있습니다.

상대 참조는 Lexicon의 `at-uri` 필드에서 지원될 수 있습니다. 예를 들어, 동일한 저장소 내의 다른 레코드를 참조할 때 `../<collection>/<rkey>`와 같은 상대 경로 문법을 사용할 수 있습니다.
