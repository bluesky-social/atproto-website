import Link from 'next/link'
import {FooterCTA} from "@/components/FooterCTA"
import {Heading} from '@/components/Heading'
import AppBanner from './app-banner.png'
import AppLogin from './app-login.png'
import AppScreenshot from './app-screenshot.png'
import AppStatusHistory from './app-status-history.png'
import AppStatusOptions from './app-status-options.png'
import DiagramEventStream from './diagram-event-stream.png'
import DiagramInfoFlow from './diagram-info-flow.png'
import DiagramOauth from './diagram-oauth.png'
import DiagramOptimisticUpdate from './diagram-optimistic-update.png'
import DiagramRepo from './diagram-repo.png'

export const header = {
  title: 'ATプロトコルでアプリケーションを構築するためのクイックスタートガイド',
  description:
    'このガイドでは、「ステータス」を絵文字として公開するシンプルなマルチユーザーアプリを構築します。',
}

# ATプロトコルでアプリケーションを構築するためのクイックスタートガイド

<Link href="https://github.com/bluesky-social/statusphere-example-app" className="not-prose flex items-center gap-2 bg-blue-100 dark:bg-blue-950 dark:text-white px-4 py-3 text-base rounded-lg hover:underline">
  <svg viewBox="0 0 20 20" aria-hidden="true" className="h-6 dark:text-white">
    <path
      fill="currentColor"
      fillRule="evenodd"
      clipRule="evenodd"
      d="M10 1.667c-4.605 0-8.334 3.823-8.334 8.544 0 3.78 2.385 6.974 5.698 8.106.417.075.573-.182.573-.406 0-.203-.011-.875-.011-1.592-2.093.397-2.635-.522-2.802-1.002-.094-.246-.5-1.005-.854-1.207-.291-.16-.708-.556-.01-.567.656-.01 1.124.62 1.281.876.75 1.292 1.948.93 2.427.705.073-.555.291-.93.531-1.143-1.854-.213-3.791-.95-3.791-4.218 0-.929.322-1.698.854-2.296-.083-.214-.375-1.09.083-2.265 0 0 .698-.224 2.292.876a7.576 7.576 0 0 1 2.083-.288c.709 0 1.417.096 2.084.288 1.593-1.11 2.291-.875 2.291-.875.459 1.174.167 2.05.084 2.263.53.599.854 1.357.854 2.297 0 3.278-1.948 4.005-3.802 4.219.302.266.563.78.563 1.58 0 1.143-.011 2.061-.011 2.35 0 .224.156.491.573.405a8.365 8.365 0 0 0 4.11-3.116 8.707 8.707 0 0 0 1.567-4.99c0-4.721-3.73-8.545-8.334-8.545Z"
    />
  </svg>
  <span>
    サンプルアプリケーションのソースコードはGitHubで見つかります。
  </span>
</Link>

このガイドでは、「ステータス」を絵文字として公開するシンプルなマルチユーザーアプリを構築します。アプリケーションは以下の画像のようになります。{{className: 'lead'}}

<Image alt="サンプルアプリケーションのスクリーンショット" src={AppScreenshot} />

以下の方法について説明します。 {{className: 'lead'}}

- OAuthでサインイン {{className: 'lead'}}
- ユーザーに関する情報（プロフィール）を取得する {{className: 'lead'}}
- ネットワークfirehoseで新しいデータを継続的に取得する {{className: 'lead'}}
- カスタムスキーマを使用してユーザーのアカウントにデータを公開する {{className: 'lead'}}

atprotoをすぐに理解できるように、ここでは簡単な内容に留めます。各ステップについて、詳細情報へのリンクがあります。 {{className: 'lead'}}

<Heading level={2} id="introduction">はじめに</Heading>

Atmosphereのデータは、ユーザーの個人リポジトリに保存されます。各ユーザーが独自のウェブサイトを持っているようなものです。目標は、全ユーザーからのデータをSQLite DBに集約することです。 

私たちのアプリをGoogleのようなものだと考えてください。Googleの仕事が、各ウェブサイトの`/status.json`の下にどの絵文字があるかを伝えることだったとしたら、次のような表示になります。

- `https://nytimes.com/status.json`によると、`nytimes.com`は📰気分です
- `https://bsky.app/status.json`によると、`bsky.app`は🦋気分です
- `https://reddit.com/status.json`によると、`reddit.com`は🤓気分です

Atmosphereも同様に動作しますが、`https://`ではなく`at://`をチェックします。各ユーザーには`at://` URLの下にデータリポジトリがあります。Atmosphere内のすべてのユーザーデータリポジトリをクロールして、すべての"status.json"レコードを取得し、それらをSQLiteデータベースに集約します。

> `at://`はATプロトコルのURLスキームです。内部的にはHTTPやDNSなどの一般的な技術を使用していますが、このチュートリアルで使用するすべての機能が追加されています。

<Heading level={2} id="step-1-starting-with-our-expressjs-app">ステップ1. ExpressJSアプリから始める</Heading>

まず、リポジトリをクローンしてパッケージをインストールします。

```bash
git clone https://github.com/bluesky-social/statusphere-example-app.git
cd statusphere-example-app
cp .env.template .env
npm install
npm run dev
# http://localhost:8080に移動します
```

リポジトリは通常のウェブアプリです。1999年のようにHTMLサーバー側でレンダリングしています。また、[Kysely](https://kysely.dev/)で管理しているSQLiteデータベースもあります。

最初のスタック

- TypeScript
- NodeJSウェブサーバー（[express](https://expressjs.com/)）
- SQLiteデータベース（[Kysely](https://kysely.dev/)）
- サーバーサイドレンダリング（[uhtml](https://www.npmjs.com/package/uhtml)）

各ステップで、ウェブアプリがAtmosphereを活用する方法を説明します。詳細なコードについては、コードベースを参照してください。繰り返しますが、このチュートリアルでは、わかりやすく簡潔に説明します。

<Heading level={2} id="step-2-signing-in-with-oauth">ステップ2. OAuthでサインイン</Heading>

誰かがアプリにログインすると、その人の個人用`at://`リポジトリへの読み取りおよび書き込みアクセス権が付与されます。これを使用して、ステータスjsonレコードを書き込みます。

これをOAuth（[spec](https://github.com/bluesky-social/proposals/tree/main/0004-oauth)）を使用して実現します。OAuthフローのほとんどは、[@atproto/oauth-client-node](https://github.com/bluesky-social/atproto/tree/main/packages/oauth/oauth-client-node)ライブラリで処理されます。私たちが目指している構成は以下のようになります。

<Image alt="OAuth要素の図" src={DiagramOauth} />

ユーザーがログインすると、OAuthクライアントはリポジトリサーバーとの新しいセッションを作成し、基本的なユーザー情報とともに読み取り/書き込みアクセス権限を付与します。

<Image alt="ログインUIのスクリーンショット" src={AppLogin} />

ログインページでは、ユーザーに「ハンドル」を尋ねるだけです。ハンドルとは、アカウントに関連付けられたドメイン名です。[Bluesky](https://bsky.app)ユーザーからすると、`alice.bsky.social`という形式ばかりに見えますが、任意のドメイン（例えば`alice.com`）にすることができます。

```html
<!-- src/pages/login.ts -->
<form action="/login" method="post" class="login-form">
  <input
    type="text"
    name="handle"
    placeholder="Enter your handle (eg alice.bsky.social)"
    required
  />
  <button type="submit">Log in</button>
</form>
```

ユーザーがフォームを送信すると、OAuthクライアントに認証フローを開始するように指示し、ユーザーをサーバーにリダイレクトしてプロセスを完了します。

```typescript
/** src/routes.ts **/
// ログインハンドラー
router.post(
  '/login',
  handler(async (req, res) => {
    // OAuthフローを開始
    const handle = req.body?.handle
    const url = await oauthClient.authorize(handle, {
      scope: 'atproto transition:generic',
    })
    return res.redirect(url.toString())
  })
)
```

これは、GoogleやGitHubが使用するのに似たSSOフローです。ユーザーはパスワードを求められ、次にアプリケーションとのセッションを確認するように求められます。

それが完了すると、ユーザーはウェブアプリの`/oauth/callback`に送り返されます。OAuthクライアントはユーザーのサーバーのアクセストークンを保存し、その後、アカウントの[DID](https://atproto.com/specs/did)をセッションCookieに添付します。

```typescript
/** src/routes.ts **/
// セッション作成を完了するためのOAuthコールバック
router.get(
  '/oauth/callback',
  handler(async (req, res) => {
    // 資格情報を保存します
    const { session } = await oauthClient.callback(params)

    // アカウントDIDをCookie経由でユーザーに添付します
    const cookieSession = await getIronSession(req, res)
    cookieSession.did = session.did
    await cookieSession.save()

    // アプリに送り返します
    return res.redirect('/')
  })
)
```

さあ、準備ができました。これで、ユーザーのリポジトリサーバーとのセッションが確立され、それを使用してユーザーのデータにアクセスできます。

<Heading level={2} id="step-3-fetching-the-users-profile">ステップ3. ユーザーのプロフィールを取得する</Heading>

ユーザーについて何か調べてみましょう。[Bluesky](https://bsky.app)では、ユーザーは次のようなプロフィールレコードを公開します。

```typescript
interface ProfileRecord {
  displayName?: string // 人間にわかりやすい名前
  description?: string // 短いアカウント説明
  avatar?: BlobRef     // 小さなプロフィール画像
  Banner?: BlobRef     // プロフィール画面に表示するバナー画像
  createdAt?: string   // このプロフィールデータが追加された時刻（自称）
  // ...
}
```

[atproto-browser.vercel.app](https://atproto-browser.vercel.app)を使用して、このレコードを直接調べることができます。たとえば、[これは@bsky.appのプロフィールレコードです](https://atproto-browser.vercel.app/at?u=at://did:plc:z72i7hdynmk6r22z27h6tvur/app.bsky.actor.profile/self)。

このレコードを取得するには、ユーザーのOAuthセッションに関連付けられた[エージェント](https://github.com/bluesky-social/atproto/tree/main/packages/api)を使用します。

```typescript
await agent.com.atproto.repo.getRecord({
  repo: agent.assertDid,                // ユーザー
  collection: 'app.bsky.actor.profile', // コレクション
  rkey: 'self',                         // レコードキー
})
```

レコードを要求するときは、3つの情報を渡します。

- **repo** ユーザーを識別する[DID](https://atproto.com/specs/did)
- **collection** コレクション名
- **rkey** レコードキー

コレクション名については後ほど説明します。レコードキーは、[いくつかの制限](https://atproto.com/specs/record-key#record-key-syntax)といくつかの共通パターンを持つ文字列です。`"self"`パターンは、コレクションにユーザーを説明するレコードが1つだけ含まれると予想される場合に使用されます。

このプロフィールレコードを取得するためにホームページを更新しましょう。

```typescript
/** src/routes.ts **/
// ホームページ
router.get(
  '/',
  handler(async (req, res) => {
    // ユーザーがサインインしている場合は、サーバーと通信するエージェントを取得します
    const agent = await getSessionAgent(req, res, ctx)

    if (!agent) {
      // ログアウトビューを提供します
      return res.type('html').send(page(home()))
    }

    // ログインしたユーザーに関する追加情報を取得します
    const { data: profileRecord } = await agent.com.atproto.repo.getRecord({
      repo: agent.assertDid,                // ユーザーのリポジトリ
      collection: 'app.bsky.actor.profile', // blueskyプロフィールを表すレコード型
      rkey: 'self',                         // レコードのキー
    })

    // ログインビューを提供する
    return res
      .type('html')
      .send(page(home({ profile: profileRecord.value || {} })))
  })
)
```

このデータを使用して、ユーザー向けにパーソナライズされた素敵なウェルカムバナーを表示できます。

<Image alt="バナー画像のスクリーンショット" src={AppBanner} />

```html
<!-- pages/home.ts -->
<div class="card">
  ${profile
    ? html`<form action="/logout" method="post" class="session-form">
        <div>
          Hi, <strong>${profile.displayName || 'friend'}</strong>.
          What's your status today?
        </div>
        <div>
          <button type="submit">Log out</button>
        </div>
      </form>`
    : html`<div class="session-form">
        <div><a href="/login">Log in</a> to set your status!</div>
        <div>
          <a href="/login" class="button">Log in</a>
        </div>
      </div>`}
</div>
```

<Heading level={2} id="step-4-reading-writing-records">ステップ4. レコードの読み取りと書き込み</Heading>

ユーザーリポジトリは、JSONレコードのコレクションと考えることができます。

<Image alt="リポジトリの図" src={DiagramRepo} />

プロフィールレコードの読み取り方法をもう一度見てみましょう。

```typescript
await agent.com.atproto.repo.getRecord({
  repo: agent.assertDid,                // ユーザー
  collection: 'app.bsky.actor.profile', // コレクション
  rkey: 'self',                         // レコードキー
})
```

同様のAPIを使用してレコードを書き込みます。目標はステータスレコードを書き込むことなので、その方法を見てみましょう。

```typescript
// 時間ベースのレコードキーを生成します
const rkey = TID.nextStr()

// 書き込み
await agent.com.atproto.repo.putRecord({
  repo: agent.assertDid,                // ユーザー
  collection: 'xyz.statusphere.status', // コレクション
  rkey,                                 // レコードキー
  record: {                             // レコード値
    status: "👍",
    createdAt: new Date().toISOString()
  }
})
```

`POST /status`ルートでは、このAPIを使用してユーザーのステータスをリポジトリに公開します。

```typescript
/** src/routes.ts **/
// "Set status" ハンドラー
router.post(
  '/status',
  handler(async (req, res) => {
    // ユーザーがサインインしている場合は、サーバーと通信するエージェントを取得します
    const agent = await getSessionAgent(req, res, ctx)
    if (!agent) {
      return res.status(401).type('html').send('<h1>Error: Session required</h1>')
    }

    // ステータスレコードを構築します
    const record = {
      $type: 'xyz.statusphere.status',
      status: req.body?.status,
      createdAt: new Date().toISOString(),
    }

    try {
      // ステータスレコードをユーザーのリポジトリに書き込みます
      await agent.com.atproto.repo.putRecord({
        repo: agent.assertDid,
        collection: 'xyz.statusphere.status',
        rkey: TID.nextStr(),
        record,
      })
    } catch (err) {
      logger.warn({ err }, 'failed to write record')
      return res.status(500).type('html').send('<h1>Error: Failed to write record</h1>')
    }

    res.status(200).json({})
  })
)
```

これで、ホームページにステータスボタンを一覧表示できます。

```html
<!-- src/pages/home.ts -->
<form action="/status" method="post" class="status-options">
  ${STATUS_OPTIONS.map(status => html`
    <button class="status-option" name="status" value="${status}">
      ${status}
    </button>
  `)}
</form>
```

するとこうなります。

<Image alt="アプリのステータスの選択肢のスクリーンショット" src={AppStatusOptions} />

<Heading level={2} id="step-5-creating-a-custom-status-schema">ステップ5. カスタムの「ステータス」スキーマの作成</Heading>

リポジトリのコレクションは型指定されており、スキーマが定義されています。`app.bsky.actor.profile`型定義は[こちら](https://github.com/bluesky-social/atproto/blob/main/lexicons/app/bsky/actor/profile.json)にあります。

[JSON-Schema](http://json-schema.org/)に非常によく似た[Lexicon](https://atproto.com/specs/lexicon)言語を使用して、誰でも新しいスキーマを作成できます。スキーマは、所有権を示す[逆DNS ID](https://atproto.com/specs/nsid)を使用します。このデモアプリでは、このプロジェクト専用に登録した`xyz.statusphere`（別名statusphere.xyz）を使用します。

> <Heading level={3} id="why-create-a-schema">スキーマを作成する理由</Heading>
>
> スキーマは、アプリが作成するデータを他のアプリケーションが理解するのに役立ちます。スキーマを公開することで、他のアプリケーション作成者もデータをあなたのアプリが認識して処理できる形式で公開しやすくなります。

コードベースの`/lexicons`フォルダーにスキーマを作成しましょう。[スキーマの定義方法の詳細については、こちら](https://atproto.com/guides/lexicon)をご覧ください。

```json
/** lexicons/status.json **/
{
  "lexicon": 1,
  "id": "xyz.statusphere.status",
  "defs": {
    "main": {
      "type": "record",
      "key": "tid",
      "record": {
        "type": "object",
        "required": ["status", "createdAt"],
        "properties": {
          "status": {
            "type": "string",
            "minLength": 1,
            "maxGraphemes": 1,
            "maxLength": 32
          },
          "createdAt": {
            "type": "string",
            "format": "datetime"
          }
        }
      }
    }
  }
}
```

では、スキーマを使用してコード生成を実行してみましょう。

```bash
./node_modules/.bin/lex gen-server ./src/lexicon ./lexicons/*
```

これにより、アプリで使用できるTypeScriptインターフェースと実行時検証関数が生成されます。生成されたコードは次のようになります。

```typescript
/** src/lexicon/types/xyz/statusphere/status.ts **/
export interface Record {
  status: string
  createdAt: string
  [k: string]: unknown
}

export function isRecord(v: unknown): v is Record {
  return (
    isObj(v) &&
    hasProp(v, '$type') &&
    (v.$type === 'xyz.statusphere.status#main' || v.$type === 'xyz.statusphere.status')
  )
}

export function validateRecord(v: unknown): ValidationResult {
  return lexicons.validate('xyz.statusphere.status#main', v)
}
```

このコードを使用して、`POST /status`ルートを改善してみましょう。

```typescript
/** src/routes.ts **/
import * as Status from '#/lexicon/types/xyz/statusphere/status'
// ...
// "Set status" ハンドラー
router.post(
  '/status',
  handler(async (req, res) => {
    // ...

    // ステータスレコードを構築して検証
    const record = {
      $type: 'xyz.statusphere.status',
      status: req.body?.status,
      createdAt: new Date().toISOString(),
    }
    if (!Status.validateRecord(record).success) {
      return res.status(400).json({ error: 'Invalid status' })
    }

    // ...
  })
)
```

<Heading level={2} id="step-6-listening-to-the-firehose">ステップ6. firehoseをリッスン</Heading>

ここまでで、以下の操作を実行しました。

- OAuthでログイン
- カスタムスキーマを作成
- ログインしたユーザーのレコードの読み取りと書き込み

次に、他のユーザーからステータスレコードを取得します。

私たちのアプリを、リポジトリをクロールしてレコードを取得するGoogleのようなものだと言ったことを覚えていますか？ATプロトコルの利点の一つは、各リポジトリが更新のイベントログを公開することです。

<Image alt="イベントストリームの図" src={DiagramEventStream} />

[リレーサービス](https://docs.bsky.app/docs/advanced-guides/federation-architecture#relay)を使用すると、ネットワーク内のすべてのユーザーにわたってイベントが集約されたfirehoseを取得できます。今回探しているのは有効な`xyz.statusphere.status`レコードです。

```typescript
/** src/ingester.ts **/
import { Firehose } from '@atproto/sync'
import * as Status from '#/lexicon/types/xyz/statusphere/status'
// ...

new Firehose({
  filterCollections: ['xyz.statusphere.status'],
  handleEvent: async (evt) => {
    // 書き込みイベントを監視する
    if (evt.event === 'create' || evt.event === 'update') {
      const record = evt.record

      // 書き込みが有効なステータス更新である場合
      if (
        evt.collection === 'xyz.statusphere.status' &&
        Status.isRecord(record) &&
        Status.validateRecord(record).success
      ) {
        // ステータスを保存する
        // TODO
      }
    }
  },
})
```

これらのステータスを保存するためのSQLiteテーブルを作成しましょう。

```typescript
/** src/db.ts **/
// ステータステーブルを作成します
await db.schema
  .createTable('status')
  .addColumn('uri', 'varchar', (col) => col.primaryKey())
  .addColumn('authorDid', 'varchar', (col) => col.notNull())
  .addColumn('status', 'varchar', (col) => col.notNull())
  .addColumn('createdAt', 'varchar', (col) => col.notNull())
  .addColumn('indexedAt', 'varchar', (col) => col.notNull())
  .execute()
```

これで、firehoseから到着したステータスをデータベースに書き込むことができます。

```typescript
/** src/ingester.ts **/
// 書き込みが有効なステータス更新である場合
if (
  evt.collection === 'xyz.statusphere.status' &&
  Status.isRecord(record) &&
  Status.validateRecord(record).success
) {
  // ステータスをSQLiteに保存します
  await db
    .insertInto('status')
    .values({
      uri: evt.uri.toString(),
      authorDid: evt.author,
      status: record.status,
      createdAt: record.createdAt,
      indexedAt: new Date().toISOString(),
    })
    .onConflict((oc) =>
      oc.column('uri').doUpdateSet({
        status: record.status,
        indexedAt: new Date().toISOString(),
      })
    )
    .execute()
}
```

ほぼ、情報がループで流れていると考えることができます。

<Image alt="情報のフロー図" src={DiagramInfoFlow} />

アプリケーションはリポジトリに書き込みます。書き込みイベントはその後、firehoseに発行され、アプリによってキャッチされてデータベースに取り込まれます。

このようにイベントログから同期する理由は、ネットワーク内に、対象のレコードを書き込む他のアプリがあるためです。イベントログをサブスクライブすることで、他のアプリによって公開されたデータを含む、すべてのデータをキャッチできます。

<Heading level={2} id="step-7-listing-the-latest-statuses">ステップ7. 最新のステータスを一覧表示する</Heading>

SQLiteにステータスが取り込まれたので、ユーザーによるステータス更新のタイムラインを作成できます。また、[DID](https://atproto.com/specs/did)からハンドルへのリゾルバも使用して、ステータスとともに適切なユーザー名を表示できるようにします。

```typescript
/** src/routes.ts **/
// ホームページ
router.get(
  '/',
  handler(async (req, res) => {
    // ...

    // SQLiteに保存されているデータを取得します
    const statuses = await db
      .selectFrom('status')
      .selectAll()
      .orderBy('indexedAt', 'desc')
      .limit(10)
      .execute()

    // ユーザーのDIDをドメイン名のハンドルにマップします
    const didHandleMap = awaitresolver.resolveDidsToHandles(
      statuses.map((s) => s.authorDid)
    )

    // ...
  })
)
```

HTMLで次のステータスレコードを一覧表示できるようになりました。

```html
<!-- src/pages/home.ts -->
${statuses.map((status, i) => {
  const handle = didHandleMap[status.authorDid] || status.authorDid
  return html`
    <div class="status-line">
      <div>
        <div class="status">${status.status}</div>
      </div>
      <div class="desc">
        <a class="author" href="https://bsky.app/profile/${handle}">@${handle}</a>
        was feeling ${status.status} on ${status.indexedAt}.
      </div>
    </div>
  `
})}
```

<Image alt="アプリのステータスタイムラインのスクリーンショット" src={AppStatusHistory} />

<Heading level={2} id="step-8-optimistic-updates">ステップ8. 楽観的更新</Heading>

最後の最適化として、楽観的更新を導入しましょう。

リポジトリ書き込みとイベントログによる情報フローループを覚えていますか？

<Image alt="情報のフロー図" src={DiagramInfoFlow} />

ユーザーのリポジトリをローカルで更新しているので、そのフローを独自のデータベースに短絡できます。

<Image alt="楽観的更新を示す図" src={DiagramOptimisticUpdate} />

これは、ユーザーがアプリの使用中に自分の変更を確認できるようにするため、重要な最適化です。最終的にイベントがfirehoseから到着すると、すでにローカルに保存されているため、それを破棄します。

これを行うには、SQLite DBへの追加の書き込みを含めるように`POST /status`を更新するだけです。

```typescript
/** src/routes.ts **/
// "Set status" ハンドラー
router.post(
  '/status',
  handler(async (req, res) => {
    // ...

    let uri
    try {
    // ステータスレコードをユーザーのリポジトリに書き込みます
    const res = await agent.com.atproto.repo.putRecord({
      repo: agent.assertDid,
      collection: 'xyz.statusphere.status',
      rkey: TID.nextStr(),
      record,
    })
    uri = res.uri
    } catch (err) {
      logger.warn({ err }, 'failed to write record')
      return res.status(500).json({ error: 'Failed to write record' })
    }

    try {
      // SQLiteを楽観的に更新します <-- ここ!
      await db
        .insertInto('status')
        .values({
          uri,
          authorDid: agent.assertDid,
          status: record.status,
          createdAt: record.createdAt,
          indexedAt: new Date().toISOString(),
        })
        .execute()
    } catch (err) {
      logger.warn(
        { err },
        'failed to update computed view; ignoring as it should be caught by the firehose'
      )
    }

    res.status(200).json({})
  })
)
```

このコードは、`ingester.ts`で行っていることとほとんど同じであることがわかります。

<Heading level={2} id="thinking-in-at-proto">atproto的に考える</Heading>

このチュートリアルでは、Atprotoアプリを構築するための重要な手順について説明しました。データは、ユーザーの`at://`リポジトリに正規形で公開され、その後、アプリのデータベースに集約されてネットワークのビューが生成されます。

アプリを構築するときは、次の4つの重要な手順について考えます。

- Atmosphereに公開するレコードの[Lexicon](https://atproto.com/guides/lexicon)スキーマを設計します。
- レコードを便利なビューに集約するためのデータベースを作成します。
- ユーザーのリポジトリにレコードを書き込むアプリケーションを構築します。
- ネットワーク全体のデータを集約するために、firehoseをリッスンします。

この情報の流れを常に覚えておいてください。

<Image alt="情報のフロー図" src={DiagramInfoFlow} />

[Blueskyソーシャルアプリ](https://bsky.app)を含む、Atmosphereのすべてのアプリはこのように動作します。

<Heading level={2} id="next-steps">次のステップ</Heading>

学習した内容を実践したい場合は、次の追加の課題に挑戦してみてください:

- すべてのユーザーのプロフィールレコードを同期して、ハンドルではなく表示名を表示できるようにします。
- 使用された各ステータスの数をカウントし、合計数を表示します。
- 認証されたユーザーのフォロー`app.bsky.graph.follow`を取得し、それらのステータスを表示します。
- ウェブサイトへのリンクを投稿して1から4つ星で評価する方法など、別の種類のスキーマを作成します。

<FooterCTA href="/" title="さらに学習する準備はできましたか？" description="仕様、ガイド、SDKはここにあります。" />
