export const metadata = {
  title: 'Lexicons - AT Protocol Docs',
  description: 'A schema-driven interoperability framework',
}

# Lexicons

Lexicon is a schema system used to define RPC methods and record types. Every Lexicon schema is written in JSON, in a format similar to [JSON-Schema](https://json-schema.org/) for defining constraints.

**Lexicons provide Interoperability.** AT applications need a way to declare their own behaviors and semantics. Lexicon solves this while making it straightforward for developers to introduce new schemas.

The schemas are identified using [NSIDs](/specs/nsid), a reverse-DNS format. Here are some example API endpoints:

```
com.atproto.repo.getRecord
com.atproto.identity.resolveHandle
app.bsky.feed.getPostThread
app.bsky.notification.listNotifications
```

And here are some example record types:

```
app.bsky.feed.post
app.bsky.feed.like
app.bsky.actor.profile
app.bsky.graph.follow
```

The schema types, definition language, and validation constraints are described in the [Lexicon specification](/specs/lexicon), and representations in JSON and CBOR are described in the [Data Model specification](/specs/data-model).

## HTTP API methods

The AT Protocol's API system, [XRPC](/specs/xrpc), is essentially a thin wrapper around HTTPS. For example, a call to:

```tsx
client.call(app.bsky.actor.getProfile, {})
```

is actually just an HTTP request:

```
GET /xrpc/com.example.getProfile
```

The schemas establish valid query parameters, request bodies, and response bodies.

```json
{
  "lexicon": 1,
  "id": "com.example.getProfile",
  "defs": {
    "main": {
      "type": "query",
      "parameters": {
        "type": "params",
        "required": ["user"],
        "properties": { "user": { "type": "string" } }
      },
      "output": {
        "encoding": "application/json",
        "schema": {
          "type": "object",
          "required": ["did", "name"],
          "properties": {
            "did": { "type": "string" },
            "name": { "type": "string" },
            "displayName": { "type": "string", "maxLength": 64 },
            "description": { "type": "string", "maxLength": 256 }
          }
        }
      }
    }
  }
}
```

## Installing and Using Lexicons

Lexicon's schemas enable code generation with types and validation. Our SDKs each install a `lex` tool that lets you generate a type-safe client that knows which parameters each AT endpoint expects.

For example, in TypeScript:

```jsx
npm install -g @atproto/lex
```

This provides the `lex` command, which you can use to install Lexicons into a local project:

```jsx
lex install app.bsky.feed.post app.bsky.feed.like
```

This creates:

- `lexicons.json` - manifest tracking installed Lexicons and their versions (CIDs)
- `lexicons/` - directory containing the Lexicon JSON files

Finally, generate TypeScript schemas from the installed Lexicons:

```markdown
lex build
```

This generates TypeScript files in `./src/lexicons`. Now, you'll have these functions available to use in your code:

```tsx
import { Client } from '@atproto/lex'
import * as app from './lexicons/app.js'

// Create a client instance
const client = new Client('https://public.api.bsky.app')

// Start making requests using generated schemas
const response = await client.call(app.bsky.actor.getProfile, {
  actor: 'pfrazee.com',
})
```

For more guidance on working with `lex`, refer to the [readme](https://github.com/bluesky-social/atproto-internal/blob/msi/lex/packages/lex/lex/README.md#json-schemas).

## Record types

Schemas define the possible values of a record. Every record has a ‚Äútype‚Äù which maps to a schema and also establishes the URL of a record.

For instance, this ‚Äúfollow‚Äù record:

```json
{
  "$type": "com.example.follow",
  "subject": "at://did:plc:12345",
  "createdAt": "2022-10-09T17:51:55.043Z"
}
```

‚Ä¶would have a URL like:

```
at://bob.com/com.example.follow/12345
```

‚Ä¶and a schema like:

```json
{
  "lexicon": 1,
  "id": "com.example.follow",
  "defs": {
    "main": {
      "type": "record",
      "description": "A social follow",
      "record": {
        "type": "object",
        "required": ["subject", "createdAt"],
        "properties": {
          "subject": { "type": "string" },
          "createdAt": { "type": "string", "format": "datetime" }
        }
      }
    }
  }
}
```

## Versioning

Once a Lexicon is published, it can never change its constraints. Loosening a constraint (adding possible values) will cause old software to fail validation for new data, and tightening a constraint (removing possible values) will cause new software to fail validation for old data. As a consequence, lexicons may only add optional constraints to previously unconstrained fields.

If a lexicon must change a previously-published constraint, it should be published as a new lexicon under a new NSID.

## Creating and Publishing Lexicons

Lexicons are designed to be machine-readable and network-accessible. While it is not currently *required* that a lexicon is available on the network, it is strongly advised to publish lexicon so that a single canonical & authoritative representation is available to consumers of the method.

You can use [`goat`](https://github.com/bluesky-social/goat), our command line tool, for creating and publishing Lexicons. The Lexicon-related features are available under [`goat lex`](https://github.com/bluesky-social/goat?tab=readme-ov-file#lexicon-development) :

- publishing schemas to and synchronizing from the AT network
- diffing, linting, and verifying schema evolution rules

For example: in a project directory, you can download some existing Lexicons, which will get saved as JSON files in `./lexicons/`:

```markdown
$ goat lex pull com.atproto.repo.strongRef com.atproto.moderation. app.bsky.actor.profile
 üü¢ com.atproto.repo.strongRef
 üü¢ com.atproto.moderation.defs
 üü¢ com.atproto.moderation.createReport
 üü¢ app.bsky.actor.profile
```

You can also create a new Lexicon record with `goat lex new record`:

```markdown
$ goat lex new record dev.project.thing

$ open ./lexicons/dev/project/thing.json
```

And eventually publish it with `goat lex publish`:

```markdown
$ goat lex publish
 üü¢ dev.project.thing
```

Refer to the [Lexicon Style Guide](/guides/lexicon-style-guide) for guidance on creating new Lexicons.

## Lexhub

Lexhub is our resource for discovering and browsing Lexicons!

## Further Reading and Resources

- [Lexicon Style Guide](/guides/lexicon-style-guide)
- [Lexcion Specs]](https://atproto.com/specs/lexicon)