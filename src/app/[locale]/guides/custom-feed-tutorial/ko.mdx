import {Container} from "@/components/Container"
import bsky from "./feeds-bsky.png"

export const header = {
  title: 'Write a Custom Feed',
  description: 'Host an algorithm that\'s accessible from apps like Bluesky.',
}

사용자 지정 피드 또는 피드 생성기는 사용자에게 알고리즘을 제공하는 서비스입니다. 이를 통해 타임라인 보기를 자유롭게 선택하거나 [다른 사용자를 위한 임베드 가능한 피드를 생성](https://graze.leaflet.pub/3m4yjmbnyec2c)할 수 있는 등 다양한 자유를 누릴 수 있습니다.
이 튜토리얼에서는 [파이어호스](http://localhost:3000/guides/streaming-data)에서 게시물을 가져와 알고리즘으로 정렬한 후 [XRPC 피드로 브로드캐스팅](/guides/feeds)하는 커스텀 피드 서버를 만들 것입니다.
## 필수 조건
이 튜토리얼은 TypeScript 애플리케이션을 처음부터 구축하는 과정을 다룹니다. TypeScript와 Node.js에 대한 실무 지식이 있어야 합니다.
다음이 설치되어 있어야 합니다:
- Node.js 18 이상
- Go 1.25 이상
[homebrew](https://brew.sh/)가 지원하는 플랫폼에서는 다음 명령어로 설치할 수 있습니다:
```bash
brew install node go
```
또한 `lex` CLI 도구를 전역으로 설치해야 합니다:
```bash
npm install -g @atproto/lex
```
네트워크의 게시물 파이프라인을 소비하려면 [`tap`](/guides/the-at-stack#tap)도 설치해야 합니다.
```bash
go install github.com/bluesky-social/indigo/cmd/tap
```
이제 새로운 Typescript 프로젝트 디렉터리를 생성하고 프로젝트를 초기화하세요:
```bash
mkdir my-agent
cd my-agent
npm init -y
npm i -D typescript ts-node @types/node dotenv @atproto/lex @atproto/lex-server @atproto/tap
npx tsc --init --verbatimModuleSyntax false
```
프로젝트에 Lexicons를 추가하는 것으로 시작합니다.
## 파트 1: Lexicons와 Tap
[Lexicons](/guides/lexicon)는 Atproto 레코드를 정의합니다. 기본 피드 생성기에는 `app.bsky.feed.describeFeedGenerator` 및 `app.bsky.feed.getFeedSkeleton` Lexicons가 필요합니다. `lex`를 사용하여 이러한 레크시콘을 다운로드하고 프로젝트에 빌드할 수 있습니다:
```bash
lex install app.bsky.feed.describeFeedGenerator app.bsky.feed.getFeedSkeleton
```
여기서 `lex build`를 실행하여 설치된 모든 레크시콘에 대한 TypeScript 타입을 생성할 수 있습니다:
```bash
lex build
```
생성된 코드는 `src/lexicons`에 위치합니다.
네트워크의 게시물을 색인화하려면 별도의 터미널에서 `tap`을 실행해야 합니다. `tap`을 다음과 같이 시작하세요:
```bash
tap run --disable-acks=true
```
이제 피드 생성기 구축을 시작할 수 있습니다.
## 파트 2: 피드 구조
사용자에게 맞춤형 알고리즘을 제공하는 일반적인 흐름은 다음과 같습니다:
- 사용자가 애플리케이션 백엔드(예: Bluesky)에 피드를 요청합니다. (예: Bluesky)
- 애플리케이션은 요청된 피드의 호스팅 서버를 조회하기 위해 해당 피드의 DID 문서를 찾습니다
- 애플리케이션은 호스팅 서버에 `getFeedSkeleton` 요청을 보냅니다
- 피드의 호스팅 서버는 게시물 URL 목록을 반환합니다
- 애플리케이션은 피드를 활성화합니다(사용자 정보, 게시물 내용, 집계 정보 등)
- 애플리케이션이 생성된 피드를 사용자에게 반환
환경 변수에서 일부 구성을 가져오는 것으로 시작합니다. 대부분은 게시된 피드에 대한 구성(`FEED_PUBLISHER_DID`, `FEED_NAME`)이지만 일부 세부 사항은 피드의 동작 방식을 설정합니다(`FEED_MAX_POSTS`, `SEARCH_TERMS`) .
이 예제에서는 `src/index.ts` 단일 파일로 전체 애플리케이션을 구현합니다. 해당 파일을 생성한 후 다음 임포트 및 구성 라인을 추가하세요:
```ts
import { AtUriString, DidString, asDidString } from '@atproto/lex'
import { LexError, LexRouter, serviceAuth } from '@atproto/lex-server'
import { serve } from '@atproto/lex-server/nodejs'
import { Tap, SimpleIndexer } from '@atproto/tap'
import * as app from './lexicons/app.js'
// =============================================================================
// 구성
// =============================================================================
interface FeedConfig {
    publisherDid: DidString
    
feedName: string
    searchTerms: string[]
    maxPosts: number
    port: number
    tapUrl: string
    tapPassword: string
    initialRepos: string[]
}
const DEFAULT_REPO = 'did:plc:ragtjsm2j2vknwkz3zp4oxrd' // pfrazee.com
const config: FeedConfig = {
    
publisherDid: asDidString(process.env.FEED_PUBLISHER_DID || 'did:example:alice'),
    feedName: process.env.FEED_NAME || 'whats-alf',
    
searchTerms: (process.env.FEED_SEARCH_TERMS || 'alf').split(',').map(s => s.trim()),
    maxPosts: parseInt(process.env.FEED_MAX_POSTS || '1000', 10),
    
port: parseInt(process.env.FEED_PORT || '3000', 10),
    tapUrl: process.env.TAP_URL || 'http://localhost:2480',
    tapPassword: process.env.TAP_PASSWORD || 'secret',
    
initialRepos: (process.env.FEED_INITIAL_REPOS || DEFAULT_REPO).split(',').map(s => s.trim()),
}
const FEED_URI: AtUriString = `at://${config.publisherDid}/app.bsky.feed.generator/${config.feedName}` as AtUriString
```
여기서 몇 가지 주의할 점이 있습니다. `tap`으로 가져올 `DEFAULT_REPO`를 지정했습니다. 이 경우 단일 사용자 [`pfrazee.com`](https://bsky.app/profile/pfrazee.com)을 팔로우합니다. 이렇게 하면 튜토리얼 예제를 관리하기 쉽게 유지할 수 있습니다.
특정 용어가 포함된 게시물을 검색하여 이 피드를 정렬하고 있습니다. 이러한 용어는 `FEED_SEARCH_TERMS` 환경 변수로 구성할 수 있습니다. 이 예제에서는 “alf”를 언급한 게시물을 검색합니다.
다음으로, 파이어호스에서 게시물을 소비하는 로직을 설정할 것입니다.
## 파트 3: 파이어호스 소비
제공할 게시물을 배열에 저장합니다.
`tap`이 네트워크에서 게시물을 발견하면, 이 피드 서버는 설정된 검색어를 게시물 텍스트에서 검색합니다. 일치하는 게시물을 찾으면 해당 게시물을 배열에 추가합니다. `src/index.ts`에 다음 내용을 추가하세요:
```ts
// =============================================================================
// 게시물 인덱서
// =============================================================================
interface IndexedPost {
    uri: AtUriString
    indexedAt: number
}
const postIndex: IndexedPost[] = []
// =============================================================================
// Tap 인덱서
// =============================================================================
const tap = new Tap(config.tapUrl, { adminPassword: config.tapPassword })
const indexer = new SimpleIndexer()
const searchPattern = new RegExp(
    `\\b(${config.searchTerms.map(t => t.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|')})\\b`,
    'i'
)
indexer.record(async (evt) => {
    
if (evt.collection !== 'app.bsky.feed.post') return
    const uri = `at://${evt.did}/${evt.collection}/${evt.rkey}` as AtUriString
    if (evt.action === 'delete') {
        
const idx = postIndex.findIndex(p => p.uri === uri)
        if (idx !== -1) {
            postIndex.splice(idx, 1)
            console.log(`DELETE ${uri}`)
        }
        return
    }
    const text = (evt.record?.text as string) || ''
    if (!searchPattern.test(text)) return
    
if (postIndex.some(p => p.uri === uri)) return
    postIndex.unshift({ uri, indexedAt: Date.now() })
    if (postIndex.length > config.maxPosts) postIndex.pop()
    const preview = text.substring(0, 60).replace(/\n/g, ' ')
    
console.log(`${evt.action.toUpperCase()} ${uri}`)
    console.log(`  “${preview}${text.length > 60 ? '...' : ''}”`)
    console.log(`  ⭐ 인덱스에 추가됨 (${postIndex.length} 총 개수)`)
})
indexer.identity(async (evt) => {
    if (evt.status === 'active') return
    // 비활성화/삭제된 아이덴티티에서 게시물 제거
    const removed = postIndex.filter(p => p.uri.includes(evt.did)).length
    if (removed > 0) {
        
postIndex.splice(0, postIndex.length, ...postIndex.filter(p => !p.uri.includes(evt.did)))        console.log(`Identity ${evt.did} (${evt.status}): removed ${removed} posts`)    }})indexer.error((err) => console.error('Indexer error:', err))const channel = tap.channel(indexer)```여기서 `tap`에 연결하고, `@atproto/tap` 라이브러리가 제공하는 `SimpleIndexer` 함수를 사용하여 `app.bsky.feed.post` 렉시콘(즉, Bluesky 게시물)에서 들어오는 레코드를 처리합니다.새로운 게시물이 발견되면, 그 텍스트가 검색어와 일치하는지 확인합니다. 일치하는 경우 `postIndex` 배열에 추가합니다. 인덱스의 정확성을 유지하기 위해 삭제 및 계정 상태 변경도 처리합니다.
본질적으로, 특정 기준에 부합하는 게시물의 인메모리 검색 인덱스를 구축하는 것입니다. 이후 이 인덱스를 피드로 제공하게 됩니다.
## 파트 4: 피드 제공
이제 피드를 제공하기 위해 [XRPC](/guides/lexicon#http-api-methods) 경로를 추가합니다. 서버는 두 종류의 요청을 처리하게 됩니다:
```
GET /xrpc/app.bsky.feed.describeFeedGenerator
GET /xrpc/app.bsky.feed.getFeedSkeleton
```
`src/index.ts`에 피드 생성기 서버 로직을 추가하세요:
```ts
// =============================================================================
// 피드 생성기 서버
// =============================================================================
// 요청자의 DID만 기록하므로 이 데모에서는 인증이 선택 사항입니다.
// 실제 운영 환경에서는 피드를 개인화하기 위해 자격 증명을 사용할 수 있습니다.
const auth = serviceAuth({
    audience: config.publisherDid,
    unique: async () => true,
})
const router = new LexRouter()
router.add(app.bsky.feed.describeFeedGenerator, {
    auth,
    handler: (ctx) => {
        console.log('describeFeedGenerator from', ctx.credentials?.did)
        
return {
            body: {
                did: config.publisherDid,
                feeds: [app.bsky.feed.describeFeedGenerator.feed.$build({ uri: FEED_URI })],
                links: {
                    privacyPolicy: 'https://example.com/privacy',
                    termsOfService: 'https://example.com/tos',
                
},
            },
        }
    },
})
router.add(app.bsky.feed.getFeedSkeleton, {
    auth,
    handler: (ctx) => {
        if (ctx.params.feed !== FEED_URI) {
            throw new LexError('InvalidRequest', 'Feed not found')
        }
        console.log('getFeedSkeleton from', ctx.credentials?.did)
        
const limit = Math.min(ctx.params.limit ?? 50, 100)
        const cursor = ctx.params.cursor as string | undefined
        let startIdx = 0
        if (cursor) {
            const cursorTime = parseInt(cursor, 10)
            startIdx = postIndex.findIndex (p => p.indexedAt < cursorTime)
            if (startIdx === -1) startIdx = postIndex.length
        }
        const slice = postIndex.slice(startIdx, startIdx + limit)
        const feed = slice.map(p => app.bsky.feed.defs.skeletonFeedPost.$build({ post: p.uri }))
        
const lastPost = slice.at(-1)
        const nextCursor = lastPost && slice.length === limit && startIdx + limit < postIndex.length
            ? lastPost.indexedAt.toString()
            : undefined
        return { body: { feed, cursor: nextCursor } }
    },
})
```
여기서는 `@atproto/lex-server` 패키지의 `LexRouter`를 사용해 XRPC 경로를 정의하고 있습니다. `getFeedSkeleton` 메서드가 응답으로 `cursor`를 반환하고 입력으로 `cursor` 매개변수를 받는 것을 확인할 수 있습니다. 이를 통해 클라이언트가 피드를 페이지 단위로 탐색할 수 있습니다.
<Note>
이 커서는 불투명한 값으로 취급되며, 완전히 피드 생성자의 재량에 따릅니다. 이 커서는 AppView를 통해 클라이언트와 직접 주고받습니다. 페이지 매김 시 예상치 못한 동작을 방지하기 위해 커서는 _피드 항목마다 고유해야_ 합니다. 예를 들어, 타임스탬프 + CID로 구성된 복합 커서:
`1683654690921::bafyreia3tbsfxe3cc75xrxyyn6qc42oupi73fxiox76prlyi5bpx7hr72u`
</Note>
마지막으로 서버를 시작하는 런타임 로직을 추가합니다.
## 파트 5: 서버 실행
`channel.start()`로 tap에 연결한 후 서버를 시작합니다. `src/index.ts`에 런타임 로직을 추가하세요:
```ts
// =============================================================================
// 시작
// =============================================================================
channel.start()
console.log('인덱서가 Tap 서버에 연결됨')
if (config.initialRepos.length > 0) {
    tap.addRepos(config.initialRepos).then(() => {
        console.log(`추적할 저장소 ${config.initialRepos.length}개 추가됨\n`)
    })
}
serve(router, { port: config.port }).then((server) => {
    
const feedParam = encodeURIComponent(FEED_URI)
    console.log(`
피드 생성기 실행 중
서버: http://localhost:${config.port}
피드: ${config.feedName}
검색어: ${config.searchTerms.join(', ')}
탭: ${config.tapUrl}
리포지토리: ${config.initialRepos.length}
테스트하기 (goat로 JWT 생성):
goat account service-auth --aud ${config.publisherDid}
그런 다음:
curl -H “Authorization: Bearer <jwt>” “http://localhost:${config.port}/xrpc/app.bsky.feed.getFeedSkeleton?feed=${feedParam}”
게시물 수신 대기: ${config.searchTerms.join(', ')}
`)
    const shutdown = async () => {
        console.log('종료 중...')
        await channel.destroy()
        await server.terminate()
        process.exit(0)
    }
    
process.on('SIGINT', shutdown)
    process.on('SIGTERM', shutdown)
})
```
이 코드는 `tap`(피드 입력)과 XRPC 서버(피드 출력)에 대한 연결을 모두 시작합니다. 또한 피드 생성기 테스트를 돕기 위한 일부 로깅을 제공합니다.
`ts-node src/index.ts`로 실행하세요. 초기 게시물이 색인되는 것을 확인할 수 있습니다:
```
인덱서가 Tap 서버에 연결됨
피드 생성기 실행 중
서버: http://localhost:3000
피드: whats-alf
용어: alf
Tap: http://localhost:2480
저장소: 1
테스트 방법 (goat로 JWT 생성):
goat account service-auth --aud did:example:alice
그런 다음:
curl -H “Authorization: Bearer <jwt>” “http://localhost:3000/xrpc/app.bsky.feed.getFeedSkeleton?feed=at%3A%2F%2Fdid%3Aexample%3Aalice%2Fapp.bsky.feed.generator%2Fwhats-alf”
alf와 일치하는 게시물 수신 대기 중
추적할 저장소 1개 추가됨
CREATE at://did:plc:ragtjsm2j2vknwkz3zp4oxrd/app.bsky.feed.post/3jux6xlrdb42v
  “실행?? 알프는 내가 실패한 날이었어 ☹️”
  ⭐ 인덱스에 추가됨 (총 1개)
CREATE at://did:plc:ragtjsm2j2vknwkz3zp4oxrd/app.bsky.feed.post/3jux7x2uvip2v
  “세상에, 괜찮은 거야? 지금 정말 혼란스러워, 알프가 나를...”
  ⭐ 인덱스에 추가됨 (총 2개)
```
<Note>
이 예제는 단일 사용자의 데이터 저장소만 가져옵니다. 전체 네트워크를 가져오려면 `tap`을 중지하고 `--signal-collection` 플래그를 추가하여 재실행하세요:
```bash
tap run --collection-filters=app.bsky.feed.post \
  --signal-collection=app.bsky.feed.post
```
</Note>
## 결론
이제 네트워크에서 게시물을 가져와 자체 알고리즘으로 색인화하고, Bluesky 같은 클라이언트에 XRPC로 제공하는 맞춤형 Atproto 피드를 구축했습니다.
이제 피드 서버가 실행 중이니 추가로 커스터마이징한 후 다른 사용자가 이용할 수 있도록 공개하세요. 이를 위해 AWS, DigitalOcean 등과 같은 공개 서버에 배포하고 HTTPS로 접근 가능하도록 설정해야 합니다.
이후, 저희의 원본 [feed-generator 저장소](https://github.com/bluesky-social/feed-generator)를 복제하고 [publishFeedGen.ts](https://github.com/bluesky-social/feed-generator/blob/main/scripts/publishFeedGen.ts) 스크립트를 대화형으로 실행하세요. 이렇게 하면 피드 서버를 가리키고 검색 가능하게 하는 데 필요한 Atproto 레코드가 생성됩니다:
<Container>
  <Image src={bsky} alt="" className="w-full max-w-md mx-auto" />
</Container>
더 많은 가이드와 튜토리얼은 [가이드](/guides) 섹션에서, 추가 예제 앱은 [쿡북](https://github.com/bluesky-social/cookbook/) 저장소에서 확인하실 수 있습니다. 즐거운 개발 되세요!