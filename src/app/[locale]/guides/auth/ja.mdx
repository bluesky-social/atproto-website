import {Container} from "@/components/Container"
import {Heading} from "@/components/Heading"

export const header = {
  title: '認証',
  description: 'Atprotoアプリケーション開発者向けの認証・認可ガイド',
}

<Heading level={2} id="getting-started">はじめましょう</Heading>

<TabGroup defaultValue="ts">
  <TabList>
    <Tab value="ts">TypeScript</Tab>
    <Tab value="go">Go</Tab>
  </TabList>
  <TabPanels>
    <TabPanel value="ts">
    任意の[OAuth](/guides/auth)プロバイダでログインできます。SDKの[PasswordSession](https://github.com/bluesky-social/atproto/tree/main/packages/lex/lex-password-session)でパスワード認証もできます。

    まずAtprotoパッケージをインストールしてください。

    ```bash
    npm install @atproto/lex @atproto/lex-password-session
    ```
    </TabPanel>
    <TabPanel value="go">
    任意の[OAuth](/guides/auth)プロバイダでログインすることもできますし、SDKのパスワード認証を使用することもできます。

    まずAtprotoパッケージをインストールしてください。

    ```bash
    go get github.com/bluesky-social/indigo
    ```
    </TabPanel>
  </TabPanels>
</TabGroup>

続いて、[SDK](/guides/sdk-auth)を使って認証します。

<Heading level={2} id="about-authorization">認証について</Heading>

**認証が最初のドキュメントであることには理由があります**。[レコードを読み出す](/reading-data#unauthenticated-reads)ために認証が必要というわけではありませんし、[firehoseからデータをストリーム](/guides/streaming-data)する場合も同じです。ただしAtmosphereに統合されるアプリケーションを構築する場合は、認証から始めることになります。

最初はAtprotoのIDをOAuthソースとして使うだけかもしれませんが、Atprotoの[ソーシャルグラフ](/guides/social-graph)上でさらに多くのことができることに気付くでしょう。

このセクションはAtprotoでアプリケーションを構築している開発者を対象としています。独自のログインフローを持つアプリケーションは認証に[OAuth](#what-is-oauth)を実装すべきです。ボットやコマンドラインツールなどの単一目的のアプリケーションは[パスワード認証](/guides/sdk-auth)を使うこともできます。

<Note>
私たちは[アプリパスワード](/specs/xrpc#app-passwords)の使用もサポートしています。アカウントは主パスワードとは別にアプリパスワードの作成・取消しができます。これにより、パスワード認証を使うアプリケーションに主パスワードを渡す必要がありません。
</Note>

アプリケーションにOAuthを実装するには、一般的なユースケースについては[OAuthパターン](/guides/oauth-patterns)を、権限モデルの理解については[スコープガイド](/guides/scopes)を参照してください。独自のプロトコル実装またはOAuthクライアアントSDKを構築している場合は、[OAuth仕様](/specs/oauth)を参照してください。

<Heading level={2} id="what-is-oauth">OAuthとは？</Heading>

OAuthは、ユーザーがパスワードを渡すことなく、開発者がアカウントへのアクセスをリクエストできるようにする認可フレームワークです。OAuthがなければ、サードパーティアプリケーションにアカウントへのアクセスを許可したい場合、ユーザー名とパスワードをそのアプリケーションに入力するしかありません。これはさまざまな理由で問題があり、一番の理由はサードパーティアプリケーションがパスワードを見て、ともすれば保存してしまうという点です。アプリケーションがユーザー名とパスワードを持つと、アプリケーションはアカウントへの*完全な*アクセスを持つことになります。

OAuthはこれらの問題を、個人のユーザー名とパスワードを必要とせずに安全な認可を管理するオープン仕様群によって解決することを目指しています。ウェブ上で「…でサインイン」ボタンやリンクを使用したことがあれば、OAuthを使用したことがあるということです。

開発者からすると、個人のアカウントへの限定的なアクセスをリクエストできます。つまり、誰かのパブリックタイムラインにメッセージを投稿するだけでよい場合、プライベートメッセージの閲覧まで要求する必要はありません。これはあなたのアプリケーションにとって素晴らしいことです。なぜなら、必要のないデータを管理することについて心配する必要がないからです。また、あなたのアプリケーションを使う人にとっても素晴らしいことです。なぜなら、DMが漏洩することについて心配する必要がないからです。

<Heading level={2} id="how-is-oauth-different-in-at-protocol">ATプロトコルのOAuthは何が違う？</Heading>

Atprotoは[OAuth仕様](/specs/oauth)でOAuth標準の特定のプロファイルを指定し、[OAuth 2.1](https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-13.html)を基礎としています。

他のOAuthシステムを使っている場合は細かい部分で意外に感じるかもしれません。

- **Atprotoは分散しています**：通常、アプリに「…でサインイン」ボタンがある場合、ユーザーの認証を許可する権限を選択できます（大抵は少数の大企業のどれか）。AtprotoのOAuthでは、アプリは認証プロバイダー、つまりユーザーの[PDS](/guides/the-at-stack#pds)との事前の関係がありません。これは、AtprotoのOAuthが、事前に確立された関係を必要とするOIDCと互換性がない理由でもあります。

- **移行**：ATプロトコルユーザーはアカウントをサーバー（[PDS](/guides/glossary#pds-personal-data-server)）間で移行できます。これを促進するため、ATプロトコルは柔軟な[ID](/guides/identity)レイヤーを持っており、ユーザー名（[ハンドル](/specs/handle)）を不変のユーザーID（[DID](/specs/did)）に解決でき、さらにそれを解決してユーザーのPDSを見つけることができます。ユーザーがアプリケーションにログインすると、OAuthクライアントはこれらの関係を動的に解決します。

- **クライアントID**：他のOAuthエコシステムでは、クライアントアプリケーションがリソースサーバーに事前登録が必要なことがよくあります。これは分散型システム（多数のクライアントと多数のリソースサーバーがある）では実行できないため、Atprotoは[Client ID Metadata Documents](/specs/oauth#client-id-metadata-document)を使用してこれに対処しています。

<Heading level={2} id="further-reading-and-resources">関連・参考資料</Heading>

まずは[SDKによる認証](/guides/sdk-auth)を読んでください。アプリケーションにOAuthを実装するには、一般的なユースケースについては[OAuthパターン](/guides/oauth-patterns)を、権限モデルを理解するには[スコープガイド](/guides/scopes)を参照してください。

- [SDKによる認証](/guides/sdk-auth)
- [OAuthパターン](/guides/oauth-patterns)
- [スコープ](/guides/scopes)
- [権限リクエスト](/guides/permission-sets)
- [OAuth仕様](/specs/oauth)
- [権限仕様](/specs/permission)
