import {DescriptionList, Description} from '@/components/DescriptionList'
import {Heading} from '@/components/Heading'

export const header = {
  title: 'Identity',
  description:
    'ATプロトコルがユーザーIDを処理する方法',
}

AtprotoのIDシステムには、いくつかの要件があります。

* **IDプロビジョニング**。ユーザーは、サービス間で安定したグローバルIDを作成できる必要があります。これらのIDは、コンテンツへのリンクが安定していることを保証するために、不変である必要があります。
* **公開鍵の配布**。分散システムは、データの信頼性を証明し、エンドツーエンドのプライバシーを提供するために暗号化に依存しています。IDシステムは、強力なセキュリティで公開鍵を公開する必要があります。
* **鍵のローテーション**。ユーザーは、IDを中断することなく鍵マテリアルをローテーションできる必要があります。
* **サービスの検出**。ユーザーと対話するには、アプリケーションは、特定のユーザーが使用しているサービスを検出できる必要があります。
* **使いやすさ**。ユーザーの名前は、人間が読みやすく、覚えやすいものにする必要があります。
* **移植性**。IDはサービス間で移植可能である必要があります。プロバイダーを変更しても、ユーザーがID、ソーシャルグラフ、またはコンテンツを失うことはありません。

atprotoのIDシステムを採用すると、エンドツーエンドの暗号化、署名されたユーザーデータ、サービスサインイン、および一般的な相互運用のためのツールがアプリケーションに提供されるはずです。

<Heading level={2} id="identifiers">識別子</Heading>

私たちは、*ハンドル*と*DID*という2つの相互に関連する識別子形式を使用します。ハンドルはDNS名ですが、DIDは安全で安定したIDとして機能する[新しいW3C標準](https://www.w3.org/TR/did-core/)です。ATプロトコルはDID PLCとDID Webの2種類に対応しています。

以下はすべて有効なユーザー識別子です。

```
alice.host.com
at://alice.host.com
did:plc:bv6ggog3tya2z3vxsub7hnal
```

これらの関係は次のように視覚化できます。

```
┌──────────────────┐                 ┌───────────────┐
│ DNS name         ├──resolves to──→ │ DID           │
│ (alice.host.com) │                 │ (did:plc:...) │
└──────────────────┘                 └─────┬─────────┘
       ↑                                   │
       │                               resolves to
       │                                   │
       │                                   ↓
       │                            ┌───────────────┐
       └───────────references───────┤ DID Document  │
                                    │ {"id":"..."}  │
                                    └───────────────┘
```

DNSハンドルはユーザー向けの識別子です。UIに表示され、ユーザーを見つける方法として宣伝される必要があります。アプリケーションはハンドルをDIDに解決し、DIDを安定した正規の識別子として使用します。その後、DIDは公開鍵とユーザーサービスを含むDIDドキュメントに安全に解決できます。

<DescriptionList>
  <Description title="ハンドル">ハンドルはDNS名です。これらはDNS TXTレコードかHTTP well-knownエンドポイントを使用して解決され、DIDドキュメント内の一致するエントリによって確認される必要があります。詳細は<a href="/specs/handle">ハンドル仕様</a>をご覧ください。</Description>
  <Description title="DID">DIDは、安定した安全なIDを提供する<a href="https://www.w3.org/TR/did-core/">W3C標準</a>です。これは、ユーザーの安定した正規IDとして使用されます。ATプロトコルでの使用方法の詳細については、<a href="/specs/did">DID仕様</a>をご覧ください。</Description>
  <Description title="DIDドキュメント">
    DIDドキュメントは標準化されたJSONオブジェクトで、DID解決プロセスによって取得されます。これには次の情報が含まれます。
    <ul>
      <li>DIDに関連付けられたハンドル</li>
      <li>署名鍵</li>
      <li>ユーザーのPDSのURL</li>
    </ul>
  </Description>
</DescriptionList>


<Heading level={2} id="did-methods">DIDメソッド</Heading>

[DID標準](https://www.w3.org/TR/did-core/)は、DIDを公開し、[DIDドキュメント](https://www.w3.org/TR/did-core/#core-properties)に解決する「メソッド」を、ただ一つに定めず多様に定義できるフレームワークを設けています。さまざまな既存のメソッドが[公開](https://w3c.github.io/did-spec-registries/#did-methods)されおり、それぞれ異なる機能や特徴を持ちます。Atprotoでの使用に際して、以下の基準を設定しました。

- **強い一貫性**。特定のDIDに対して、解決クエリによって生成される有効なドキュメントは常に1つだけである必要があります。（一部のネットワークでは、これは確率的なトランザクションの最終性に左右される可能性があります。）
- **高可用性**。解決クエリは確実に成功する必要があります。
- **オンラインAPI**。クライアントは、標準APIを介して新しいDIDドキュメントを公開できる必要があります。
- **安全**。ネットワークは、オペレーター、MITM、およびその他のユーザーからの攻撃から保護する必要があります。
- **低コスト**。DIDドキュメントの作成と更新は、サービスとユーザーにとって手頃な価格である必要があります。
- **鍵ローテーション**。ユーザーは、IDを失うことなく鍵ペアをローテーションできる必要があります。
- **分散型ガバナンス**。ネットワークは単一の利害関係者によって管理されるべきではなく、オープンネットワークまたはプロバイダーのコンソーシアムである必要があります。

プロジェクト開始時点で、DIDメソッドのいずれもこれらの基準を完全には満たしていませんでした。そのため、私たちは[did-web](https://w3c-ccg.github.io/did-method-web/)と、私たちが作成した[DID PLC](https://github.com/bluesky-social/did-method-plc)という新規メソッドをサポートすることを選択しました。

<Heading level={2} id="handle-resolution">ハンドル解決</Heading>

Atprotoのハンドルは、DIDに解決されるドメイン名です。DIDは、ユーザーの署名公開鍵とホスティングサービスを含むDIDドキュメントに解決されます。

ハンドル解決には、DNSのTXTレコードか、HTTPSのwell-knownエンドポイントを利用します。詳細は[ハンドル仕様](/specs/handle)を参照してください。


<Heading level={3} id="example-hosting-service">例：ホスティングサービス</Heading>

ホスティングサービスがPLCを使用していて、ユーザーのハンドルをサブドメインとして提供しているシナリオを考えてみましょう。

- ハンドル：`alice.pds.com`
- DID：`did:plc:12345`
- ホスティングサービス：`https://pds.com`

まず、わかっているのは`alice.pds.com`なので、`_atproto.alice.pds.com`のDNS TXTレコードを見てみます。これにより、DIDが`did:plc:12345`であるとわかります。

次に、返されたDIDでPLCディレクトリに問い合わせ、ホスティングサービスのエンドポイントとユーザーの鍵マテリアルを確認します。

```typescript
await didPlc.resolve('did:plc:12345') /* => {
  id: 'did:plc:12345',
  alsoKnownAs: `https://alice.pds.com`,
  verificationMethod: [...],
  service: [{serviceEndpoint: 'https://pds.com', ...}]
}*/
```

これで、`https://pds.com`と通信してAliceのデータにアクセスできるようになりました。

<Heading level={3} id="example-self-hosting">例：セルフホスト</Heading>

セルフホストのシナリオを考えてみましょう。`did:plc`を使用している場合は、次のようになります。

- ハンドル：`alice.com`
- DID：`did:plc:12345`
- ホスティングサービス：`https://alice.com`

ただし、**セルフホストする人がドメイン名の所有権を保持し続けられると確信している場合**、`did:plc`ではなく`did:web`を使用できます。

- ハンドル：`alice.com`
- DID：`did:web:alice.com`
- ホスティングサービス：`https://alice.com`

解決方法は同じく`_atproto.alice.com`で、DIDとして`did:web:alice.com`が得られます。

これを解決すると以下のようになります。

```typescript
await didWeb.resolve('did:web:alice.com') /* => {
  id: 'did:web:alice.com',
  alsoKnownAs: `https://alice.com`,
  verificationMethod: [...],
  service: [{serviceEndpoint: 'https://alice.com', ...}]
}*/
```
