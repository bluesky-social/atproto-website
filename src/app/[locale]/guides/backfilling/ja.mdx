import {Heading} from '@/components/Heading'

export const header = {
  title: 'バックフィル',
  description: 'ネットワークを複製する',
}

<Heading level={2} id="about-backfilling">バックフィルとは</Heading>

バックフィルは、ネットワーク内のすべてのデータをゼロから同期する処理です。ネットワーク内の全データの完全なコピーが必要なサービスを動かすなら、これを行いたい場合があるでしょう。フィードジェネレーター、ラベラー、またはボットを実行する場合、大抵はfirehoseからのライブデータだけで十分なため、これは一般に必要ありません。ただし、大規模なデータ分析を実行したい場合は、バックフィリングに関心を持つかもしれません。

ネットワーク全体が第三者によってバックフィル可能であることは、ATの画期的なコンセプトです。他のモノリシックなソーシャルネットワークは、一般にその時点からの大規模なイベントストリーム（firehoseのようなもの）のみを提供するため、追加のデータベンダーなしで縦断的なデータ分析を実行することが困難です。ATプロトコルと十分なリソースがあれば、*いつでも*ネットワーク全体を自分でバックフィルできます。これはさらに研究者やその他のデータ分析に利益をもたらします。十分なストレージを用意できれば、Atmosphere全体の独自のローカルコピーを持つことができます。

バックフィルを行うのは、一般にデータの最新レプリカを維持する必要がある場合なので、バックフィルが完了したらfirehoseデータのストリーミングへの切り替えが必要です。このプロセスを簡素化するために`tap`を作成しました。

<Heading level={2} id="using-tap">tapの利用</Heading>

`tap`はfirehose接続、検証、バックフィル、フィルタリングを処理することでAT同期を簡素化します。アプリケーションはTapに接続し、あなたが関心のあるリポジトリとコレクションのみのシンプルなJSONイベントを受け取ります。署名検証のためのバイナリ形式について心配する必要はありません。

Tapはコマンドラインから実行できます。

```shell
# tapを実行する
go run ./cmd/tap run --disable-acks=true
# デフォルトでは、サービスは`./tap.db`のSQLiteと`:2480`ポートを使用します。

# 別のターミナルでイベントを受け取るために接続
websocat ws://localhost:2480/channel

# リポジトリを追跡対象に追加
curl -X POST http://localhost:2480/repos/add \
  -H "Content-Type: application/json" \
  -d '{"dids": ["did:plc:ewvi7nxzyoun6zhxrhs64oiz"]}' # @atproto.comのリポジトリ
```

リポジトリが追加されると、tapは以下を提供します。

1. 履歴バックフィル：Tapはcom.atproto.sync.getRepoを使用して、対象アカウントのPDSから完全なリポジトリをフェッチします。
2. ライブイベントバッファリング：バックフィル中のこのリポジトリのfirehoseイベントはメモリに保持されます。
3. 順序保証：履歴イベント（live: false）が先に配送されます。
4. 切り替え：履歴イベントが完了した後、バッファされたライブイベントが排出されます。
5. ライブストリーミング：新しいfirehoseイベント（live: true）が即座に配信されます。

Tapを使うための[TypeScriptライブラリ](https://www.npmjs.com/package/@atproto/tap)も提供しています。詳細については、[The AT Stack](/guides/the-at-stack#tap)および[tapリポジトリ](https://github.com/bluesky-social/indigo/tree/main/cmd/tap)を参照してください。

<Heading level={2} id="how-backfilling-works">バックフィルの仕組み</Heading>

バックフィルを自分で実装する場合、一般的なプロセスは次のとおりです。

- DIDが与えられた場合、そのDIDの現在のリビジョンを確認します（リポジトリへのすべての変更は、辞書順でソート可能なタイムスタンプである「rev」文字列でタグされます）。
- そのリポジトリのrevがない場合は、`com.atproto.sync.getRepo`エンドポイントからユーザーのリポジトリチェックポイントをダウンロードして処理します。
- その間、チェックポイント以降に通過するリポジトリイベントをバッファします。
- チェックポイントにはrevが含まれており、そのチェックポイントに既にあるイベントをバッファからスキップするのに使用できます。
- バッファされた各イベントについて、そのイベントのrevが現在のrevより小さい場合、安全にスキップできます。

各リポジトリに対して上記のプロセスを実行すると、ネットワークの完全なレプリカが得られます。すべてのリポジトリのリストを取得するには、リレーや各PDSで`com.atproto.sync.listRepos`エンドポイントを使用できます。

- これはかなり大量のデータ（執筆時点で数百GB）であり、リソースの点でやや要求が厳しいものになります。
- レート制限を受けないように注意してください。ユーザー毎に`getRepo`呼び出しを1回行うことになります。データをリクエストされるPDSまたはリレーのファイアウォールによってリクエストがブロックされるのを防ぐために、クライアント側のレート制限を実装することをお勧めします。

<Heading level={2} id="further-reading-and-resources">関連・参考資料</Heading>

- [同期](/guides/sync)
- [データストリーミング](/guides/streaming-data)
- [フィード](/guides/feeds)
- [リポジトリ仕様](/specs/repository)
- [イベントストリーム仕様](/specs/event-stream)
- [同期仕様](/specs/sync)
- [Microcosm](https://www.microcosm.blue/)コミュニティプロジェクトは、ローカルミラーリングなしでATレコードを大規模に操作するためのツールを保守しています。
