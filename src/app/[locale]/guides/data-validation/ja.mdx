import {Heading} from '@/components/Heading'

export const metadata = {
  title: 'データバリデーション',
  description:
    '推奨されるデータ制限とバリデーションに期待するもの',
}

# データ検証

一部のソフトウェアはBlueskyやatprotoのスキーマ検証についてあまり心配する必要はありません。例えば、クライアントアプリやボットは通常、Bluesky APIから受け取るデータが正しいと見なすことができ、レコードの作成時にはPDSがスキーマ検証を二重チェックする責任があります。

イベントストリーム（firehose）から直接データを消費するソフトウェアはもう少し慎重である必要があります。新しいツールやイカしたハックを設計する開発者は、データバリデーションに関するいくつかの期待と制限を認識すべきです。

個別のレコードが何らかの理由でバリデーションに失敗した場合、レコード全体は無視されるべきですが、同じリポジトリの他のレコードは処理される必要があります。リポジトリのコミットデータまたはリポジトリ構造（MST）に問題がある場合、リポジトリは無効としてマークされるべきですが、古いコンテンツはインデックスからの除外や削除をする必要はありません。新しい有効なコミットが受け取られたら、リポジトリはすぐに有効としてマークされます。このロジックはフィードジェネレーター、AppView、およびモデレーションサービスといったfirehose利用者に主に関連しています。


<Heading level={2} id="recommended-data-limits">推奨データ制限</Heading>

以下は非公式なガイドラインであり、主に大まかな期待を伝えるためのものであり、時間の経過とともに進化する可能性があります。これらはatproto仕様の一部ではありませんが、この制限を超えている場合、現在または将来の相互運用性の問題に遭遇する可能性があります。

**CBORレコードサイズ：**個別のレコードを数十キロバイト程度に抑えるようにしてください。テキストデータを含め、より大きなデータを保存する必要がある場合は、代わりにblobの使用を検討してください。合理的な最大レコードサイズ制限（`MAX_CBOR_RECORD_SIZE`）は1 MiByte（1メビバイト、または1,048,576バイト）です。2025年8月の時点では、`subscribeRepos`のLexiconは`#commit`メッセージブロックサイズを2,000,000バイト（メビバイトではない）に制限しているため、コミットごとに1 MiByteレコードは1つだけ作成または更新できます。

イベントストリーム（firehose）の"フレーム"は複数のレコードで構成される可能性があり、一般的なCBOR解析には4～5MBytes程度のより大きな制限が推奨されます。

**JSONレコードサイズ：**CBORエンコーディングはレコードの正規形であるため、そのエンコーディングのみに焦点を当てることは理にかなっています。ただし、JSONエンコーディングのサイズに制限を設けることが良い場合もあります。合理的な制限（`MAX_JSON_RECORD_SIZE`）は2 MiByte（2,097,152バイト）です。

**一般的な文字列長：**Lexiconによる文字列長指定の有無を問わない、レコード内の文字列全般に対する長さ制限。バイト（UTF-8エンコード）で測定されます。これらは最大でも数十キロバイト程度に保つようにしてください。上限（`MAX_RECORD_STRING_LEN`）については、全体的なCBORレコードサイズ制限に従うのが妥当でしょう。なお、初期の一部実装では8キロバイト（8192バイト）の制限を持っていました。

**一般的な`bytes`長：**文字列制限と同じですが、バイナリデータ（`MAX_RECORD_BYTES_LEN`）の場合。CBORレコード全体のサイズ制限に従うことをお勧めします。レコードサイズと同様に、数十キロバイト以上が必要な場合、推奨はblobを使用することです。

**CIDバイナリエンコーディングサイズ：**全体で100バイトの制限（`MAX_CID_BYTES`）を推奨します。

**コンテナネストの深さ：**例えば、配列内の配列内のマップが何層あるかなど。CBORまたはJSONパースライブラリが制限をサポートしている場合、おそらくデフォルトで問題ありません。合理的な制限（`MAX_CBOR_NESTED_LEVELS`）は32レベルのネストです。

**コンテナ要素数：**例えば、マップ内のキーの数、または配列内の要素の数。CBORまたはJSONパースライブラリが制限をサポートしている場合、おそらくデフォルトで問題ありません。合理的な制限（`MAX_CBOR_CONTAINER_LEN`）は128 x 1024 = 131,072要素です。

**オブジェクトキー文字列長：**例えば、オブジェクトのキーで許可されるバイト数（UTF-8エンコード）。CBORまたはJSONパーシングライブラリが制限をサポートしている場合、おそらくデフォルトで問題ありません。合理的な制限（`MAX_CBOR_OBJECT_KEY_LEN`）は8キロバイト（8192）です。

**整数：**[atproto仕様](https://atproto.com/specs/data-model#data-types)で述べられているように、整数値を"64ビットフロートセーフ"に保つこと、つまり53ビットの精度に制限することは強く推奨されるベストプラクティスです。これにより、精度の損失なくJavaScriptとの互換性が保証されます。具体的な値としては`MAX_SAFE_INTEGER: 9007199254740991`および`MIN_SAFE_INTEGER: -9007199254740991`です。


<Heading level={2} id="validation-without-schema">スキーマ無しのバリデーション</Heading>

[atprotoのLexiconシステム](https://atproto.com/specs/lexicon)は、既知のスキーマに対してデータを検証するためのデータモデルとスキーマ言語について説明しています。しかし、スキーマが不明または存在しないデータを処理している場合はどうでしょうか？

以下は、データ型別のガイドラインです。

- `integer`：制限内の値を持つべきです（制限セクションで説明）
- `string`：有効なUTF-8エンコーディングである必要があります。特定のUnicode正規化は期待も要求もされません。空の文字列は許可されていますが、可能であればnullableまたはオプションフィールドを活用することが推奨されます。
- `bytes`：空（長さ0）を許します
- `cid-link`：プロトコル仕様で説明されている通りです。CIDv1である必要があります。multibaseではCBORエンコーディングはraw（type `0x00`）です。multicodecは`dag-cbor`（`0x71`）または`raw`（`0x55`）である必要があります。multihashはSHA-256が推奨されています（ただし厳密には必須ではありません）。
- `array`：Lexiconの共用体が提供する柔軟性のため、型が異なる要素を持つ可能性があります。
- `object`：キーはすべて文字列である必要があり、`string`フィールドと同様の要件に従います。空のキー文字列は許可されていません。`$`で始まるキー名はプロトコル使用のために予約されています（例えば、`$bytes`および`$type`）
- `blob`：`ref`は有効な`cid-link`である必要があり、`raw` multicodec（`dag-cbor`ではない）を持つ必要があります。`size`は負の値であってはいけません。`mimeType`は空の文字列であってはいけません。レガシーblob形式は読み取りでサポートされるべきですが、作成される新しいレコードは通常のblob形式である必要があります。追加の参照形式（例えば、別のmulticodecまたはハッシュタイプ）をサポートすることは、将来のプロトコルの進化と拡張の可能性としてありえますが、現在のバージョンではリポジトリとデータモデルは狭く定義されています。


