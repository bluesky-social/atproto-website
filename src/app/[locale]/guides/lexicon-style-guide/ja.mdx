import {Heading} from '@/components/Heading'

export const header = {
  title: 'Lexiconスタイルガイド',
  description:
    'ATプロトコルのLexicon作成のためのスタイルガイド',
}

<Heading level={2} id="overview">概要</Heading>

Lexiconスキーマの設計に関する推奨される慣例とベストプラクティスを紹介します。

名前の大文字小文字の慣例

- スキーマと属性：スキーマと名前には`lowerCamelCase`を使用してください（`UpperCamelCase`、`snake_case`、`ALL_CAPS`などではなく）。
- APIエラー名：`UpperCamelCase`
- 文字列定数（例：`knownValues`）：`kebab-case`

許可される文字

- フィールド名はスキーマ名（NSIDの名前セグメント）と同じ文字セットに従う必要があります。すなわち、ASCII英数字、最初の文字は数字ではない、ハイフンなし、大文字小文字を区別
    - 既存の外部スキーマの名前を保持する場合など、例外が正当化されることもあります
    - データオブジェクトはネストのいかなるレベルでも`$`で始まるフィールド名を含むようなスキーマを指定してはいけません。これらは将来のプロトコルレベルの拡張用に予約されています。

<Heading level={2} id="naming-conventions">命名規則</Heading>

- `record`スキーマには単数形の名詞を使用してください
    - 例：`post`、`like`、`profile`
- `query`と`procedure`エンドポイントには動詞と名詞を使用してください
    - 例：`getPost`、`listLikes`、`putProfile`
    - `query`エンドポイントの一般的な動詞：`get`、`list`、`search`（全文検索用）、`query`（柔軟なマッチングやフィルタリング用）
    - `procedure`エンドポイントの一般的な動詞：`create`、`update`、`delete`、`upsert`、`put`
- `subscription`には「subscribe-複数形名詞」を使用してください
    - 例：`subscribeLabels`
- `permission-set`スキーマの命名規則はまだ確立されていませんが、おそらく「auth」プレフィックスが付くでしょう（例：`authBasic`）
-  エンドポイントが実験的、不安定、または相互運用を意図していない場合は、NSID名に示してください
    - 例：NSIDの階層に`.temp.`または`.unspecced.`を含める
- 一般的なプログラミング言語の慣例と衝突する一般的な名前を避けてください
    - 例：スキーマ名に`default`や`length`を使わない

<Heading level={2} id="documentation">ドキュメンテーション</Heading>

- すべての`main`スキーマ定義（レコード、APIエンドポイントなど）にdescriptionを追加してください
    - APIエンドポイントの場合、descriptionに認証が必須かどうか、認証がオプションの場合にレスポンスがパーソナライズされるかどうかを記載してください
- 曖昧性のあるフィールドとプロパティにdescriptionを追加してください。これは`uri`や`cid`のような一般的な名前を持つフィールドに特に重要です（何のCIDですか？）。

NSID名前空間グループ化

- 多くのアプリケーションやプロジェクトは複数の異なる機能を持つため、どのタイプのスキーマもNSIDの階層でグループを表現できます
    - 例：`app.bsky.feed.*`、`app.bsky.graph.*`
- 非常に単純なアプリケーションであれば、すべてのエンドポイントを単一のNSIDグループに含めることができます-
-  同じ名前空間内の複数のスキーマまたはサードパーティによって再利用される可能性がある定義には、`.defs`スキーマを使用してください
    - 例：`app.bsky.feed.defs`
    - 個別のスキーマファイルに切り出すと、他のスキーマファイルの廃止や削除が再利用に影響しなくなります
- グループ、名前、および定義間の競合や混同を避けてください
    - 例：`app.bsky.feed.post#main`に対する`app.bsky.feed.post.main`や、`com.example.record#foo`と`com.example.record.foo`の共存
    - または`app.bsky.feed`（レコード）と`app.bsky.feed.post`（`app.bsky.feed`はグループ）の両方を定義すること

<Heading level={2} id="other-guidelines">その他のガイドライン</Heading>

- 使えるなら文字列フィールドの形式（format）を指定してください
- レコード内の文字列フィールドは、形式指定がない場合、ほとんどにおいて最大長を持つべきです
    - 形式と長さ制限で重複する指定をしないでください
    - 意味的または視覚的な理由で文字列の長さを制限する場合、書記素制限を使用して言語間である程度の一貫性を確保するべきです。この場合、データサイズ（バイト）の制限も追加してください。1書記素あたり10〜20バイトの比率が推奨されます。
- レコードにおける文字列型とバイト型は、データサイズ制約が強い用途向けです。より大きなサイズのテキストまたはバイナリデータの場合、blob参照を使用してください。これには、長文テキストや構造化データも含まれます。
- 列挙セットは「閉じている」ため、スキーマ進化ルールを破らずに更新または拡張することはできません。このため、ほとんどの場合で避けるべきです。
    - 文字列の場合、`knownValues`はより柔軟な代替案を提供します
- 文字列の`knownValues`には単純な文字列定数が含まれるか、`token`へのスキーマ参照が含まれる場合があります（例：`"com.example.defs#tokenOne"`という文字列）
    - トークンは拡張メカニズムを提供し、主観的な定義を持つ値や時間とともに拡張される可能性のある値に適しています
    - 例えば`com.atproto.moderation.defs#reasonType`と`com.atproto.sync.defs#hostStatus`を見比べると、前者の方が柔軟で、後者はより制約が強いです
- `com.atproto.repo.strongRef`（レコードへのバージョン指定参照）や`com.atproto.label.defs#label`（配列内のハイドレートされたラベル）などの再利用可能な定義を活用してください
- アカウント識別子を引数（例：クエリパラメータ）として受け取るAPIエンドポイントは、ハンドルしかない場合でもクライアントが`resolveHandle`を呼び出さなくていいように、`at-identifier`を使用するべきです
- レコードスキーマは、他のアカウントへのリファレンスに対して、常にハンドルではなく永続的な識別子（DID）を使用すべきです
- APIエンドポイントは、意味のあるレスポンスデータがない場合でも、常に`encoding`付きの`output`を指定すべきです
    - 良いデフォルトは`application/json`で、スキーマはプロパティ定義のないオブジェクトです
- オプションの`boolean`フィールドは、`false`がデフォルト値および期待値となるように表現すべきです
    - 例えば、エンドポイントが「foo」と「bar」の混合を返すことができ、一般的な動作は「foo」を含めるが「bar」を含めない場合、制御パラメータは`excludeFoo`（デフォルト`false`）と`includeBar`（デフォルト`false`）という名前にして、`excludeBar`（デフォルト`true`）は使いません
- コンテンツハッシュ（CID）は文字列型の形式またはバイナリエンコーディング（`cid-link`）で表現できます
    - レコード間のバージョン付き参照を含むほとんどの状況では、文字列形式が推奨されます。
    - バイナリエンコーディングは主にfirehoseなどのプロトコルレベルのメカニズムに使用されます。

<Heading level={2} id="lexicon-evolition">Lexiconの進化</Heading>

すべてのLexiconはスキーマの進化ルールを破らない範囲で拡張と進化に柔軟であるべきです。これは特にレコードスキーマに当てはまります。Atprotoの分散ストレージモデルを考えると、開発者はネットワーク内のすべてのデータレコードを更新するための確実なメカニズムを持ちません。拡張は元の設計者または他の開発者やプロジェクトから来ることがあります。

実験的なスキーマとプロジェクトは、バリアントNSID（例：名前の階層に`.temp.`を含める）を使用することで、安定したレコードデータスキーマにコミットすることなく、動作中のネットワークで開発できます。

新しいスキーマを宣言することで、大規模な後方互換性のないスキーマ変更が可能です。現在の命名規則は、元の名前に「V2」（または「V3」など）を追加することです。

スキーマを将来の進化と拡張に柔軟にするための設計推奨事項

- データフィールドまたはAPIパラメータが機能に真に必須でない限り、`required`としてマークしないでください
    - `required`フィールドは進化ルールの下では、オプション化または廃止することはできません
- 後方互換性を変更したり、V2スキーマを使ったりせずに、スキーマに新しい`optional`フィールドを追加できますが、新しい`required`フィールドを追加することはできません
- 配列でアトミックデータ型の代わりに、単一の要素/フィールドを含むオブジェクト型を使用して、将来追加のコンテキストを含めることを許可してください
    - 例えば、アカウント（DID）を一覧するAPIレスポンスでは、文字列の配列の代わりに、DID用の`account`フィールドを持つオブジェクトの配列を返してください
- ほぼすべての状況で共用体を「open」にして、将来的な型や値の追加を許可してください
    - オープンな共用体は、サードパーティが自己定義されたデータ型を含めるための拡張メカニズムです

<Heading level={2} id="desugn-paterns">デザインパターン</Heading>

- `query` APIエンドポイントのページネーションの基本的な慣例
    - クエリパラメータにはオプションの`limit`（整数）とオプションの`cursor`（文字列）が含まれます
    - 出力のボディには、オプションの`cursor`（文字列）と、必須のレスポンスオブジェクト配列（コンテキスト固有の複数形フィールド名を持つ）が含まれます
    - クライアントによる最初のリクエストでは`cursor`を定義しません。レスポンスに`cursor`が含まれている場合はより多くの結果が利用可能であり、クライアントは新しい`cursor`でクエリを再度実行して追加の結果を取得します
    - `limit`値は上限であり、より多くの結果が利用可能だとしても、レスポンスには少ない（またはゼロの）結果が含まれる可能性があります。ページネーションの完了を示すのは、レスポンスに`cursor`がないことです。レスポンスからは、削除が示されている場合や他の方法でフィルタリングされた場合、項目が取り除かれることがあります。
- 「シーケンシング」とバックフィルカーソルをサポートするサブスクリプションエンドポイントの慣例
    - エンドポイントにはオプションの`cursor`クエリパラメータ（整数）があります
    - すべてのコアメッセージタイプに`seq`フィールド（整数）が含まれます。メッセージの`seq`は単調に増加しますが、ギャップがある場合があります。
    - `cursor`が提供されない場合、サーバーはその時点以降のメッセージを返し始めます
    - `cursor`が提供されている場合、サーバーは一致する`seq`で始まる履歴メッセージを返し、現在のストリームまで続きます
    - `cursor`が未来を指す場合（現在のシーケンスより高い）、エラーが返され、接続が閉じられます
    - `cursor`が最も古い利用可能なメッセージより古い場合（または0の場合）、サーバーは`OutdatedCursor`という名前のメッセージを返した後、最も古い利用可能なものからメッセージを返します
-  APIレスポンスのよくあるパターンは、データレコードの「ハイドレートされたビュー」を含めることです。例えば、アカウントのプロフィールを表示する場合、レスポンスにはメディアファイルのCDNまたはサムネイルURL、モデレーションラベル、グローバルな集計値、およびビューア固有のソーシャルグラフコンテキストが含まれる場合があります。
    - 詳細ビューの場合、フィールドのスーパーセットを持つ新しいスキーマを定義する代わりに、元のレコードをそのまま含めることがベストプラクティスです。これはメンテナンスが簡単で（フィールドの更新漏れはありえません）、スキーマ外の拡張データまで含まれることを保証します。
    - 閲覧者依存のメタデータはオプションであり、descriptionで示されているか、サブオブジェクトの下にグループ化される必要があります。これにより、スキーマが公開ビューとログインビューの間で再利用可能になり、どの情報がいつ利用可能かが明確になります。
    - アプリケーション開発者にとって有用なパターンは、レコードへの参照（例：AT URIまたは同等のもの、および複数の参照）を受け入れるAPIエンドポイントがあり、ハイドレートされたデータオブジェクトを返すことです。
- `app.bsky.richtext.facet`システムは、フル機能のマークアップ言語よりも単純で安全な方法で短い文字列を装飾するために使用できます
    - 詳細については、[『Why RichText facets in Bluesky』](https://www.pfrazee.com/blog/why-facets)を参照してください
    - この機能の型システムは、追加の型で拡張できるオープンな共用体です
    - 長文テキストにはMarkdownを使うこともできます
- レコードを拡張または補足するための一つのパターンは、同じリポジトリに同じレコードキーで異なる型（コレクション）を持つ「サイドカー」レコードを定義することです。
    - サイドカーレコードは、元のLexicon設計者または別の開発者によって定義および管理できます。
    - サイドカーレコードは、元のレコードへの強い参照を壊さずに更新（変更）できます。
    - サイドカーコンテキストはAPIレスポンスに含めることができます。
- Atprotoアカウントはネットワーク内のあらゆるアプリケーションと柔軟に使用できるため、どのアカウントが特定のアプリケーションに参加しているかは曖昧な場合があります。モダリティを示す既知の代表的なレコード型があり、クライアントが活動中のアカウントにそのようなレコードを作成するなら、これを明確にすることができます。このレコードを削除することで、ユーザーがアクティブでなくなったと示せます。レコードの既知インスタンスが唯一（固定レコードキー）である場合に、この手法は特に機能します。
    - 例えば、アプリ固有の「プロフィール」または「宣言」レコードは、たとえ空であっても存在していれば、アカウントが関連アプリに一度はログインしたことを示すことができます。
    - バックフィルサービスは、指定されたシグナリングレコードを持つネットワーク内のすべてのアカウントを列挙し、そのレコードの削除を非アクティブ化として処理できます。
    - このデザインパターンは、新規アプリのモダリティに強く推奨されます。
