import {Heading} from '@/components/Heading'

export const metadata = {
  title: 'Lexicon 스타일 가이드',
  description:
    '새로운 atproto 스키마 생성을 위한 권장 스타일 가이드',
}

# Lexicon 스타일 가이드

Lexicon 스키마를 설계할 때 권장되는 관례와 모범 사례는 다음과 같습니다.

이름 표기법 관례:

- 스키마 및 속성: 스키마와 이름에는 `lowerCamelCase` 를 사용하세요 (`UpperCamelCase` , `snake_case` , `ALL_CAPS` 등과 대비됨). 
- API 에러 이름: `UpperCamelCase` 
- 고정 문자열(예: `knownValues`): `kebab-case` 

허용되는 문자:

- 필드 이름은 스키마 이름(NSID 이름 세그먼트)과 동일한 문자 집합을 유지해야 합니다: ASCII 영문자 및 숫자, 첫 글자는 숫자가 아니어야 함, 하이픈 미사용, 대소문자 구분.
    - 기존 외부 스키마의 이름을 보존해야 하는 경우 등 일부 상황에서는 예외가 정당화될 수 있습니다.
    - 데이터 객체는 중첩 수준에 관계없이 `$` 로 시작하는 스키마 지정 필드 이름을 포함해서는 안 됩니다. 이는 향후 프로토콜 수준의 확장을 위해 예약되어 있습니다.

명명 규칙:

- 레코드(record) 스키마에는 단수 명사를 사용하세요. 
    - 예: `post` , `like` , `profile` 
- 쿼리(query) 및 프로시저(procedure) 엔드포인트에는 “동사-명사” 형태를 사용하세요. 
    - 예: `getPost` , `listLikes` , `putProfile` 
    - `query` 엔드포인트에서 자주 쓰이는 동사: `get` , `list` , `search` (전체 텍스트 검색용), `query` (유연한 매칭이나 필터링용)
    - `procedure` 엔드포인트에서 자주 쓰이는 동사: `create` , `update` , `delete` , `upsert` , `put` 
- 구독(subscription) 에는 “subscribe-복수-명사” 형태를 사용하세요. 
    - 예: `subscribeLabels` 
- 권한 세트(permission-set) 스키마 명명 규칙은 아직 확립되지 않았으나, 아마도 “auth” 접두사를 가질 것입니다 (예: `authBasic` ). 
- 엔드포인트가 실험적이거나 불안정하거나 상호 운용성을 목적으로 하지 않는 경우 NSID 이름에 이를 표시하세요.
    - 예: NSID 계층 구조에 `.temp.` 또는 `.unspecced.` 를 포함합니다.
- 대중적인 프로그래밍 언어의 관례와 충돌하는 일반적인 이름은 피하세요.
    - 예: 스키마 이름으로 `default` 나 `length` 를 사용하는 것을 피하세요.

문서화 및 완전성:

- 모든 메인(`main`) 스키마 정의(레코드, API 엔드포인트 등)에 설명을 추가하세요. 
    - API 엔드포인트의 경우, 인증 필요 여부와 인증이 선택 사항일 때 응답이 개인화되는지 여부를 설명에 명시하세요.
- 모호할 수 있는 필드와 속성에 설명을 추가하세요. 이는 `uri` 나 `cid` 와 같이 일반적인 이름을 가진 필드에서 특히 중요합니다: 무엇의 CID인가요?

NSID 네임스페이스 그룹화:

- 많은 애플리케이션과 프로젝트는 여러 개의 뚜렷한 기능이나 특징을 가지며, 모든 유형의 스키마는 NSID 계층 구조에서 이러한 그룹화를 나타낼 수 있습니다.
    - 예: `app.bsky.feed.*` , `app.bsky.graph.*` 
- 매우 단순한 애플리케이션은 모든 엔드포인트를 단일 NSID “그룹” 아래에 포함할 수 있습니다.
- 동일한 네임스페이스 내의 여러 스키마 또는 제3자가 재사용할 수 있는 정의에는 `.defs` 스키마를 사용하세요. 
    - 예: `app.bsky.feed.defs` 
    - 이러한 정의를 별도의 스키마 파일에 넣으면 다른 스키마 파일의 폐기(deprecation)나 삭제가 재사용에 영향을 주지 않습니다.
- 그룹, 이름, 정의 간의 충돌과 혼동을 피하세요.
    - 예: `app.bsky.feed.post#main` 대 `app.bsky.feed.post.main` , 또는 `com.example.record#foo` 와 `com.example.record.foo` 
    - 또는 `app.bsky.feed` (레코드로 정의)와 `app.bsky.feed.post` ( `app.bsky.feed` 를 그룹으로 사용)를 동시에 정의하는 경우.

기타 가이드라인:

- 적절한 경우 문자열 필드의 형식을 지정하세요.
- 레코드의 문자열 필드는 형식(format) 유형이 없는 경우 거의 항상 최대 길이를 가져야 합니다.
    - 형식과 길이 제한을 중복으로 지정하지 마세요.
    - 의미적 또는 시각적 이유로 문자열 길이를 제한하는 경우, 인간의 언어 간 일관성을 보장하기 위해 자소(grapheme) 제한을 사용해야 합니다. 이 경우 데이터 크기(바이트) 제한도 함께 추가해야 합니다. 1자소당 10~20바이트 사이의 비율이 권장됩니다.
- 문자열 및 바이트 레코드 데이터 유형은 제한된 데이터 크기 사용 사례를 위한 것입니다. 더 큰 크기의 텍스트나 바이너리 데이터의 경우 블롭(blob) 참조를 사용해야 합니다. 여기에는 장문 텍스트와 구조화된 데이터가 포함될 수 있습니다.
- 열거형(Enum) 세트는 “닫혀(closed)” 있으며 스키마 진화 규칙을 어기지 않고는 업데이트하거나 확장할 수 없습니다. 이러한 이유로 열거형은 거의 항상 피해야 합니다.
    - 문자열의 경우 `knownValues` 가 더 유연한 대안을 제공합니다.
- 문자열 `knownValues` 에는 단순한 문자열 상수나 토큰(`token`) 에 대한 스키마 참조(예: 문자열 `"com.example.defs#tokenOne"` )가 포함될 수 있습니다. 
    - 토큰은 확장 메커니즘을 제공하며, 주관적인 정의를 가지거나 시간이 지남에 따라 확장될 수 있는 값에 잘 작동합니다.
    - `com.atproto.moderation.defs#reasonType` (확장 가능)과 `com.atproto.sync.defs#hostStatus` (더 제한적)라는 두 가지 대조적인 사례를 참조하세요.
- `com.atproto.repo.strongRef` (레코드에 대한 버전 관리된 참조용)나 `com.atproto.label.defs#label` (배열 내의 구체화된 라벨용)과 같은 재사용 가능한 정의를 활용하세요. 
- 계정 식별자를 인자로 받는 API 엔드포인트(예: 쿼리 파라미터)는 `at-identifier` 를 사용해야 합니다. 그래야 클라이언트가 계정 핸들만 가지고 있는 경우 `resolveHandle` 을 호출하는 것을 피할 수 있습니다. 
- 레코드 스키마는 다른 계정을 참조할 때 핸들 대신 항상 영구 식별자(DID) 를 사용해야 합니다. 
- API 엔드포인트는 유의미한 응답 데이터가 없더라도 항상 `encoding` 과 함께 출력(`output`) 을 지정해야 합니다. 
    - 좋은 기본값은 정의된 속성이 없는 객체를 스키마로 하는 `application/json` 입니다. 
- 선택 사항인 불리언(`boolean`) 필드는 `false` 가 기본값이자 기대값이 되도록 표현해야 합니다. 
    - 예를 들어 엔드포인트가 “foo”와 “bar”를 섞어서 반환할 수 있고, 일반적인 동작이 “foo”는 포함하지만 “bar”는 포함하지 않는 것이라면, 제어 파라미터의 이름은 `excludeBar` (기본값 `true` )가 아니라 `excludeFoo` (기본값 `false` ) 및 `includeBar` (기본값 `false` )로 명명해야 합니다. 
- 콘텐츠 해시(CID)는 문자열 형식이나 바이너리 인코딩( `cid-link` )으로 표현될 수 있습니다. 
    - 레코드 간의 버전 관리된 참조를 포함한 대부분의 상황에서는 문자열 형식이 권장됩니다.
    - 바이너리 인코딩은 주로 파이어호스(firehose)와 같은 프로토콜 수준의 메커니즘에 사용됩니다.

<Heading level={2} id="schema-evolution-and-extension">스키마 진화 및 확장</Heading>

모든 스키마는 Lexicon 스키마 진화 규칙을 어기지 않으면서 시간이 지남에 따라 확장과 진화에 유연해야 합니다. 이는 특히 레코드 스키마에서 더욱 그렇습니다. atproto의 분산 저장 모델을 고려할 때, 개발자는 네트워크의 모든 데이터 레코드를 업데이트할 수 있는 신뢰할 수 있는 메커니즘을 가지고 있지 않습니다. 확장은 원래 설계자나 다른 개발자 및 프로젝트에서 올 수 있습니다.

실험적인 스키마와 프로젝트는 변형된 NSID(예: 이름 계층 구조에 `.temp.` 포함)를 사용하여 안정적인 레코드 데이터 스키마를 약속하지 않고도 실제 네트워크에서 개발을 진행할 수 있습니다. 

스키마의 대대적인 하위 호환성 없는 변경은 새로운 스키마를 선언함으로써 가능합니다. 현재의 명명 관례는 원래 이름 뒤에 “V2”(또는 “V3” 등)를 붙이는 것입니다.

스키마를 미래의 진화와 확장에 유연하게 만들기 위한 설계 권장 사항:

- 기능에 진정으로 필수적인 경우가 아니면 데이터 필드나 API 파라미터를 필수(`required`) 로 표시하지 마세요. 
    - 진화 규칙에 따라 `required` 필드는 선택 사항으로 만들거나 폐기할 수 없습니다. 
- 하위 호환성을 변경하거나 V2 스키마를 요구하지 않고도 스키마에 새로운 선택적(`optional`) 필드를 추가할 수 있지만, 새로운 `required` 필드는 추가할 수 없습니다. 
- 배열에 원자적(atomic) 데이터 유형을 사용하는 대신 단일 요소/필드를 포함하는 객체 유형을 사용하여 향후 추가적인 컨텍스트가 포함될 수 있도록 하세요.
    - 예를 들어, 계정(DID)을 나열하는 API 응답에서 문자열 배열 대신 각각 DID를 나열하는 `account` 필드가 있는 객체 배열을 반환하세요. 
- 거의 모든 상황에서 공용체(union) 를 “개방형(open)”으로 만들어 향후 유형이나 값이 추가될 수 있도록 하세요. 
    - 개방형 공용체는 제어권을 가진 당사자가 아닌 제3자가 자체적으로 정의한 데이터 유형을 포함할 수 있는 확장 메커니즘이 될 수 있습니다.

<Heading level={2} id="design-patterns">설계 패턴</Heading>

- 쿼리(`query`) API 엔드포인트의 페이지네이션(pagination)에는 기본적인 관례가 있습니다. 
    - 쿼리 파라미터에는 선택 사항인 `limit` (정수) 및 `cursor` (문자열)가 포함됩니다. 
    - 출력 바디에는 선택 사항인 `cursor` (문자열)와 필수 항목인 응답 객체 배열(컨텍스트별로 복수형 필드 이름 사용)이 포함됩니다. 
    - 초기 클라이언트 요청은 `cursor` 를 정의하지 않습니다. 응답에 `cursor` 가 포함되어 있으면 더 많은 결과를 사용할 수 있다는 뜻이며, 클라이언트는 더 많은 결과를 얻기 위해 새로운 `cursor` 로 다시 쿼리해야 합니다. 
    - `limit` 값은 상한선이며, 추가 결과가 남아 있더라도 응답에 더 적은(또는 0개의) 결과가 포함될 수 있습니다. 페이지네이션이 완료되었음을 나타내는 것은 응답에 `cursor` 가 없는 경우입니다. 응답 세트에서 툼스톤(tombstone) 처리되었거나 다른 방식으로 필터링된 항목은 제거될 수 있습니다. 
- “시퀀싱(sequencing)” 및 백필(backfill) 커서를 지원하는 구독 엔드포인트에 대한 관례도 있습니다.
    - 엔드포인트에는 선택 사항인 `cursor` 쿼리 파라미터(정수)가 있습니다. 
    - 모든 핵심 메시지 유형에는 `seq` 필드(정수)가 포함됩니다. 메시지의 `seq` 는 단조 증가하지만 간격이 있을 수 있습니다. 
    - `cursor` 가 제공되지 않으면 서버는 현재 시점부터 새로운 메시지를 반환하기 시작합니다. 
    - `cursor` 가 제공되면 서버는 일치하는 `seq` 로 시작하는 과거 메시지를 반환하려고 시도하며 현재 스트림까지 계속 이어집니다. 
    - `cursor` 가 미래 시점(현재 시퀀스보다 높음)이면 에러를 반환하고 연결을 닫습니다. 
    - `cursor` 가 사용 가능한 가장 오래된 메시지보다 더 오래되었거나(또는 0인 경우), 서버는 `OutdatedCursor` 라는 이름의 정보 메시지를 반환한 후 사용 가능한 가장 오래된 메시지부터 반환을 시작합니다. 
- API 응답에서 흔히 볼 수 있는 패턴은 데이터 레코드의 “구체화된 뷰(hydrated views)” 를 포함하는 것입니다. 예를 들어 계정의 프로필을 볼 때 응답에는 미디어 파일의 CDN 또는 썸네일 URL, 중재 라벨, 전역 집계 정보, 뷰어별 소셜 그래프 컨텍스트 등이 포함될 수 있습니다. 
    - 상세 뷰의 경우, 필드의 슈퍼셋(superset)을 갖는 새 스키마를 정의하는 대신 원래 레코드를 그대로(verbatim) 포함하는 것이 모범 사례입니다. 이렇게 하면 유지 관리가 더 쉽고(필드 업데이트를 잊어버릴 일이 없음), 스키마 외의 확장 데이터가 포함되도록 보장합니다.
    - 뷰어별 메타데이터는 선택 사항이어야 하며, 설명에 표시하거나 하위 객체 아래에 그룹화해야 합니다. 이렇게 하면 “공개” 뷰와 “로그인” 뷰 간에 스키마를 재사용할 수 있으며, 언제 어떤 정보를 사용할 수 있는지 더 명확해집니다.
    - 애플리케이션 개발자에게 유용한 패턴은 레코드 참조(예: AT URI 또는 이에 준하는 식이나 여러 참조)를 받아 구체화된 데이터 객체를 반환하는 API 엔드포인트를 확보하는 것입니다.
- `app.bsky.richtext.facet` 시스템을 사용하면 전체 기능을 갖춘 마크업 언어보다 더 단순하고 안전한 방식으로 짧은 텍스트 문자열에 주석을 달 수 있습니다. 
    - 자세한 내용은 ["Bluesky의 RichText 패싯을 사용하는 이유"](https://www.pfrazee.com/blog/why-facets) 를 참조하세요. 
    - 특징 유형 시스템은 추가적인 유형으로 확장될 수 있는 개방형 공용체입니다.
    - 마크다운과 같이 더 강력한 시스템은 장문 텍스트에 더 적합합니다.
- 레코드를 확장하거나 보완하는 한 가지 패턴은 동일한 레코드 키를 갖고 유형(컬렉션)이 다른 “사이드카(sidecar)” 레코드를 동일한 계정 저장소에 정의하는 것입니다. 
    - 사이드카 레코드는 원래 Lexicon 설계자나 독립적인 개발자가 정의하고 관리할 수 있습니다.
    - 사이드카 레코드는 원래 레코드에 대한 강한 참조(strong references)를 깨지 않고도 업데이트(변형)될 수 있습니다.
    - 사이드카 컨텍스트는 API 응답에 포함될 수 있습니다.
- atproto 계정은 네트워크의 모든 애플리케이션에서 유연하게 사용될 수 있기 때문에, 어떤 계정이 특정 앱 방식에 참여하고 있는지 모호할 수 있습니다. 해당 방식에 대한 알려진 대표 레코드 유형이 있고 클라이언트가 활성 계정에 대해 그러한 레코드를 생성한다면 이를 명확히 할 수 있습니다. 이 레코드를 삭제하는 것이 사용자가 더 이상 활성 상태가 아님을 나타내는 방법이 될 수 있습니다. 이는 레코드가 단일한 고정 레코드 키를 가질 때 가장 잘 작동합니다.
    - 예를 들어, 앱 전용 “프로필” 또는 “선언(declaration)” 레코드는 레코드가 “비어 있더라도” 계정이 관련 앱에 적어도 한 번은 로그인했음을 나타낼 수 있습니다.
    - 백필 서비스는 네트워크에서 주어진 신호 레코드를 가진 모든 계정을 나열할 수 있으며, 해당 레코드의 삭제를 해당 방식의 비활성화로 처리할 수도 있습니다.
    - 이 설계 패턴은 새로운 앱 방식에 강력히 권장됩니다.